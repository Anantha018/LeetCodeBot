{
    "1. Two Sum": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        m = {}\n        for i, x in enumerate(nums):\n            y = target - x\n            if y in m:\n                return [m[y], i]\n            m[x] = i",
    "2. Add Two Numbers": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def addTwoNumbers(\n        self, l1: Optional[ListNode], l2: Optional[ListNode]\n    ) -> Optional[ListNode]:\n        dummy = ListNode()\n        carry, curr = 0, dummy\n        while l1 or l2 or carry:\n            s = (l1.val if l1 else 0) + (l2.val if l2 else 0) + carry\n            carry, val = divmod(s, 10)\n            curr.next = ListNode(val)\n            curr = curr.next\n            l1 = l1.next if l1 else None\n            l2 = l2.next if l2 else None\n        return dummy.next",
    "3. Longest Substring Without Repeating Characters": "class Solution:\n  def lengthOfLongestSubstring(self, s): # map for index\n    d = {} # value => its index\n    i = 0\n    ans = 0\n    for j, c in enumerate(s):\n      if c in d:\n        # mast max check i, example \"abba\"\n        i = max(i, d[c] + 1)\n      d[c] = j\n      ans = max(ans, j - i + 1)\n    return ans\n\n\n",
    "4. Median of Two Sorted Arrays": "class Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n\n        def findKth(i: int, j: int, k: int) -> float:\n            if i >= m:\n                return nums2[j + k - 1]\n            if j >= n:\n                return nums1[i + k - 1]\n            if k == 1:\n                return min(nums1[i], nums2[j])\n\n            # Division a // b :  floordiv(a, b)\n            midVal1 = nums1[i + k // 2 - 1] if i + k // 2 - 1 < m else math.inf\n            midVal2 = nums2[j + k // 2 - 1] if j + k // 2 - 1 < n else math.inf\n\n            if midVal1 < midVal2:\n                return findKth(i + k // 2, j, k - k // 2) # '+' or '-' k//2\n            else:\n                return findKth(i, j + k // 2, k - k // 2)\n\n        m = len(nums1)\n        n = len(nums2)\n        # Division a // b :  floordiv(a, b)\n        left = (m + n + 1) // 2 \n        right = (m + n + 2) // 2\n        return (findKth(0, 0, left) + findKth(0, 0, right)) / 2.0\n\n############\n\n# iteration version\nclass Solution(object):\n  def findMedianSortedArrays(self, nums1, nums2):\n    a, b = sorted((nums1, nums2), key=len)\n    m, n = len(a), len(b)\n    after = (m + n - 1) / 2\n    lo, hi = 0, m\n    while lo < hi:\n      i = (lo + hi) / 2\n      if after - i - 1 < 0 or a[i] >= b[after - i - 1]:\n        hi = i\n      else:\n        lo = i + 1\n    i = lo\n    nextfew = sorted(a[i:i + 2] + b[after - i:after - i + 2])\n    return (nextfew[0] + nextfew[1 - (m + n) % 2]) / 2.0",
    "5. Longest Palindromic Substring": "class Solution:\n    def longestPalindrome(self, s: str) -> str:\n        mlen = 0\n        start = end = 0\n        n = len(s)\n        dp = [ [False] * n for i in range(n) ]\n\n        for j in range(n):\n            for i in range(j + 1):\n                dp[i][j] = (i == j) or (s[i] == s[j] and j - i == 1) or (s[i] == s[j] and dp[i + 1][j - 1])\n                if dp[i][j] is True and j - i + 1 > mlen:\n                    mlen = j - i + 1\n                    start = i\n                    end = j\n\n        return s[start: end + 1]\n\n######\n\n",
    "6. ZigZag Conversion": "class Solution:\n    def convert(self, s: str, numRows: int) -> str:\n        if numRows == 1:\n            return s\n        group = 2 * numRows - 2\n        ans = []\n        for i in range(1, numRows + 1):\n            interval = group if i == numRows else 2 * numRows - 2 * i\n            idx = i - 1\n            while idx < len(s):\n                ans.append(s[idx])\n                idx += interval\n                interval = group - interval\n                if interval == 0:\n                    interval = group\n        return ''.join(ans)\n\n############\n\nclass Solution(object):\n  def convert(self, s, numRows):\n    \"\"\"\n    :type s: str\n    :type numRows: int\n    :rtype: str\n    \"\"\"\n    if numRows <= 1:\n      return s\n    n = len(s)\n    ans = []\n    step = 2 * numRows - 2\n    for i in range(numRows):\n      one = i\n      two = -i\n      while one < n or two < n:\n        if 0 <= two < n and one != two and i != numRows - 1:\n          ans.append(s[two])\n        if one < n:\n          ans.append(s[one])\n        one += step\n        two += step\n    return \"\".join(ans)",
    "7. Reverse Integer": "class Solution:\n    def reverse(self, x: int) -> int:\n        ans = 0\n        mi, mx = -(2**31), 2**31 - 1\n        while x:\n            if ans < mi // 10 + 1 or ans > mx // 10:\n                return 0\n            y = x % 10\n            if x < 0 and y > 0:\n                y -= 10\n            ans = ans * 10 + y\n            x = (x - y) // 10\n        return ans",
    "9. Palindrome Number": "class Solution:\n    def isPalindrome(self, x: int) -> bool:\n        if x < 0 or (x and x % 10 == 0):\n            return False\n        y = 0\n        while y < x:\n            y = y * 10 + x % 10\n            x //= 10\n        return x in (y, y // 10)",
    "10. Regular Expression Matching": "class Solution:\n    def isMatch(self, s: str, p: str) -> bool:\n        m, n = len(s), len(p)\n        f = [[False] * (n + 1) for _ in range(m + 1)]\n        f[0][0] = True\n        for i in range(m + 1):\n            for j in range(1, n + 1):\n                if p[j - 1] == \"*\":\n                    f[i][j] = f[i][j - 2]\n                    if i > 0 and (p[j - 2] == \".\" or s[i - 1] == p[j - 2]):\n                        f[i][j] |= f[i - 1][j]\n                elif i > 0 and (p[j - 1] == \".\" or s[i - 1] == p[j - 1]):\n                    f[i][j] = f[i - 1][j - 1]\n        return f[m][n]",
    "11. Container With Most Water": "class Solution:\n    def maxArea(self, height: List[int]) -> int:\n        i, j = 0, len(height) - 1\n        ans = 0\n        while i < j:\n            t = (j - i) * min(height[i], height[j])\n            ans = max(ans, t)\n            if height[i] < height[j]:\n                i += 1\n            else:\n                j -= 1\n        return ans",
    "12. Integer to Roman": "class Solution:\n    def intToRoman(self, num: int) -> str:\n        cs = ('M', 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I')\n        vs = (1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1)\n        ans = []\n        for c, v in zip(cs, vs):\n            while num >= v:\n                num -= v\n                ans.append(c)\n        return ''.join(ans)",
    "13. Roman to Integer": "class Solution:\n    def romanToInt(self, s: str) -> int:\n        d = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000}\n        return sum((-1 if d[a] < d[b] else 1) * d[a] for a, b in pairwise(s)) + d[s[-1]]",
    "14. Longest Common Prefix": "class Solution:\n    def longestCommonPrefix(self, strs: List[str]) -> str:\n        for i in range(len(strs[0])):\n            for s in strs[1:]:\n                if len(s) <= i or s[i] != strs[0][i]:\n                    return s[:i]\n        return strs[0]",
    "15. 3Sum": "class Solution:\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\n        nums.sort()\n        n = len(nums)\n        ans = []\n        for i in range(n - 2):\n            if nums[i] > 0:\n                break\n            if i and nums[i] == nums[i - 1]:\n                continue\n            j, k = i + 1, n - 1\n            while j < k:\n                x = nums[i] + nums[j] + nums[k]\n                if x < 0:\n                    j += 1\n                elif x > 0:\n                    k -= 1\n                else:\n                    ans.append([nums[i], nums[j], nums[k]])\n                    j, k = j + 1, k - 1\n                    while j < k and nums[j] == nums[j - 1]:\n                        j += 1\n                    while j < k and nums[k] == nums[k + 1]:\n                        k -= 1\n        return ans",
    "16. 3Sum Closest": "class Solution:\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\n        nums.sort()\n        n = len(nums)\n        ans = inf\n        for i, v in enumerate(nums):\n            j, k = i + 1, n - 1\n            while j < k:\n                t = v + nums[j] + nums[k]\n                if t == target:\n                    return t\n                if abs(t - target) < abs(ans - target):\n                    ans = t\n                if t > target:\n                    k -= 1\n                else:\n                    j += 1\n        return ans",
    "17. Letter Combinations of a Phone Number": "class Solution:\n    def letterCombinations(self, digits: str) -> List[str]:\n        if not digits:\n            return []\n        d = [\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"]\n        ans = [\"\"]\n        for i in digits:\n            s = d[int(i) - 2]\n            ans = [a + b for a in ans for b in s]\n        return ans",
    "18. 4Sum": "# k-sum\nclass Solution:\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\n        nums.sort()\n        return self.kSum(nums, target, 0, 4)\n\n    def kSum(self, nums: List[int], target: int, start: int, k: int) -> List[List[int]]:\n        res = []\n        if start == len(nums) or nums[start] * k > target or target > nums[-1] * k:\n            return res\n        if k == 2:\n            return self.twoSum(nums, target, start)\n        for i in range(start, len(nums)):\n            if i == start or nums[i - 1] != nums[i]:\n                # here is a hidden matching target==0\n                # if not matching target, then kSum() will return empty list\n                for sset in self.kSum(nums, target - nums[i], i + 1, k - 1):\n                    # if kSum(k-1) return empty, it will not execute this line\n                    res.append([ nums[i] ] + sset) # put nums[i] in a list\n        return res\n\n    def twoSum(self, nums: List[int], target: int, start: int) -> List[List[int]]:\n        res = []\n        lo, hi = start, len(nums) - 1\n        while lo < hi:\n            s = nums[lo] + nums[hi]\n            if s < target or (lo > start and nums[lo] == nums[lo - 1]):\n                lo += 1\n            elif s > target or (hi < len(nums) - 1 and nums[hi] == nums[hi + 1]):\n                hi -= 1\n            else:\n                res.append([nums[lo], nums[hi]])\n                # continue searching, could be multiple answers\n                lo += 1\n                hi -= 1\n        return res\n\n#########\n\n",
    "19. Remove Nth Node From End of List": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\n        dummy = ListNode(next=head)\n        fast = slow = dummy\n        for _ in range(n):\n            fast = fast.next\n        while fast.next:\n            slow, fast = slow.next, fast.next\n        slow.next = slow.next.next\n        return dummy.next",
    "20. Valid Parentheses": "class Solution:\n    def isValid(self, s: str) -> bool:\n        stk = []\n        d = {'()', '[]', '{}'}\n        for c in s:\n            if c in '({[':\n                stk.append(c)\n            elif not stk or stk.pop() + c not in d:\n                return False\n        return not stk",
    "21. Merge Two Sorted Lists": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# without ops after while loop\nclass Solution:\n    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:\n        dummy = ListNode()\n        current = dummy\n        while list1 or list2:\n            v1 = list1.val if list1 else float('inf')\n            v2 = list2.val if list2 else float('inf')\n\n            if v1 < v2:\n                current.next = list1\n                list1 = list1.next\n            else:\n                current.next = list2\n                list2 = list2.next\n            current = current.next\n\n        return dummy.next\n\n############\n\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n",
    "22. Generate Parentheses": "class Solution:\n    def generateParenthesis(self, n: int) -> List[str]:\n        def dfs(l, r, t):\n            if l > n or r > n or l < r:\n                return\n            if l == n and r == n:\n                ans.append(t)\n                return\n            dfs(l + 1, r, t + '(')\n            dfs(l, r + 1, t + ')')\n\n        ans = []\n        dfs(0, 0, '')\n        return ans\n\n############\n\nclass Solution(object):\n  def generateParenthesis(self, n):\n    \"\"\"\n    :type n: int\n    :rtype: List[str]\n    \"\"\"\n\n    def dfs(left, path, res, n):\n      if len(path) == 2 * n:\n        if left == 0:\n          res.append(\"\".join(path))\n        return\n\n      if left < n:\n        path.append(\"(\")\n        dfs(left + 1, path, res, n)\n        path.pop()\n      if left > 0:\n        path.append(\")\")\n        dfs(left - 1, path, res, n)\n        path.pop()\n\n    res = []\n    dfs(0, [], res, n)\n    return res",
    "23. Merge k Sorted Lists": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\n        setattr(ListNode, \"__lt__\", lambda a, b: a.val < b.val)\n        pq = [head for head in lists if head]\n        heapify(pq)\n        dummy = cur = ListNode()\n        while pq:\n            node = heappop(pq)\n            if node.next:\n                heappush(pq, node.next)\n            cur.next = node\n            cur = cur.next\n        return dummy.next\n\n\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n\n######\n\n\nimport heapq\n\n\n'''\n__lt__(self, other) for <\n__le__(self,other) for <=\n__gt__(self, other) for >\n__ge__(self, other) for >=\n'''\n\n'''\n# or create a wrapper class, without modifying existing node class\nclass NodeWrapper:\n    def __init__(self, node):\n        self.node = node\n    \n    def __lt__(self, other):\n        return self.node.val < other.node.val\n\n'''\n\n# overwrite the comparison function, so the node can be comparable\n# or else, error, TypeError: '<' not supported between instances of 'ListNode' and 'ListNode'\n\n# define 'gt' will also work, so either lt or gt will do the compare job for ListNode\n# ListNode.__gt__ = lambda x, y: (x.val > y.val)\n\nListNode.__lt__ = lambda x, y: (x.val < y.val)\n\n",
    "24. Swap Nodes in Pairs": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        dummy = ListNode(next=head)\n        pre, cur = dummy, head\n        while cur and cur.next:\n            t = cur.next\n            cur.next = t.next\n            t.next = cur\n            pre.next = t\n            pre, cur = cur, cur.next\n        return dummy.next",
    "25. Reverse Nodes in k-Group": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def reverseKGroup(self, head: ListNode, k: int) -> ListNode:\n        '''\n            for reverse 1->2->3->4->5, process is like\n                1->None, 2->3->4->5\n                2->1->None, 3->4->5\n                3->2->1->None, 4->5\n                4->3->2->1->None, 5\n                5->4->3->2->1->None, None\n        '''\n        def reverseList(head):\n            pre, p = None, head\n            while p:\n                pnext = p.next\n                p.next = pre\n                pre = p\n                p = pnext\n            return pre\n\n        dummy = ListNode(next=head)\n        pre = cur = dummy\n        while cur.next:\n            for _ in range(k):\n                cur = cur.next\n                if cur is None:\n                    return dummy.next\n            t = cur.next\n            cur.next = None # cut from next k-group, so to reverseList() for current k-group\n            start = pre.next\n            pre.next = reverseList(start)\n            start.next = t # so now 'start' is the last node of k-group\n            pre = cur = start # same as the reset dummy before while loop\n        return dummy.next\n\n############\n\n# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution(object):\n  def reverseKGroup(self, head, k):\n    \"\"\"\n    :type head: ListNode\n    :type k: int\n    :rtype: ListNode\n    \"\"\"\n\n    def reverseList(head, k):\n      pre = None\n      cur = head\n      while cur and k > 0:\n        tmp = cur.next\n        cur.next = pre\n        pre = cur\n        cur = tmp\n        k -= 1\n      head.next = cur\n      return cur, pre\n\n    length = 0\n    p = head\n    while p:\n      length += 1\n      p = p.next\n    if length < k:\n      return head\n    step = length / k\n    ret = None\n    pre = None\n    p = head\n    while p and step:\n      next, newHead = reverseList(p, k)\n      if ret is None:\n        ret = newHead\n      if pre:\n        pre.next = newHead\n      pre = p\n      p = next\n      step -= 1\n    return ret",
    "26. Remove Duplicates from Sorted Array": "class Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        k = 0\n        for x in nums:\n            if k == 0 or x != nums[k - 1]:\n                nums[k] = x\n                k += 1\n        return k",
    "27. Remove Element": "class Solution:\n    def removeElement(self, nums: List[int], val: int) -> int:\n        k = 0\n        for x in nums:\n            if x != val:\n                nums[k] = x\n                k += 1\n        return k",
    "29. Divide Two Integers": "class Solution:\n    def divide(self, a: int, b: int) -> int:\n        if b == 1:\n            return a\n        if a == -(2**31) and b == -1:\n            return 2**31 - 1\n        sign = (a > 0 and b > 0) or (a < 0 and b < 0)\n        a = -a if a > 0 else a\n        b = -b if b > 0 else b\n        ans = 0\n        while a <= b:\n            x = b\n            cnt = 1\n            while x >= (-(2**30)) and a <= (x << 1):\n                x <<= 1\n                cnt <<= 1\n            a -= x\n            ans += cnt\n        return ans if sign else -ans",
    "30. Substring with Concatenation of All Words": "class Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        cnt = Counter(words)\n        m, n = len(s), len(words)\n        k = len(words[0])\n        ans = []\n        for i in range(k):\n            cnt1 = Counter()\n            l = r = i\n            t = 0\n            while r + k <= m:\n                w = s[r : r + k]\n                r += k\n                if w not in cnt:\n                    l = r\n                    cnt1.clear()\n                    t = 0\n                    continue\n                cnt1[w] += 1\n                t += 1\n                while cnt1[w] > cnt[w]:\n                    remove = s[l : l + k]\n                    l += k\n                    cnt1[remove] -= 1\n                    t -= 1\n                if t == n:\n                    ans.append(l)\n        return ans",
    "31. Next Permutation": "'''\n>>> i = 3\n>>> ~i\n-4\n>>> bool(~i)\nTrue\n#######################\n\n>>> j = -1\n>>> ~j\n0\n>>> bool(~j)\nFalse\n#######################\n\n>>> a = (i for i in range (10, -1, -1) if i < 6)\n>>> a\n<generator object <genexpr> at 0x10a17eeb0>\n>>> next(a)\n5\n>>>\n>>>\n>>> b = (i for i in range (10, -1, -1) if i < 0)\n>>> next(b)\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nStopIteration\n>>> next(b, -1)\n-1\n>>>\n'''\nclass Solution:\n    def nextPermutation(self, nums: List[int]) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        n = len(nums)\n        # next(func, -1) => default value -1\n        i = next((i for i in range(n - 2, -1, -1) if nums[i] < nums[i + 1]), -1)\n        if i != -1:\n            j = next((j for j in range(n - 1, i, -1) if nums[j] > nums[i]))\n            nums[i], nums[j] = nums[j], nums[i]\n        nums[i + 1:] = nums[i + 1:][::-1]\n        # wrong reverse: nums[i + 1:] = nums[i + 1::-1]\n\n##############\n\n'''\n>>> a=[1,2,3]\n>>> reversed(a)\n<list_reverseiterator object at 0x108458be0>\n>>> list(reversed(a))\n[3, 2, 1]\n\n# but, use reversed(a) to directly assign values is ok\n>>> b=[4,5,6,7,8]\n>>> b[:3] = reversed(a)\n>>> b\n[3, 2, 1, 7, 8]\n'''\n",
    "32. Longest Valid Parentheses": "class Solution:\n    def longestValidParentheses(self, s: str) -> int:\n        left = right = 0\n        res = 0\n        for c in s: # from left to right, '(()' => will never hit left==right\n            if c == '(':\n                left += 1\n            else:\n                right += 1\n            if left == right:\n                res = max(res, 2 * left)\n            if left < right:\n                left = right = 0\n\n        left = right = 0 # dont forget to reset\n        for c in reversed(s): # from right to left, '())' => will never hit left==right\n            if c == '(':\n                left += 1\n            else:\n                right += 1\n            if left == right:\n                res = max(res, 2 * left)\n            if left > right: # reverse '<' to '>'\n                left = right = 0\n\n        return res\n\n######\n\n",
    "33. Search in Rotated Sorted Array": "# below 2 solutions, diff is while condition: left ('<' or '<=') right\n\n# I like this better\nclass Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        n = len(nums)\n        left, right = 0, n - 1\n        while left <= right:\n            mid = (left + right) >> 1\n            if nums[mid] == target:\n                return mid\n            elif nums[0] <= nums[mid]: # left half sorted\n                if nums[0] <= target <= nums[mid]:\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            else: # right half sorted\n                if nums[mid] < target <= nums[n - 1]:\n                    left = mid + 1\n                else:\n                    right = mid -1\n        return -1\n\n############\n\n",
    "34. Find First and Last Position of Element in Sorted Array": "'''\n>>> bisect.bisect_left([1,1,1,2,2,2,7,7,7], 2)\n3\n>>> bisect.bisect_left([1,1,1,2,2,2,7,7,7], 2+1)\n6\n\n\n>>> bisect.bisect_right([1,1,1,2,2,2,7,7,7], 2)\n6\n>>> bisect.bisect_right([1,1,1,2,2,2,7,7,7], 2+1)\n6\n\n\n>>> bisect.bisect_left([1,1,1,2,2,2,7,7,7], 0)\n0\n>>> bisect.bisect_left([1,1,1,2,2,2,7,7,7], 1)\n0\n\n# below, even single value for 2, after +1 the index will be different\n>>> bisect.bisect_left([1,2,3,4,5], 2)\n1\n>>> bisect.bisect_left([1,2,3,4,5], 2+1)\n2\n'''\n\nimport bisect\n\nclass Solution:\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\n        l = bisect_left(nums, target)\n        r = bisect_left(nums, target + 1)\n        return [-1, -1] if l == r else [l, r - 1]\n\n############\n\n",
    "35. Search Insert Position": "class Solution:\n    def searchInsert(self, nums: List[int], target: int) -> int:\n        left, right = 0, len(nums)\n        while left < right:\n            mid = (left + right) >> 1\n            if nums[mid] >= target:\n                right = mid\n            else:\n                left = mid + 1\n        return left",
    "36. Valid Sudoku": "class Solution:\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\n        row = [[False] * 9 for _ in range(9)]\n        col = [[False] * 9 for _ in range(9)]\n        sub = [[False] * 9 for _ in range(9)]\n        for i in range(9):\n            for j in range(9):\n                c = board[i][j]\n                if c == '.':\n                    continue\n                num = int(c) - 1\n                k = i // 3 * 3 + j // 3\n                if row[i][num] or col[j][num] or sub[k][num]:\n                    return False\n                row[i][num] = True\n                col[j][num] = True\n                sub[k][num] = True\n        return True",
    "37. Sudoku Solver": "class Solution:\n    def solveSudoku(self, board: List[List[str]]) -> None:\n        def dfs(k):\n            nonlocal ok\n            if k == len(t):\n                ok = True\n                return\n            i, j = t[k]\n            for v in range(9):\n                if row[i][v] == col[j][v] == block[i // 3][j // 3][v] == False:\n                    row[i][v] = col[j][v] = block[i // 3][j // 3][v] = True\n                    board[i][j] = str(v + 1)\n                    dfs(k + 1)\n                    row[i][v] = col[j][v] = block[i // 3][j // 3][v] = False\n                if ok:\n                    return\n\n        row = [[False] * 9 for _ in range(9)]\n        col = [[False] * 9 for _ in range(9)]\n        block = [[[False] * 9 for _ in range(3)] for _ in range(3)]\n        t = []\n        ok = False\n        for i in range(9):\n            for j in range(9):\n                if board[i][j] == '.':\n                    t.append((i, j))\n                else:\n                    v = int(board[i][j]) - 1\n                    row[i][v] = col[j][v] = block[i // 3][j // 3][v] = True\n        dfs(0)",
    "38. Count and Say": "class Solution:\n    def countAndSay(self, n: int) -> str:\n        s = '1'\n        for _ in range(n - 1):\n            i = 0\n            t = []\n            while i < len(s):\n                j = i\n                while j < len(s) and s[j] == s[i]:\n                    j += 1\n                t.append(str(j - i)) # j is now different from i's value\n                t.append(str(s[i]))\n                i = j\n            s = ''.join(t)\n        return s",
    "39. Combination Sum": "class Solution:\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\n        # i: start index for this recursion\n        # s: sum\n        def dfs(i, s):\n            if s == target:\n                ans.append(t.copy())\n                return\n            if s > target:\n                return\n            for j in range(i, len(candidates)):\n                c = candidates[j]\n                t.append(c)\n                dfs(j, s + c)\n                t.pop()\n\n        ans = []\n        t = []\n        # candidates.sort() # diff from combinationSum-II, no need sorting it\n        dfs(0, 0)\n        return ans\n\n############\n\n# dp version\nclass Solution_dp:\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\n        # for each-target (from 1 to target), its dp[i][j]\n        #   => so 3-D array dp[][][]\n        dp = []\n        candidates.sort()\n\n        for i in range(1, target+1):\n            cur = []\n            for j in range(len(candidates)):\n                if candidates[j] > i:\n                    break\n                if candidates[j] == i:\n                    one = [candidates[j]]\n                    cur.append(one)\n                    break\n                for a in dp[i - candidates[j] - 1]:\n                    if candidates[j] > a[0]:\n                        continue\n                    deepCopied = a.copy()\n                    deepCopied.insert(0, candidates[j])\n                    cur.append(deepCopied)\n            dp.append(cur)\n\n        return dp[-1]\n\n\n############\n\nclass Solution(object):\n  def combinationSum(self, candidates, target):\n    \"\"\"\n    :type candidates: List[int]\n    :type target: int\n    :rtype: List[List[int]]\n    \"\"\"\n\n    def dfs(candidates, start, target, path, res):\n      if target == 0:\n        return res.append(path + [])\n\n      for i in range(start, len(candidates)):\n        if target - candidates[i] >= 0:\n          path.append(candidates[i])\n          dfs(candidates, i, target - candidates[i], path, res)\n          path.pop()\n\n    res = []\n    dfs(candidates, 0, target, [], res)\n    return res\n\n#########\n\n",
    "40. Combination Sum II": "class Solution:\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\n        def dfs(i, s):\n            if s > target:\n                return\n            if s == target:\n                ans.append(t.copy())\n                return\n            for j in range(i, len(candidates)):\n                # or: if i == j or candidates[j] != candidates[j - 1]\n                if j > i and candidates[j] == candidates[j - 1]:\n                    continue\n                t.append(candidates[j])\n                dfs(j + 1, s + candidates[j])\n                t.pop()\n\n        ans = []\n        candidates.sort()\n        t = []\n        dfs(0, 0)\n        return ans\n\n############\n\nclass Solution(object):\n  def combinationSum2(self, candidates, target):\n    \"\"\"\n    :type candidates: List[int]\n    :type target: int\n    :rtype: List[List[int]]\n    \"\"\"\n\n    def dfs(nums, target, start, visited, path, res):\n      if target == 0:\n        res.append(path + [])\n        return\n\n      for i in range(start, len(nums)):\n        if i > start and nums[i] == nums[i - 1]:\n          continue\n        if target - nums[i] < 0:\n          return 0\n        if i not in visited:\n          visited.add(i)\n          path.append(nums[i])\n          dfs(nums, target - nums[i], i + 1, visited, path, res)\n          path.pop()\n          visited.discard(i)\n\n    candidates.sort()\n    res = []\n    visited = set([])\n    dfs(candidates, target, 0, visited, [], res)\n    return res",
    "41. First Missing Positive": "class Solution:\n    def firstMissingPositive(self, nums: List[int]) -> int:\n        def swap(i, j):\n            nums[i], nums[j] = nums[j], nums[i]\n\n        n = len(nums)\n        for i in range(n):\n            while 1 <= nums[i] <= n and nums[i] != nums[nums[i] - 1]:\n                swap(i, nums[i] - 1)\n        for i in range(n):\n            if i + 1 != nums[i]:\n                return i + 1\n        return n + 1",
    "42. Trapping Rain Water": "class Solution:\n    def trap(self, height: List[int]) -> int:\n        n = len(height)\n        if n < 3:\n            return 0\n\n        lmx = [height[0]] * n\n        rmx = [height[n - 1]] * n\n        for i in range(1, n):\n            lmx[i] = max(lmx[i - 1], height[i]) # i self compare\n            rmx[n - 1 - i] = max(rmx[n - i], height[n - 1 - i])\n\n        # no negative, worst is, min(left,right) is itself\n        return sum( min(lmx[i], rmx[i]) - height[i] for i in range(n) )\n\n######\n\n",
    "43. Multiply Strings": "class Solution:\n    def multiply(self, num1: str, num2: str) -> str:\n        if num1 == \"0\" or num2 == \"0\":\n            return \"0\"\n        m, n = len(num1), len(num2)\n        arr = [0] * (m + n)\n        for i in range(m - 1, -1, -1):\n            a = int(num1[i])\n            for j in range(n - 1, -1, -1):\n                b = int(num2[j])\n                arr[i + j + 1] += a * b\n        for i in range(m + n - 1, 0, -1):\n            arr[i - 1] += arr[i] // 10\n            arr[i] %= 10\n        i = 0 if arr[0] else 1\n        return \"\".join(str(x) for x in arr[i:])",
    "44. Wildcard Matching": "class Solution:\n    def isMatch(self, s: str, p: str) -> bool:\n        m, n = len(s), len(p)\n        dp = [[False] * (n + 1) for _ in range(m + 1)]\n        dp[0][0] = True\n\n        # if p starting with \"*\", then all true for dp[0][i]\n        # or else, all false for dp[0][i]\n        for j in range(1, n + 1):\n            if p[j - 1] == '*':\n                dp[0][j] = dp[0][j - 1]\n\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if s[i - 1] == p[j - 1] or p[j - 1] == '?':\n                    dp[i][j] = dp[i - 1][j - 1]\n                # dp[i - 1][j], where j is always '*', all the way back to i-1==0\n                elif p[j - 1] == '*':\n                    dp[i][j] = dp[i - 1][j] or dp[i][j - 1]\n        return dp[m][n]",
    "45. Jump Game II": "class Solution:\n    def jump(self, nums: List[int]) -> int:\n        current_reach = next_reach = steps = 0\n        # stop at 2nd-to-last, not the last index.\n        # because, eg. nums=[1,0] or nums=[0,0],\n        # just check the 2nd-to-last then we can decide if able to reach end\n\n        # eg. - if input is [0], then 0 step needed\n        for i, num in enumerate(nums[:-1]):\n            next_reach = max(next_reach, i + num)\n            if i == current_reach:\n                current_reach = next_reach # update next-reach before if check\n                steps += 1 # in question, guarenteed can reach end. or else need more check\n        return steps\n\n############\n\nclass Solution(object):\n  def jump(self, nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    pos = 0\n    ans = 0\n    bound = len(nums)\n    while pos < len(nums) - 1:\n      dis = nums[pos]\n      farthest = posToFarthest = 0\n      for i in range(pos + 1, min(pos + dis + 1, bound)):\n        canReach = i + nums[i]\n        if i == len(nums) - 1:\n          return ans + 1\n        if canReach > farthest:\n          farthest = canReach\n          posToFarthest = i\n      ans += 1\n      pos = posToFarthest\n    return ans",
    "46. Permutations": "'''\nremove an element by its value from a set\n\n>>> my_set = {1, 2, 3, 4, 5}\n>>> my_set.remove(3)\n>>> print(my_set)\n{1, 2, 4, 5}\n\n------\n\ncannot remove an element by index from a set in Python3\nneed to convert the set to a list\n\n>>> my_set = {1, 2, 3, 4, 5}\n>>> my_list = list(my_set)\n>>> del my_list[2] # remove the element at index 2\n>>> my_set = set(my_list)\n>>> print(my_set)\n{1, 2, 4, 5}\n'''\n\nclass Solution: # iterative\n    def permute(self, nums: List[int]) -> List[List[int]]:\n        res = [[]]\n\n        if nums is None or len(nums) == 0:\n            return ans\n\n        for num in nums:\n            new_res = []\n            for perm in res:\n                for i in range(len(perm) + 1):\n                    new_perm = perm[:i] + [num] + perm[i:]\n                    new_res.append(new_perm)\n\n            res = new_res\n\n        return res\n\n##############\n\n",
    "47. Permutations II": "from typing import List\nclass Solution: # iterative, if new_perm not in new_res\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\n        res = [[]]\n\n        if nums is None or len(nums) == 0:\n            return res\n\n        for num in nums:\n            new_res = []\n            for perm in res:\n                for i in range(len(perm) + 1):\n                    new_perm = perm[:i] + [num] + perm[i:]\n                    if new_perm not in new_res:  # Check for uniqueness\n                        new_res.append(new_perm)\n\n            res = new_res\n\n        return res\n\n##############\n\n",
    "48. Rotate Image": "class Solution(object):\n  def rotate(self, matrix):\n    \"\"\"\n    :type matrix: List[List[int]]\n    :rtype: void Do not return anything, modify matrix in-place instead.\n    \"\"\"\n    if len(matrix) == 0:\n      return\n    h = len(matrix)\n    w = len(matrix[0])\n    for i in range(0, h): # mirror\n      for j in range(0, w / 2):\n        matrix[i][j], matrix[i][w - j - 1] = matrix[i][w - j - 1], matrix[i][j]\n\n    for i in range(0, h): # transpos\n      for j in range(0, w - 1 - i):\n        matrix[i][j], matrix[w - 1 - j][h - 1 - i] = matrix[w - 1 - j][h - 1 - i], matrix[i][j]\n\n\n############\n\nclass Solution:\n    def rotate(self, matrix: List[List[int]]) -> None:\n        n = len(matrix)\n        for i in range(n >> 1):\n            for j in range(n):\n                matrix[i][j], matrix[n - i - 1][j] = matrix[n - i - 1][j], matrix[i][j]\n        for i in range(n):\n            for j in range(i):\n                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]",
    "49. Group Anagrams": "'''\n>>> from collections import defaultdict\n>>> d = defaultdict(list)\n>>> d[\"a\"]=1\n>>> d[\"b\"]=2\n>>> d\ndefaultdict(<class 'list'>, {'a': 1, 'b': 2})\n>>> d.values()\ndict_values([1, 2])\n>>> list(d.values())\n[1, 2]\n\n### sorted(str) will return a list of chars\n>>> a = \"sdfddxyz\"\n>>> sorted(a)\n['d', 'd', 'd', 'f', 's', 'x', 'y', 'z']\n>>> \"\".join(sorted(a))\n'dddfsxyz'\n'''\n\nclass Solution:\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\n        d = defaultdict(list)\n        for s in strs:\n            k = \"\".join(sorted(s))\n            d[k].append(s)\n        return list(d.values())",
    "50. Pow(x, n)": "class Solution:\n    def myPow(self, x: float, n: int) -> float:\n        def qpow(a: float, n: int) -> float:\n            ans = 1\n            while n:\n                if n & 1:\n                    ans *= a\n                a *= a\n                n >>= 1\n            return ans\n\n        return qpow(x, n) if n >= 0 else 1 / qpow(x, -n)",
    "51. N-Queens": "class Solution:\n    def solveNQueens(self, n: int) -> List[List[str]]:\n        def dfs(i: int):\n            if i == n:\n                ans.append([\"\".join(row) for row in g])\n                return\n            for j in range(n):\n                if col[j] + dg[i + j] + udg[n - i + j] == 0:\n                    g[i][j] = \"Q\"\n                    col[j] = dg[i + j] = udg[n - i + j] = 1\n                    dfs(i + 1)\n                    col[j] = dg[i + j] = udg[n - i + j] = 0\n                    g[i][j] = \".\"\n\n        ans = []\n        g = [[\".\"] * n for _ in range(n)]\n        col = [0] * n\n        dg = [0] * (n << 1)\n        udg = [0] * (n << 1)\n        dfs(0)\n        return ans",
    "52. N-Queens II": "class Solution:\n    def totalNQueens(self, n: int) -> int:\n        def dfs(i: int):\n            if i == n:\n                nonlocal ans\n                ans += 1\n                return\n            for j in range(n):\n                a, b = i + j, i - j + n\n                if cols[j] or dg[a] or udg[b]:\n                    continue\n                cols[j] = dg[a] = udg[b] = True\n                dfs(i + 1)\n                cols[j] = dg[a] = udg[b] = False\n\n        cols = [False] * 10\n        dg = [False] * 20\n        udg = [False] * 20\n        ans = 0\n        dfs(0)\n        return ans",
    "53. Maximum Subarray": "class Solution:\n    def maxSubArray(self, nums: List[int]) -> int:\n        res = cur_sum = nums[0]\n        for num in nums[1:]:\n            cur_sum = num + max(cur_sum, 0)\n            res = max(res, cur_sum)\n        return res",
    "54. Spiral Matrix": "class Solution:\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\n        m, n = len(matrix), len(matrix[0])\n        dirs = (0, 1, 0, -1, 0)\n        i = j = k = 0\n        ans = []\n        vis = set()\n        for _ in range(m * n):\n            ans.append(matrix[i][j])\n            vis.add((i, j))\n            x, y = i + dirs[k], j + dirs[k + 1]\n            if not 0 <= x < m or not 0 <= y < n or (x, y) in vis:\n                k = (k + 1) % 4\n            i = i + dirs[k]\n            j = j + dirs[k + 1]\n        return ans",
    "55. Jump Game": "class Solution:\n    def canJump(self, nums: List[int]) -> bool:\n        mx = 0\n        for i, x in enumerate(nums):\n            if mx < i:\n                return False\n            mx = max(mx, i + x)\n        return True",
    "56. Merge Intervals": "# Definition for an interval.\n# class Interval(object):\n#     def __init__(self, s=0, e=0):\n#         self.start = s\n#         self.end = e\n\nclass Solution(object):\n  def merge(self, intervals):\n    \"\"\"\n    :type intervals: List[Interval]\n    :rtype: List[Interval]\n    \"\"\"\n    ans = []\n    for intv in sorted(intervals, key=lambda x: x.start):\n      if ans and ans[-1].end >= intv.start:\n        ans[-1].end = max(ans[-1].end, intv.end)\n      else:\n        ans.append(intv)\n    return ans\n\n######\n\n'''\n>>> intervals = [[111,222],[1,3],[2,6],[8,10],[15,18]]\n>>> intervals.sort()\n>>> intervals\n[[1, 3], [2, 6], [8, 10], [15, 18], [111, 222]]\n'''\nclass Solution:\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\n        intervals.sort() # default sort also ok\n        ans = [intervals[0]]\n        for s, e in intervals[1:]:\n            if ans[-1][1] < s:\n                ans.append([s, e])\n            else:\n                ans[-1][1] = max(ans[-1][1], e)\n        return ans",
    "57. Insert Interval": "'''\n>>> a = [1,2,3,4,5]\n>>> a[1]\n2\n>>> a[~1]\n4\n'''\nclass Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        start = newInterval[0]\n        end = newInterval[1]\n\n        left = list(filter(lambda x: x[1] < start, intervals)) # cast via list()\n        right = list(filter(lambda x: x[0] > end, intervals))\n\n        if left + right != intervals:\n            start = min(start, intervals[len(left)][0]) # note, left not -1, because index starts at 0\n            end = max(end, intervals[~len(right)][1]) # same, starting at right with index=0\n\n        return left + [[start, end]] + right\n\n######\n\n",
    "58. Length of Last Word": "class Solution:\n    def lengthOfLastWord(self, s: str) -> int:\n        i = len(s) - 1\n        while i >= 0 and s[i] == ' ':\n            i -= 1\n        j = i\n        while j >= 0 and s[j] != ' ':\n            j -= 1\n        return i - j",
    "59. Spiral Matrix II": "class Solution:\n    def generateMatrix(self, n: int) -> List[List[int]]:\n        ans = [[0] * n for _ in range(n)]\n        dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n        i = j = k = 0\n        for v in range(1, n * n + 1):\n            ans[i][j] = v\n            x, y = i + dirs[k][0], j + dirs[k][1]\n            if x < 0 or y < 0 or x >= n or y >= n or ans[x][y]:\n                k = (k + 1) % 4\n                x, y = i + dirs[k][0], j + dirs[k][1]\n            i, j = x, y\n        return ans",
    "60. Permutation Sequence": "class Solution:\n    def getPermutation(self, n: int, k: int) -> str:\n        nums = list(range(1, n + 1))\n        factorial = [1] * (n + 1)\n        for i in range(1, n + 1):\n            factorial[i] = factorial[i - 1] * i\n\n        result = []\n        k -= 1\n        for i in range(n, 0, -1):\n            digit = k // factorial[i - 1]\n            result.append(str(nums[digit]))\n            nums.pop(digit)\n\n            k %= factorial[i - 1]\n\n        return ''.join(result)\n\n##########\n\n",
    "61. Rotate List": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if head is None or head.next is None:\n            return head\n        cur, n = head, 0\n        while cur:\n            n += 1\n            cur = cur.next\n        k %= n\n        if k == 0:\n            return head\n        fast = slow = head\n        for _ in range(k):\n            fast = fast.next\n        while fast.next:\n            fast, slow = fast.next, slow.next\n\n        ans = slow.next\n        slow.next = None\n        fast.next = head\n        return ans",
    "62. Unique Paths": "class Solution:\n    def uniquePaths(self, m: int, n: int) -> int:\n        # avoid setting dp[][] to 1 for i==0 or j==0 as initialization\n        dp = [[1] * n for _ in range(m)]\n        for i in range(1, m):\n            for j in range(1, n):\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n        return dp[-1][-1]",
    "63. Unique Paths II": "class Solution:\n    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:\n        if not obstacleGrid:\n            return 0\n\n        m, n = len(obstacleGrid), len(obstacleGrid[0])\n        dp = [[0] * (n+1) for _ in range(m+1)]\n\n        # dp[1][1] = dp[0][1] + dp[1][0]\n        # so, set either dp[0][1]=1, or set dp[1][0]=1\n        dp[0][1] = 1\n\n        for i in range(1, m+1):\n            for j in range(1, n+1):\n                if obstacleGrid[i-1][j-1] == 0:\n                    dp[i][j] = dp[i-1][j] + dp[i][j-1]\n                # else, ==1, obstacle, skip and leave as 0\n\n        return dp[m][n]\n\n############\n\n",
    "64. Minimum Path Sum": "class Solution:\n    def minPathSum(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        f = [[0] * n for _ in range(m)]\n        f[0][0] = grid[0][0]\n        for i in range(1, m):\n            f[i][0] = f[i - 1][0] + grid[i][0]\n        for j in range(1, n):\n            f[0][j] = f[0][j - 1] + grid[0][j]\n        for i in range(1, m):\n            for j in range(1, n):\n                f[i][j] = min(f[i - 1][j], f[i][j - 1]) + grid[i][j]\n        return f[-1][-1]",
    "65. Valid Number": "class Solution:\n    def isNumber(self, s: str) -> bool:\n        n = len(s)\n        i = 0\n        if s[i] in '+-':\n            i += 1\n        if i == n:\n            return False\n        if s[i] == '.' and (i + 1 == n or s[i + 1] in 'eE'):\n            return False\n        dot = e = 0\n        j = i\n        while j < n:\n            if s[j] == '.':\n                if e or dot:\n                    return False\n                dot += 1\n            elif s[j] in 'eE':\n                if e or j == i or j == n - 1:\n                    return False\n                e += 1\n                if s[j + 1] in '+-':\n                    j += 1\n                    if j == n - 1:\n                        return False\n            elif not s[j].isnumeric():\n                return False\n            j += 1\n        return True",
    "66. Plus One": "class Solution:\n    def plusOne(self, digits: List[int]) -> List[int]:\n        n = len(digits)\n        for i in range(n - 1, -1, -1):\n            if digits[i] < 9:\n                digits[i] += 1\n                return digits\n            \n            digits[i] = 0\n\n        return [1] + digits\n        # also ok: return [1] + [0]*n\n\n############\n\nclass Solution(object):\n  def plusOne(self, digits):\n    \"\"\"\n    :type digits: List[int]\n    :rtype: List[int]\n    \"\"\"\n    carry = 1\n    for i in reversed(range(0, len(digits))):\n      digit = (digits[i] + carry) % 10\n      carry = 1 if digit < digits[i] else 0\n      digits[i] = digit\n    if carry == 1:\n      return [1] + digits\n    return digits",
    "67. Add Binary": "class Solution:\n    def addBinary(self, a: str, b: str) -> str:\n        ans = []\n        i, j, carry = len(a) - 1, len(b) - 1, 0\n        while i >= 0 or j >= 0 or carry:\n            carry += (0 if i < 0 else int(a[i])) + (0 if j < 0 else int(b[j]))\n            carry, v = divmod(carry, 2)\n            ans.append(str(v))\n            i, j = i - 1, j - 1\n        return \"\".join(ans[::-1])",
    "68. Text Justification": "'''\nExplanation:\n\n- The function `fullJustify` takes a list of words and a maximum width `maxWidth` as inputs.\n- It iterates over each word, deciding whether to add the current word to the current line (`cur`) or to start a new line.\n- If adding the current word to the line would exceed `maxWidth`, it justifies the current line by adding extra spaces between words as needed, then starts a new line.\n- Once all words are processed, it left-justifies the last line by joining the remaining words in `cur` with a single space and then using `.ljust(maxWidth)` to ensure the line is of maximum width.\n- The result is a list of strings, where each string represents a justified line of text.\n\nThis solution carefully handles edge cases, such as when there's only one word in the line (avoiding division by zero) and ensuring the last line is left-justified instead of fully justified.\n'''\n\n'''\n>>> cur = [1]\n>>> len(cur) - 1\n0\n>>> ( len(cur) - 1 or 1 )\n1\n'''\n\n'''\n# api: string.ljust(width[, fillchar])\n\n>>> \"Hello\".ljust(10)\n'Hello     '\n>>> \"Hello\".ljust(10, '-')\n'Hello-----'\n>>> \"Hello\".ljust(2)\n'Hello'\n\n>>> \"Hello World\".ljust(20)\n'Hello World         '\n>>> \"Hello World\".ljust(20, '-')\n'Hello World---------'\n\n\n# api: string.rjust(width[, fillchar])\n>>> \"Hello\".rjust(10)\n'     Hello'\n>>> \"Hello\".rjust(10, '-')\n'-----Hello'\n>>> \"Hello\".rjust(2)\n'Hello'\n\n>>> \"Hello World\".rjust(20)\n'         Hello World'\n>>> \"Hello World\".rjust(20, '-')\n'---------Hello World'\n\n'''\n\nclass Solution:\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\n        res, cur, num_of_letters = [], [], 0\n\n        for w in words:\n            # len(cur) is the space count, from last round, right one less after adding 'w'\n            if num_of_letters + len(cur) + len(w) > maxWidth:\n                for i in range(maxWidth - num_of_letters):\n                    # The \"or 1\" part is for dealing with the edge case 'len(cur) == 1'\n                    cur[i % ( len(cur) - 1 or 1 )] += ' '\n                res.append(''.join(cur))\n                cur, num_of_letters = [], 0\n            cur += [w]\n            num_of_letters += len(w)\n\n        return res + [' '.join(cur).ljust(maxWidth)]\n\n\n############\n\n'''\n>>> 17 % 3\n2\n>>> divmod(17,3)\n(5, 2)\n'''\n\n'''\n>>> ['This', 'is', 'an']\n['This', 'is', 'an']\n>>> t = ['This', 'is', 'an']\n>>> spaces = ['    ', '    ']\n\n# note: here j starts from 0\n>>> for j, word in enumerate(t[1:]):\n...     print(j)\n...     print(word)\n...\n0\nis\n1\nan\n'''\n\n",
    "70. Climbing Stairs": "class Solution:\n    def climbStairs(self, n: int) -> int:\n        a, b = 0, 1\n        for _ in range(n):\n            a, b = b, a + b\n        return b",
    "71. Simplify Path": "class Solution:\n    def simplifyPath(self, path: str) -> str:\n        stk = []\n        for s in path.split('/'):\n            if not s or s == '.':\n                continue\n            if s == '..':\n                if stk:\n                    stk.pop()\n            else:\n                stk.append(s)\n        return '/' + '/'.join(stk)",
    "72. Edit Distance": "class Solution:\n    def minDistance(self, word1: str, word2: str) -> int:\n        m, n = len(word1), len(word2)\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        for i in range(m + 1):\n            dp[i][0] = i\n        for j in range(n + 1):\n            dp[0][j] = j\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if word1[i - 1] == word2[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1]\n                else:\n                # dp[i - 1][j - 1]) meaning replace. \n                # e.g. \"abc\" and \"bf\", checking \"ab\" and \"b\" distance, \n                #   then replace either way for \"c\" or \"f\"\n                    dp[i][j] = 1 + min(dp[i][j - 1], dp[i - 1][j], dp[i - 1][j - 1])\n        return dp[-1][-1]\n\n############\n\n",
    "73. Set Matrix Zeroes": "class Solution:\n    def setZeroes(self, matrix: List[List[int]]) -> None:\n        m, n = len(matrix), len(matrix[0])\n        i0 = any(v == 0 for v in matrix[0])\n        j0 = any(matrix[i][0] == 0 for i in range(m))\n        for i in range(1, m):\n            for j in range(1, n):\n                if matrix[i][j] == 0:\n                    matrix[i][0] = matrix[0][j] = 0\n        for i in range(1, m):\n            for j in range(1, n):\n                if matrix[i][0] == 0 or matrix[0][j] == 0:\n                    matrix[i][j] = 0\n        if i0:\n            for j in range(n):\n                matrix[0][j] = 0\n        if j0:\n            for i in range(m):\n                matrix[i][0] = 0",
    "74. Search a 2D Matrix": "class Solution:\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\n        m, n = len(matrix), len(matrix[0])\n        left, right = 0, m * n - 1\n        while left <= right: # must be <=, not <, for matrax=[[1]],target=1\n            mid = (left + right) >> 1\n            x, y = divmod(mid, n) # note: divide column count\n            if matrix[x][y] == target:\n                return True\n            elif matrix[x][y] > target:\n                right = mid - 1\n            else:\n                left = mid + 1\n        return False\n\n###########\n\n",
    "75. Sort Colors": "class Solution:\n    def sortColors(self, nums: List[int]) -> None:\n        i, j, k = -1, len(nums), 0\n        while k < j:\n            if nums[k] == 0:\n                i += 1\n                nums[i], nums[k] = nums[k], nums[i]\n                k += 1\n            elif nums[k] == 2:\n                j -= 1\n                nums[j], nums[k] = nums[k], nums[j]\n            else:\n                k += 1",
    "76. Minimum Window Substring": "'''\n>>> deq = collections.deque([])\n>>> deq.append(11)\n>>> deq.append(22)\n>>> deq.append(33)\n>>>\n>>> deq[0]\n11\n'''\n\nimport collections\n\nclass Solution:\n    def minWindow(self, s: str, t: str) -> str:\n        cnt = 0\n        need = collections.Counter(t)\n        start, end = len(s), 3 * len(s) # Arbitrary 3, just make sure end-start is larger than input s length, for later min-check\n        d = {}\n        # Using queue to store indexes, good for a large amount of API calls\n        deq = collections.deque([])\n        for i, c in enumerate(s):\n            if c in need:\n                deq.append(i)\n                d[c] = d.get(c, 0) + 1\n                # '=' also +1, because it's inceased already one line above :)\n                if d[c] <= need[c]:\n                    cnt += 1\n                while deq and d[s[deq[0]]] > need[s[deq[0]]]:\n                    d[s[deq.popleft()]] -= 1\n                if cnt == len(t) and deq[-1] - deq[0] < end - start:\n                    start, end = deq[0], deq[-1]\n        return s[start:end + 1]\n\n############\n\nfrom collections import Counter\n\n",
    "77. Combinations": "class Solution:\n    def combine(self, n: int, k: int) -> List[List[int]]:\n        res = []\n\n        def dfs(i, t):\n            # no need to check len(t)>k, when '==k' returned already\n            if len(t) == k:\n                res.append(t.copy())\n                return\n            for j in range(i, n + 1):\n                t.append(j)\n                dfs(j + 1, t)\n                t.pop()\n\n        dfs(1, []) # 1 to n\n        return res\n\nclass Solution_iteration:\n    def combine(self, n: int, k: int) -> List[List[int]]:\n        res = []\n        out = [0] * k\n        i = 0\n        \n        while i >= 0:\n            out[i] += 1\n            if out[i] > n:\n                i -= 1\n            elif i == k - 1:\n                res.append(list(out))\n            else:\n                i += 1\n                out[i] = out[i - 1]\n                \n        return res\n\n############\n\nclass Solution(object):\n  def combine(self, n, k):\n    if k == 1:\n      return [[i] for i in range(1, n + 1)]\n    elif k == n:\n      return [[i for i in range(1, n + 1)]]\n    else:\n      rs = []\n      rs += self.combine(n - 1, k)\n      part = self.combine(n - 1, k - 1)\n      for ls in part:\n        ls.append(n)\n      rs += part\n      return rs",
    "78. Subsets": "from typing import List\n\nclass Solution: # bfs\n    def subsets(self, nums: List[int]) -> List[List[int]]:\n        if not nums:\n            return [[]]\n\n        nums.sort() # sort() not necessary if no duplicates\n        result = [[]]\n\n        for num in nums:\n            result += [subset + [num] for subset in result]\n\n        return result\n\n\n",
    "79. Word Search": "class Solution:\n    def exist(self, board: List[List[str]], word: str) -> bool:\n        def dfs(i, j, cur): # cur: current char count\n            if cur == len(word):\n                return True\n            if (\n                i < 0\n                or i >= m\n                or j < 0\n                or j >= n\n                or board[i][j] == '0'\n                or word[cur] != board[i][j]\n            ):\n                return False\n            t = board[i][j]\n            board[i][j] = '0' # mark as visited\n            for a, b in [[0, 1], [0, -1], [-1, 0], [1, 0]]:\n                x, y = i + a, j + b\n                if dfs(x, y, cur + 1):\n                    return True\n            board[i][j] = t\n            return False\n\n        m, n = len(board), len(board[0])\n        return any(dfs(i, j, 0) for i in range(m) for j in range(n))",
    "80. Remove Duplicates from Sorted Array II": "class Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        k = 0\n        for x in nums:\n            if k < 2 or x != nums[k - 2]:\n                nums[k] = x\n                k += 1\n        return k",
    "81. Search in Rotated Sorted Array II": "class Solution:\n    def search(self, nums: List[int], target: int) -> bool:\n        if not nums:\n            return False\n\n        i = 0  # left pointer\n        j = len(nums) - 1  # right pointer\n\n        while i <= j:\n            mid = (i + j) // 2\n\n            if nums[mid] == target:\n                return True\n\n            if nums[i] <= nums[mid]:  # left half ordered, right half not ordered\n                if nums[i] <= target <= nums[mid]:\n                    j = mid\n                else:\n                    i += 1\n            else:  # right half ordered, left half not ordered\n                if nums[mid] <= target <= nums[j]:\n                    i = mid\n                else:\n                    j -= 1\n\n        return False\n\n############\n\n",
    "82. Remove Duplicates from Sorted List II": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        dummy = pre = ListNode(next=head)\n        cur = head\n        while cur:\n            while cur.next and cur.next.val == cur.val:\n                cur = cur.next\n            if pre.next == cur:\n                pre = cur\n            else:\n                pre.next = cur.next\n            cur = cur.next\n        return dummy.next",
    "83. Remove Duplicates from Sorted List": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        cur = head\n        while cur and cur.next:\n            if cur.val == cur.next.val:\n                cur.next = cur.next.next\n            else:\n                cur = cur.next\n        return head",
    "84. Largest Rectangle in Histogram": "'''\n\u679a\u4e3e\u6bcf\u6839\u67f1\u5b50\u7684\u9ad8\u5ea6 h \u4f5c\u4e3a\u77e9\u5f62\u7684\u9ad8\u5ea6\uff0c\u5411\u5de6\u53f3\u4e24\u8fb9\u627e\u7b2c\u4e00\u4e2a\u9ad8\u5ea6 \u5c0f\u4e8e(<) h \u7684\u4e0b\u6807 left_i, right_i\n\n\u90a3\u4e48\u6b64\u65f6\u77e9\u5f62\u9762\u79ef\u4e3a h * (right_i - left_i - 1)\uff0c\u6c42\u6700\u5927\u503c\u5373\u53ef\u3002\n'''\nclass Solution:\n    def largestRectangleArea(self, heights: List[int]) -> int:\n        n = len(heights)\n        stk = []\n        left = [-1] * n\n        right = [n] * n\n        for i, h in enumerate(heights):\n            while stk and heights[stk[-1]] >= h:\n                right[stk[-1]] = i\n                stk.pop()\n            if stk:\n                left[i] = stk[-1] # same as below: stk[-1] in 'i - stack[-1] - 1'\n            stk.append(i)\n\n        # valid for one element input [3]\n        return max(h * (right[i] - left[i] - 1) for i, h in enumerate(heights))\n\n\n############\n\n\n",
    "85. Maximal Rectangle": "class Solution:\n    def maximalRectangle(self, matrix: List[List[str]]) -> int:\n        heights = [0] * len(matrix[0])\n        ans = 0\n        for row in matrix:\n            for j, v in enumerate(row):\n                if v == \"1\":\n                    heights[j] += 1 # inherite from row above\n                else:\n                    heights[j] = 0\n            # check for every row\n            ans = max(ans, self.largestRectangleArea(heights))\n        return ans\n\n    def largestRectangleArea(self, heights: List[int]) -> int:\n        n = len(heights)\n        stk = []\n        left = [-1] * n\n        right = [n] * n\n        for i, h in enumerate(heights):\n            while stk and heights[stk[-1]] >= h:\n                stk.pop()\n            if stk:\n                left[i] = stk[-1]\n            stk.append(i)\n        return max(h * (right[i] - left[i] - 1) for i, h in enumerate(heights))\n\n############\n\nclass Solution(object):\n  def maximalRectangle(self, matrix):\n    \"\"\"\n    :type matrix: List[List[str]]\n    :rtype: int\n    \"\"\"\n\n    def histogram(height):\n      if not height:\n        return 0\n      height.append(-1)\n      stack = []\n      ans = 0\n      for i in range(0, len(height)):\n        while stack and height[i] < height[stack[-1]]:\n          h = height[stack.pop()]\n          w = i - stack[-1] - 1 if stack else i\n          ans = max(ans, h * w)\n        stack.append(i)\n      return ans\n\n    ans = 0\n    dp = [[0] * len(matrix[0]) for _ in range(0, len(matrix))]\n    for i in reversed(range(0, len(matrix))):\n      if i == len(matrix) - 1:\n        dp[i] = [int(h) for h in matrix[i]]\n      else:\n        for j in range(0, len(matrix[0])):\n          if matrix[i][j] != \"0\":\n            dp[i][j] = dp[i + 1][j] + 1\n      ans = max(ans, histogram(dp[i]))\n    return ans",
    "86. Partition List": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def partition(self, head: Optional[ListNode], x: int) -> Optional[ListNode]:\n        d1, d2 = ListNode(), ListNode()\n        t1, t2 = d1, d2\n        while head:\n            if head.val < x:\n                t1.next = head\n                t1 = t1.next\n            else:\n                t2.next = head\n                t2 = t2.next\n            head = head.next\n        t1.next = d2.next\n        t2.next = None\n        return d1.next",
    "87. Scramble String": "class Solution:\n    def isScramble(self, s1: str, s2: str) -> bool:\n        @cache\n        def dfs(i: int, j: int, k: int) -> bool:\n            if k == 1:\n                return s1[i] == s2[j]\n            for h in range(1, k):\n                if dfs(i, j, h) and dfs(i + h, j + h, k - h):\n                    return True\n                if dfs(i + h, j, k - h) and dfs(i, j + k - h, h):\n                    return True\n            return False\n\n        return dfs(0, 0, len(s1))",
    "88. Merge Sorted Array": "class Solution:\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\n        \"\"\"\n        Do not return anything, modify nums1 in-place instead.\n        \"\"\"\n        i, j, k = m - 1, n - 1, m + n - 1\n        # what if j=-1 already but k is not 0 yet? e.g. m=[1,2,0], n=[3]\n        # => then no more ops needed, rest of m[] already sorted, so this while is good enough\n        while j >= 0: \n            # i could be -1, eg. [7,8,9, ] and [1]\n            if i >= 0 and nums1[i] > nums2[j]:\n                nums1[k] = nums1[i]\n                i -= 1\n            else:\n                nums1[k] = nums2[j]\n                j -= 1\n            k -= 1",
    "89. Gray Code": "class Solution:\n    def grayCode(self, n: int) -> List[int]:\n        return [i ^ (i >> 1) for i in range(1 << n)]",
    "90. Subsets II": "class Solution:\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\n        def dfs(u, t):\n            ans.append(t[:]) # or, t.copy()\n            for i in range(u, len(nums)):\n                 # also good for [1,5,5], second '5' will be skipped here if\n                 # but second '5' is always covered, because i==u when ans=[1,5] and i=2\n                if i != u and nums[i] == nums[i - 1]:\n                    continue\n                t.append(nums[i])\n                dfs(i + 1, t)\n                t.pop()\n\n        ans = []\n        nums.sort()\n        dfs(0, [])\n        return ans\n\n\n# iteration\n",
    "91. Decode Ways": "'''\n>>> s = \"abcdef\"\n>>> [(i,c) for i, c in enumerate(s, 1)]\n[(1, 'a'), (2, 'b'), (3, 'c'), (4, 'd'), (5, 'e'), (6, 'f')]\n'''\nclass Solution:\n    def numDecodings(self, s: str) -> int:\n        # f: i-2\n        # g: i-1\n        f, g = 0, 1\n        for i, c in enumerate(s, 1):\n            h = g if c != \"0\" else 0\n            if i > 1 and s[i - 2] != \"0\" and int(s[i - 2 : i]) <= 26:\n                h += f\n            f, g = g, h\n        return g\n\n##############\n\n",
    "92. Reverse Linked List II": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def reverseBetween(\n        self, head: Optional[ListNode], left: int, right: int\n    ) -> Optional[ListNode]:\n        if head.next is None or left == right:\n            return head\n        dummy = ListNode(0, head)\n        pre = dummy\n        for _ in range(left - 1):\n            pre = pre.next\n        p, q = pre, pre.next\n        cur = q\n        # +1, so when for loop done, 'cur' is at right's next node\n        for _ in range(right - left + 1):\n            t = cur.next\n            cur.next = pre\n            pre, cur = cur, t\n        p.next = pre\n        # p,q did not change by the for loop, but now pre at right(or called m) node, cur at right+1 node\n        q.next = cur\n        return dummy.next\n\n############\n\nclass Solution_optimize:\n    def reverseBetween(self, head: ListNode, m: int, n: int) -> ListNode:\n        dummy = ListNode(0)\n        prev = dummy\n        prev.next = head\n        p = head\n\n        for i in range(1, m):\n            prev = p\n            p = p.next\n\n        original_first = p # this is anchor node always pointing to the next-to-be-swapped\n        for i in range(m, n):\n            current_head = prev.next\n            future_head = original_first.next\n            \n            prev.next = future_head\n            original_first.next = future_head.next\n            future_head.next = current_head\n\n        return dummy.next\n\n############\n\n# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution(object):\n  def reverseBetween(self, head, m, n):\n    \"\"\"\n    :type head: ListNode\n    :type m: int\n    :type n: int\n    :rtype: ListNode\n    \"\"\"\n\n    def reverse(root, prep, k):\n      cur = root\n      pre = None\n      next = None\n      while cur and k > 0:\n        next = cur.next\n        cur.next = pre\n        pre = cur\n        cur = next\n        k -= 1\n      root.next = next\n      prep.next = pre\n      return pre\n\n    dummy = ListNode(-1)\n    dummy.next = head\n    k = 1\n    p = dummy\n    start = None\n    while p:\n      if k == m:\n        start = p\n      if k == n + 1:\n        reverse(start.next, start, n - m + 1)\n        return dummy.next\n      k += 1\n      p = p.next",
    "93. Restore IP Addresses": "class Solution:\n    def restoreIpAddresses(self, s: str) -> List[str]:\n        def check(i: int, j: int) -> int:\n            if s[i] == \"0\" and i != j:\n                return False\n            return 0 <= int(s[i : j + 1]) <= 255\n\n        def dfs(i: int):\n            if i >= n and len(t) == 4:\n                ans.append(\".\".join(t))\n                return\n            if i >= n or len(t) >= 4:\n                return\n            for j in range(i, min(i + 3, n)):\n                if check(i, j):\n                    t.append(s[i : j + 1])\n                    dfs(j + 1)\n                    t.pop()\n\n        n = len(s)\n        ans = []\n        t = []\n        dfs(0)\n        return ans",
    "94. Binary Tree Inorder Traversal": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\n        stack = []\n        current = root\n        res = []\n        while stack or current:\n            while current:\n                stack.append(current)\n                current = current.left\n            left_or_middle = stack.pop()\n            res.append(left_or_middle.val)\n            current = left_or_middle.right\n        return res\n\n\n# no stack, but modifying original tree\n",
    "95. Unique Binary Search Trees II": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def generateTrees(self, n: int) -> List[TreeNode]:\n        def gen(left, right):\n            ans = []\n            # this if check instead of if left==right then return Node(left), less hassle\n            if left > right:\n                ans.append(None)\n            else:\n                # right+1, to cover case when left==right\n                for i in range(left, right + 1):\n                    left_trees = gen(left, i - 1)\n                    right_trees = gen(i + 1, right)\n                    for l in left_trees:\n                        for r in right_trees:\n                            node = TreeNode(i, l, r)\n                            ans.append(node)\n            return ans\n\n        return gen(1, n) # n or right is inclusive\n\n############\n\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n",
    "96. Unique Binary Search Trees": "class Solution:\n    def numTrees(self, n: int) -> int:\n        dp = [0] * (n + 1)\n        dp[0] = 1 # e.g, null is counted as one unique tree\n        for i in range(1, n + 1):\n            # up to i-1, when j=i-1 meaning left child having i-1 node then i is the root\n            for j in range(i):\n                dp[i] += dp[j] * dp[i - j - 1] # -1, not counting root\n        return dp[-1]\n\n############\n\nclass Solution(object):\n  def _numTrees(self, n):\n    \"\"\"\n    :type n: int\n    :rtype: int\n    \"\"\"\n    dp = [0] * (n + 1)\n    dp[0] = dp[1] = 1\n    for i in range(2, n + 1):\n      for j in range(1, i + 1):\n        dp[i] += dp[j - 1] * dp[i - j]\n    return dp[-1]\n\n  def numTrees(self, n):\n    ans = 1\n    for i in range(1, n + 1):\n      ans = ans * (n + i) / i\n    return ans / (n + 1)",
    "97. Interleaving String": "# 2-d\nclass Solution:\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\n        if len(s1) + len(s2) != len(s3):\n            return False\n\n        dp = [[False] * (len(s2) + 1) for _ in range(len(s1) + 1)]\n        dp[0][0] = True\n\n        for i in range(1, len(s1) + 1):\n            dp[i][0] = s1[i - 1] == s3[i - 1] and dp[i - 1][0]\n        for i in range(1, len(s2) + 1):\n            dp[0][i] = s2[i - 1] == s3[i - 1] and dp[0][i - 1]\n\n        # fill in dp array\n        for i in range(1, len(s1) + 1):\n            for j in range(1, len(s2) + 1):\n                with_s1 = s1[i - 1] == s3[i + j - 1] and dp[i - 1][j]\n                with_s2 = s2[j - 1] == s3[i + j - 1] and dp[i][j - 1]\n                dp[i][j] = with_s1 or with_s2\n\n        return dp[-1][-1]\n\n############\n\n# 1-d\n",
    "98. Validate Binary Search Tree": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\n\nclass Solution: # recursive\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\n        def dfs(root, mi, ma):\n            if not root:\n                return True\n            return mi < root.val < ma and dfs(root.left, mi, root.val) and dfs(root.right, root.val, ma)\n        return dfs(root, -math.inf, math.inf)\n\n\n",
    "99. Recover Binary Search Tree": "'''\nWithout nonlocal, any assignment to prev, first, and second inside dfs\nwould be treated as creating new local variables within dfs,\nrather than modifying the outer variables.\n'''\n\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def recoverTree(self, root: Optional[TreeNode]) -> None:\n        \"\"\"\n        Do not return anything, modify root in-place instead.\n        \"\"\"\n\n        def dfs(root):\n            if root is None:\n                return\n            nonlocal prev, first, second\n            dfs(root.left)\n            if prev and prev.val > root.val:\n                if first is None:\n                    first = prev\n                second = root\n            prev = root\n            dfs(root.right)\n\n        prev = first = second = None\n        dfs(root)\n        first.val, second.val = second.val, first.val",
    "100. Same Tree": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution(object):\n  def isSameTree(self, p, q):\n    \"\"\"\n    :type p: TreeNode\n    :type q: TreeNode\n    :rtype: bool\n    \"\"\"\n    if not p or not q:\n      return p == q # covers: p=none and q!=none, q=none and p!=none, both none\n    return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\n\n\n# iteration\nclass Solution:\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\n        if p is None:\n            return q is None\n\n        if q is None:\n            return p is None\n\n        stack1 = [p]\n        stack2 = [q]\n\n        while stack1 and stack2:\n            current1 = stack1.pop()\n            current2 = stack2.pop()\n\n            if current1 is None and current2 is None:\n                continue\n            elif current1 is None or current2 is None:\n                return False\n            elif current1.val != current2.val:\n                return False\n\n            stack1.append(current1.left)\n            stack2.append(current2.left)\n\n            stack1.append(current1.right)\n            stack2.append(current2.right)\n\n        return not stack1 and not stack2",
    "101. Symmetric Tree": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isSymmetric(self, root: Optional[TreeNode]) -> bool:\n        def dfs(root1, root2):\n            if root1 is None and root2 is None:\n                return True\n            if root1 is None or root2 is None or root1.val != root2.val:\n                return False\n            return dfs(root1.left, root2.right) and dfs(root1.right, root2.left)\n\n        return dfs(root, root)",
    "102. Binary Tree Level Order Traversal": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:\n        ans = []\n        if root is None:\n            return ans\n        q = deque([root])\n        while q:\n            t = []\n            for _ in range(len(q)):\n                node = q.popleft()\n                t.append(node.val)\n                if node.left:\n                    q.append(node.left)\n                if node.right:\n                    q.append(node.right)\n            ans.append(t)\n        return ans",
    "103. Binary Tree Zigzag Level Order Traversal": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\n'''\ncan also use list.insert()\n\n>>> my_list = [2, 3, 4]\n>>> my_list.insert(0, 1)  # Insert 1 at the head of the list\n>>> print(my_list)  # Output: [1, 2, 3, 4]\n\n\n>>> a = deque([])\n>>> a\ndeque([])\n>>> a.append(1)\n>>> a.append(2)\n>>> a.append(3)\n>>> a\ndeque([1, 2, 3])\n>>>\n>>> a.append(0, 555)\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nTypeError: deque.append() takes exactly one argument (2 given)\n>>> a.insert(0, 555)\n>>> a\ndeque([555, 1, 2, 3])\n'''\n\nfrom collections import deque\n\nclass Solution:\n    def zigzagLevelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:\n        ans = []\n        if root is None:\n            return ans\n        q = deque([root])\n        ans = []\n        left = True\n        while q:\n            t = []\n            for _ in range(len(q)):\n                node = q.popleft()\n                t.append(node.val)\n                if node.left:\n                    q.append(node.left)\n                if node.right:\n                    q.append(node.right)\n            ans.append(t if left else t[::-1])\n            left = (not left)\n        return ans\n\n############\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\nfrom collections import deque\n\n\nclass Solution(object):\n  def zigzagLevelOrder(self, root):\n    \"\"\"\n    :type root: TreeNode\n    :rtype: List[List[int]]\n    \"\"\"\n    stack = deque([root])\n    ans = []\n    odd = True\n    while stack:\n      level = []\n      for k in range(0, len(stack)):\n        top = stack.popleft()\n        if top is None:\n          continue\n        level.append(top.val)\n        stack.append(top.left)\n        stack.append(top.right)\n      if level:\n        if odd:\n          ans.append(level)\n        else:\n          ans.append(level[::-1])\n      odd = not odd\n    return ans\n\n############\n\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n",
    "104. Maximum Depth of Binary Tree": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxDepth(self, root: TreeNode) -> int:\n        if root is None:\n            return 0\n        l, r = self.maxDepth(root.left), self.maxDepth(root.right)\n        return 1 + max(l, r)",
    "105. Construct Binary Tree from Preorder and Inorder Traversal": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\n# best\nclass Solution:\n    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:\n        if not preorder: # or, not inorder\n            return None\n        v = preorder[0]\n        i = inorder.index(v)\n        root = TreeNode(v)\n        root.left = self.buildTree(preorder[1: i+1], inorder[:i])\n        root.right = self.buildTree(preorder[i+1:], inorder[i+1:])\n        return root\n\n\n# inorder.index(preorder_val)\n",
    "106. Construct Binary Tree from Inorder and Postorder Traversal": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def buildTree(self, inorder: List[int], postorder: List[int]) -> TreeNode:\n        if not postorder:\n            return None\n        v = postorder[-1]\n        root = TreeNode(val=v)\n        i = inorder.index(v)\n        root.left = self.buildTree(inorder[:i], postorder[:i])\n        root.right = self.buildTree(inorder[i + 1 :], postorder[i:-1])\n        return root\n\n#############\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\n'''\nsearch for index, also use .index(val)\n  >>> a = [1,2,3,4,5]\n  >>> a.index(3)\n  2\n'''\nclass Solution(object):\n  def buildTree(self, inorder, postorder):\n    \"\"\"\n    :type inorder: List[int]\n    :type postorder: List[int]\n    :rtype: TreeNode\n    \"\"\"\n    if inorder and postorder:\n      postorder.reverse()\n      self.index = 0\n      d = {}\n      for i in range(0, len(inorder)):\n        d[inorder[i]] = i\n      return self.dfs(inorder, postorder, 0, len(postorder) - 1, d)\n\n  def dfs(self, inorder, postorder, start, end, d):\n    if start <= end:\n      root = TreeNode(postorder[self.index])\n      mid = d[postorder[self.index]]\n      self.index += 1\n      root.right = self.dfs(inorder, postorder, mid + 1, end, d)\n      root.left = self.dfs(inorder, postorder, start, mid - 1, d)\n      return root",
    "107. Binary Tree Level Order Traversal II": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:\n        ans = []\n        if root is None:\n            return ans\n        q = deque([root])\n        while q:\n            t = []\n            for _ in range(len(q)):\n                node = q.popleft()\n                t.append(node.val)\n                if node.left:\n                    q.append(node.left)\n                if node.right:\n                    q.append(node.right)\n            ans.append(t)\n        return ans[::-1]",
    "108. Convert Sorted Array to Binary Search Tree": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def sortedArrayToBST(self, nums: List[int]) -> Optional[TreeNode]:\n        def dfs(l, r):\n            if l > r:\n                return None\n            mid = (l + r) >> 1\n            left = dfs(l, mid - 1)\n            right = dfs(mid + 1, r)\n            return TreeNode(nums[mid], left, right)\n\n        return dfs(0, len(nums) - 1)\n\n############\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution(object):\n  def sortedArrayToBST(self, nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: TreeNode\n    \"\"\"\n    if nums:\n      midPos = len(nums) / 2\n      mid = nums[midPos]\n      root = TreeNode(mid)\n      root.left = self.sortedArrayToBST(nums[:midPos])\n      root.right = self.sortedArrayToBST(nums[midPos + 1:])\n      return root",
    "109. Convert Sorted List to Binary Search Tree": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n        if not head:\n            return None\n        if not head.next:\n            return TreeNode(head.val)\n        \n        # find mid\n        dummy = ListNode(0)\n        dummy.next = head\n        slow, fast, prev = head, head, dummy\n        while fast and fast.next:\n            prev = slow\n            slow = slow.next\n            fast = fast.next.next\n        \n        # prev is one before mid\n        new_head = slow.next\n        prev.next = None  # cut\n        \n        root = TreeNode(slow.val)\n        root.left = self.sortedListToBST(head)\n        root.right = self.sortedListToBST(new_head)\n\n        return root\n\n#################\n\n",
    "110. Balanced Binary Tree": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isBalanced(self, root: Optional[TreeNode]) -> bool:\n        def height(root):\n            if root is None:\n                return 0\n            l, r = height(root.left), height(root.right)\n            if l == -1 or r == -1 or abs(l - r) > 1:\n                return -1\n            return 1 + max(l, r)\n\n        return height(root) >= 0",
    "111. Minimum Depth of Binary Tree": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def minDepth(self, root: Optional[TreeNode]) -> int:\n        if root is None:\n            return 0\n        if root.left is None:\n            return 1 + self.minDepth(root.right)\n        if root.right is None:\n            return 1 + self.minDepth(root.left)\n        return 1 + min(self.minDepth(root.left), self.minDepth(root.right))\n\n##########\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution(object):\n  def minDepth(self, root):\n    \"\"\"\n    :type root: TreeNode\n    :rtype: int\n    \"\"\"\n    if not root:\n      return 0\n    left = self.minDepth(root.left)\n    right = self.minDepth(root.right)\n    if not left and not right:\n      return 1\n    elif not left:\n      return right + 1\n    elif not right:\n      return left + 1\n    else:\n      return min(left, right) + 1",
    "112. Path Sum": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\n        def dfs(root, s):\n            if root is None:\n                return False\n            s += root.val\n            if root.left is None and root.right is None and s == targetSum:\n                return True\n            return dfs(root.left, s) or dfs(root.right, s)\n\n        return dfs(root, 0)",
    "113. Path Sum II": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> List[List[int]]:\n        def dfs(root, s):\n            if root is None:\n                return\n            s += root.val\n            t.append(root.val)\n            if root.left is None and root.right is None and s == targetSum:\n                ans.append(t[:])\n            dfs(root.left, s)\n            dfs(root.right, s)\n            t.pop()\n\n        ans = []\n        t = []\n        dfs(root, 0)\n        return ans",
    "114. Flatten Binary Tree to Linked List": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution: # stack, pre-order interation\n    def flatten(self, root: TreeNode) -> None:\n        \"\"\"\n        Do not return anything, modify root in-place instead.\n        \"\"\"\n        if not root:\n            return\n        \n        stack = [root]\n        prev = TreeNode(0) # dummy node\n        \n        while stack:\n            current = stack.pop()\n            \n            if current.right:\n                stack.append(current.right)\n            if current.left:\n                stack.append(current.left)\n                \n            prev.left = None\n            prev.right = current\n            \n            prev = current\n\n###########\n\n",
    "115. Distinct Subsequences": "class Solution:\n    def numDistinct(self, s: str, t: str) -> int:\n        n = len(t)\n        f = [1] + [0] * n\n        for a in s:\n            for j in range(n, 0, -1):\n                if a == t[j - 1]:\n                    f[j] += f[j - 1]\n        return f[n]",
    "116. Populating Next Right Pointers in Each Node": "\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, val: int = 0, left: 'Node' = None, right: 'Node' = None, next: 'Node' = None):\n        self.val = val\n        self.left = left\n        self.right = right\n        self.next = next\n\"\"\"\n\n'''\n>>> d = deque((5,1,9,2))\n>>> d.popleft()\n5\n>>> d.popleft()\n1\n>>>\n>>>\n>>> d = deque([5,1,9,2])\n>>> d.popleft()\n5\n>>> d.popleft()\n1\n'''\n\nfrom collections import deque\n\nclass Solution:\n    def connect(self, root: \"Optional[Node]\") -> \"Optional[Node]\":\n        if root is None:\n            return root\n\n        # q = deque(root) ===> TypeError: 'Node' object is not iterable\n        # make it a list [], so it's iterable\n        q = deque([root])\n        while q:\n            prev = None\n            for _ in range(len(q)):\n                node = q.popleft()\n                if prev:\n                    p.next = node\n                prev = node\n                if node.left:\n                    q.append(node.left)\n                if node.right:\n                    q.append(node.right)\n        return root\n\n\n",
    "117. Populating Next Right Pointers in Each Node II": "\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, val: int = 0, left: 'Node' = None, right: 'Node' = None, next: 'Node' = None):\n        self.val = val\n        self.left = left\n        self.right = right\n        self.next = next\n\"\"\"\nclass Solution:\n    def connect(self, root: \"Node\") -> \"Node\":\n        def modify(curr):\n            nonlocal prev_node, next_node\n            if curr is None:\n                return\n            if next_node is None: # next level's first node\n                next_node = curr\n            # \"if next_node is None\" logic can be replaced by:\n            #   next_node = next_node or curr\n            if prev_node:\n                prev_node.next = curr\n            prev_node = curr\n\n        node = root\n        while node:\n            prev_node = next_node = None\n            while node: # process for every level\n                modify(node.left)\n                modify(node.right)\n                node = node.next\n            node = next_node\n        return root\n\n\n\n# use dummyHead.next to find each level's first node\n",
    "118. Pascal's Triangle": "class Solution:\n    def generate(self, numRows: int) -> List[List[int]]:\n        f = [[1]]\n        for i in range(numRows - 1):\n            g = [1] + [a + b for a, b in pairwise(f[-1])] + [1]\n            f.append(g)\n        return f",
    "119. Pascal's Triangle II": "class Solution:\n    def getRow(self, rowIndex: int) -> List[int]:\n        f = [1] * (rowIndex + 1)\n        for i in range(2, rowIndex + 1):\n            for j in range(i - 1, 0, -1):\n                f[j] += f[j - 1]\n        return f",
    "120. Triangle": "class Solution:\n    def minimumTotal(self, triangle: List[List[int]]) -> int:\n        n = len(triangle)\n        for i in range(n - 2, -1, -1):\n            for j in range(i + 1):\n                triangle[i][j] = (\n                    min(triangle[i + 1][j], triangle[i + 1][j + 1]) + triangle[i][j]\n                )\n        return triangle[0][0]",
    "121. Best Time to Buy and Sell Stock": "'''\n>>> import math\n>>> a = math.inf\n>>> a\ninf\n\n>>> x = float('-inf')\n>>> y = float('inf')\n>>> print(x < y)  # Output: True\nTrue\n>>>\n>>> z = -math.inf\n>>> x==z\nTrue\n\n'''\nclass Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        ans, mi = 0, inf\n        for v in prices:\n            mi = min(mi, v)\n            ans = max(ans, v - mi)\n        return ans\n\n############\n\nclass Solution(object):\n  def maxProfit(self, prices):\n    \"\"\"\n    :type prices: List[int]\n    :rtype: int\n    \"\"\"\n    if not prices:\n      return 0\n    ans = 0\n    pre = prices[0]\n    for i in range(1, len(prices)):\n      pre = min(pre, prices[i])\n      ans = max(prices[i] - pre, ans)\n    return ans",
    "122. Best Time to Buy and Sell Stock II": "'''\n>>> from itertools import pairwise\n>>> dirs = (-1, 0, 1, 0, -1)\n>>> pairwise(dirs)\n<itertools.pairwise object at 0x104dbe470>\n>>> list(pairwise(dirs))\n[(-1, 0), (0, 1), (1, 0), (0, -1)]\n'''\n\nclass Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        return sum(max(0, b - a) for a, b in pairwise(prices))\n\n\n",
    "123. Best Time to Buy and Sell Stock III": "'''\n-   `f1` \u8868\u793a\u7b2c\u4e00\u6b21\u4e70\u5165\u80a1\u7968\u540e\u7684\u6700\u5927\u5229\u6da6\uff1b\n-   `f2` \u8868\u793a\u7b2c\u4e00\u6b21\u5356\u51fa\u80a1\u7968\u540e\u7684\u6700\u5927\u5229\u6da6\uff1b\n-   `f3` \u8868\u793a\u7b2c\u4e8c\u6b21\u4e70\u5165\u80a1\u7968\u540e\u7684\u6700\u5927\u5229\u6da6\uff1b\n-   `f4` \u8868\u793a\u7b2c\u4e8c\u6b21\u5356\u51fa\u80a1\u7968\u540e\u7684\u6700\u5927\u5229\u6da6\u3002\n'''\nclass Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        # \u7b2c\u4e00\u6b21\u4e70\u5165\uff0c\u7b2c\u4e00\u6b21\u5356\u51fa\uff0c\u7b2c\u4e8c\u6b21\u4e70\u5165\uff0c\u7b2c\u4e8c\u6b21\u5356\u51fa\n        f1, f2, f3, f4 = -prices[0], 0, -prices[0], 0\n        for price in prices[1:]:\n            f1 = max(f1, -price)\n            f2 = max(f2, f1 + price)\n            f3 = max(f3, f2 - price)\n            f4 = max(f4, f3 + price)\n        return f4\n\n\n",
    "124. Binary Tree Maximum Path Sum": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxPathSum(self, root: Optional[TreeNode]) -> int:\n        def dfs(root: Optional[TreeNode]) -> int:\n            if root is None:\n                return 0\n            left = max(0, dfs(root.left))\n            right = max(0, dfs(root.right))\n            nonlocal ans\n            ans = max(ans, root.val + left + right)\n            return root.val + max(left, right)\n\n        ans = -inf\n        dfs(root)\n        return ans",
    "125. Valid Palindrome": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        i, j = 0, len(s) - 1\n        while i < j:\n            if not s[i].isalnum():\n                i += 1\n            elif not s[j].isalnum():\n                j -= 1\n            elif s[i].lower() != s[j].lower():\n                return False\n            else:\n                i, j = i + 1, j - 1\n        return True",
    "126. Word Ladder II": "'''\nremove() same as discard()\n\n>>> a = set([11,22,33])\n>>> a.remove(22)\n>>> a\n{33, 11}\n\n>>> a = set([11,22,33])\n>>> a.discard(22)\n>>> a\n{33, 11}\n\n\n>>> a=set([1,2,3])\n>>> a.discard(555)\n>>> a.remove(555)\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nKeyError: 555\n'''\n\nclass Solution:\n    def findLadders(\n        self, beginWord: str, endWord: str, wordList: List[str]\n    ) -> List[List[str]]:\n        # endWord to beginWord\n        # better than begin to end, too many paths not in final result\n        def dfs(path, cur):\n            if cur == beginWord:\n                ans.append(path[::-1])\n                return\n            for precursor in prev[cur]:\n                path.append(precursor)\n                dfs(path, precursor)\n                path.pop()\n\n        ans = []\n        words = set(wordList)\n        if endWord not in words:\n            return ans\n        # no exception if beginWord not in set\n        words.discard(beginWord)\n        dist = {beginWord: 0}\n        prev = defaultdict(set)\n        q = deque([beginWord])\n        found = False\n        step = 0\n        while q and not found:\n            step += 1\n            for _ in range(len(q), 0, -1):\n                p = q.popleft()\n                s = list(p)\n                for i in range(len(s)):\n                    ch = s[i]\n                    for j in range(26):\n                        s[i] = chr(ord('a') + j)\n                        t = ''.join(s)\n                        if dist.get(t, 0) == step:\n                            prev[t].add(p) # repeated 3 lines below\n                        if t not in words: \n                        # if above '== step' met, then t must be removed from words[] from previous iterations\n                            continue\n                        prev[t].add(p) # repeated 3 lines above\n                        words.discard(t)\n                        q.append(t)\n                        dist[t] = step\n                        if endWord == t:\n                            found = True\n                    s[i] = ch\n        if found:\n            path = [endWord]\n            dfs(path, endWord)\n        return ans\n\n############\n\nfrom collections import deque\n\nclass Solution(object):\n  def findLadders(self, beginWord, endWord, wordlist):\n    \"\"\"\n    :type beginWord: str\n    :type endWord: str\n    :type wordlist: Set[str]\n    :rtype: List[List[int]]\n    \"\"\"\n\n    def getNbrs(src, dest, wordList):\n      res = []\n      for c in string.ascii_lowercase:\n        for i in range(0, len(src)):\n          newWord = src[:i] + c + src[i + 1:]\n          if newWord == src:\n            continue\n          if newWord in wordList or newWord == dest:\n            yield newWord\n\n    def bfs(beginWord, endWord, wordList):\n      distance = {beginWord: 0}\n      queue = deque([beginWord])\n      length = 0\n      while queue:\n        length += 1\n        for k in range(0, len(queue)):\n          top = queue.popleft()\n          for nbr in getNbrs(top, endWord, wordList):\n            if nbr not in distance:\n              distance[nbr] = distance[top] + 1\n              queue.append(nbr)\n      return distance\n\n    def dfs(beginWord, endWord, wordList, path, res, distance):\n      if beginWord == endWord:\n        res.append(path + [])\n        return\n\n      for nbr in getNbrs(beginWord, endWord, wordList):\n        if distance.get(nbr, -2) + 1 == distance[beginWord]:\n          path.append(nbr)\n          dfs(nbr, endWord, wordList, path, res, distance)\n          path.pop()\n\n    res = []\n    distance = bfs(endWord, beginWord, wordlist)\n    dfs(beginWord, endWord, wordlist, [beginWord], res, distance)\n    return res",
    "127. Word Ladder": "# native BFS\nclass Solution:\n    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:\n        words = set(wordList)\n        q = deque([beginWord])\n        ans = 1\n        while q:\n            ans += 1\n            for _ in range(len(q)):\n                s = q.popleft()\n                s = list(s) # must convert to list, cannot directly update s[i]='a'\n                for i in range(len(s)):\n                    ch = s[i]\n                    for j in range(26):\n                        # will re-generate s itself\n                        # but s not in words-set, s removed after added to words-set\n                        s[i] = chr(ord('a') + j)\n                        t = ''.join(s)\n                        if t not in words:\n                            continue\n                        if t == endWord:\n                            return ans\n                        q.append(t)\n                        words.remove(t) # equivalent to set t as visited\n                    s[i] = ch # restore\n        return 0\n\n\n#########\n\n'''\n\u53cc\u5411 BFS \u662f BFS \u5e38\u89c1\u7684\u4e00\u4e2a\u4f18\u5316\u65b9\u6cd5\uff0c\u4e3b\u8981\u5b9e\u73b0\u601d\u8def\u5982\u4e0b\uff1a\n\n1. \u521b\u5efa\u4e24\u4e2a\u961f\u5217 q1, q2 \u5206\u522b\u7528\u4e8e\u201c\u8d77\u70b9 -> \u7ec8\u70b9\u201d\u3001\u201c\u7ec8\u70b9 -> \u8d77\u70b9\u201d\u4e24\u4e2a\u65b9\u5411\u7684\u641c\u7d22\uff1b\n2. \u521b\u5efa\u4e24\u4e2a\u54c8\u5e0c\u8868 m1, m2 \u5206\u522b\u8bb0\u5f55\u8bbf\u95ee\u8fc7\u7684\u8282\u70b9\u4ee5\u53ca\u5bf9\u5e94\u7684\u6269\u5c55\u6b21\u6570\uff08\u6b65\u6570\uff09\uff1b\n3. \u6bcf\u6b21\u641c\u7d22\u65f6\uff0c\u4f18\u5148\u9009\u62e9\u5143\u7d20\u6570\u91cf\u8f83\u5c11\u7684\u961f\u5217\u8fdb\u884c\u641c\u7d22\u6269\u5c55\uff0c\u5982\u679c\u5728\u6269\u5c55\u8fc7\u7a0b\u4e2d\uff0c\u641c\u7d22\u5230\u53e6\u4e00\u4e2a\u65b9\u5411\u5df2\u7ecf\u8bbf\u95ee\u8fc7\u7684\u8282\u70b9\uff0c\u8bf4\u660e\u627e\u5230\u4e86\u6700\u77ed\u8def\u5f84\uff1b\n4. \u53ea\u8981\u5176\u4e2d\u4e00\u4e2a\u961f\u5217\u4e3a\u7a7a\uff0c\u8bf4\u660e\u5f53\u524d\u65b9\u5411\u7684\u641c\u7d22\u5df2\u7ecf\u8fdb\u884c\u4e0d\u4e0b\u53bb\u4e86\uff0c\u8bf4\u660e\u8d77\u70b9\u5230\u7ec8\u70b9\u4e0d\u8fde\u901a\uff0c\u65e0\u9700\u7ee7\u7eed\u641c\u7d22\u3002\n'''\n",
    "128. Longest Consecutive Sequence": "class Solution:\n    def longestConsecutive(self, nums: List[int]) -> int:\n        s = set(nums)\n        ans = 0\n        for x in nums:\n            if x - 1 not in s:\n                y = x + 1\n                while y in s:\n                    y += 1\n                ans = max(ans, y - x)\n        return ans",
    "129. Sum Root to Leaf Numbers": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\n        def dfs(root, s):\n            if root is None:\n                return 0\n            s = s * 10 + root.val\n            if root.left is None and root.right is None:\n                return s\n            return dfs(root.left, s) + dfs(root.right, s)\n\n        return dfs(root, 0)",
    "130. Surrounded Regions": "class Solution:\n    def solve(self, board: List[List[str]]) -> None:\n        \"\"\"\n        Do not return anything, modify board in-place instead.\n        \"\"\"\n\n        def dfs(i, j):\n            board[i][j] = '.'\n            for a, b in [[0, -1], [0, 1], [1, 0], [-1, 0]]:\n                x, y = i + a, j + b\n                if 0 <= x < m and 0 <= y < n and board[x][y] == 'O':\n                    dfs(x, y)\n\n        m, n = len(board), len(board[0])\n        for i in range(m):\n            for j in range(n):\n                if board[i][j] == 'O' and (\n                    i == 0 or i == m - 1 or j == 0 or j == n - 1\n                ):\n                    dfs(i, j)\n        for i in range(m):\n            for j in range(n):\n                if board[i][j] == 'O':\n                    board[i][j] = 'X'\n                elif board[i][j] == '.':\n                    board[i][j] = 'O'",
    "131. Palindrome Partitioning": "'''\n>>> t = []\n>>> t.append(1)\n>>> t.append(2)\n>>> t.append(3)\n>>> t\n[1, 2, 3]\n>>> t.pop(-1)\n3\n>>> t\n[1, 2]\n>>> t.pop()\n2\n>>> t\n[1]\n\n\n>>> t = [1,2,3]\n>>> t.pop(0)\n1\n>>> t\n[2, 3]\n\n\n>>> t = [1,2,3]\n>>> t.pop(1)\n2\n>>> t\n[1, 3]\n'''\nclass Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        ans = []\n        n = len(s)\n        dp = [[False] * n for _ in range(n)]\n\n        for i in range(n - 1, -1, -1):\n            for j in range(i, n):\n                # <=3 also working, same as <=1\n                # i==j, or i+1==j\n                dp[i][j] = s[i] == s[j] and (abs(i - j) <= 1 or dp[i + 1][j - 1])\n\n        def dfs(s, i, t):\n            nonlocal n # note: still pass OJ without this nonlocal. default is non-local\n            if i == n:\n                ans.append(t.copy())\n                return\n            for j in range(i, n): # including single char dp[i][i]\n                if dp[i][j]:\n                    t.append(s[i : j + 1])\n                    dfs(s, j + 1, t)\n                    t.pop(-1)\n\n        dfs(s, 0, [])\n        return ans\n\n###########\n\nclass Solution(object): # iteration, real dp\n  def partition(self, s):\n    \"\"\"\n    :type s: str\n    :rtype: List[List[str]]\n    \"\"\"\n    pal = [[False for i in range(0, len(s))] for j in range(0, len(s))]\n    ans = [[[]]] + [[] for _ in range(len(s))] # length is n+1\n\n    for i in range(0, len(s)):\n      for j in range(0, i + 1):\n        if (s[j] == s[i]) and ((j + 1 > i - 1) or (pal[j + 1][i - 1])):\n          pal[j][i] = True\n          for res in ans[j]:\n            a = res + [s[j:i + 1]]\n            ans[i + 1].append(a)\n    return ans[-1]",
    "132. Palindrome Partitioning II": "class Solution:\n    def minCut(self, s: str) -> int:\n        pal = [[False for j in range(0, len(s))] for i in range(0, len(s))]\n        dp = [len(s) for _ in range(0, len(s) + 1)]\n        for i in range(0, len(s)):\n            for j in range(0, i + 1):\n                # also ok if, (j + 1 >= i - 1)\n                if (s[i] == s[j]) and ((j + 1 > i - 1) or (pal[i - 1][j + 1])):\n                    pal[i][j] = True\n                    dp[i + 1] = min(dp[i + 1], dp[j] + 1) if j != 0 else 0\n                    # 'if j != 0' to ensure from start to i is a palindrome\n        return dp[-1]\n\n############\n\n",
    "133. Clone Graph": "\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, val = 0, neighbors = None):\n        self.val = val\n        self.neighbors = neighbors if neighbors is not None else []\n\"\"\"\n\n\nclass Solution:\n    def cloneGraph(self, node: 'Node') -> 'Node':\n        visited = defaultdict()\n\n        def clone(node):\n            if node is None:\n                return None\n            if node in visited:\n                return visited[node]\n            c = Node(node.val)\n            visited[node] = c\n            for e in node.neighbors:\n                c.neighbors.append(clone(e))\n            return c\n\n        return clone(node)",
    "134. Gas Station": "class Solution:\n    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:\n        n = len(gas)\n        i = j = n - 1\n        cnt = s = 0\n        while cnt < n:\n            s += gas[j] - cost[j]\n            cnt += 1\n            j = (j + 1) % n\n            while s < 0 and cnt < n:\n                i -= 1\n                s += gas[i] - cost[i]\n                cnt += 1\n        return -1 if s < 0 else i",
    "135. Candy": "class Solution:\n    def candy(self, ratings: List[int]) -> int:\n        n = len(ratings)\n        left = [1] * n\n        right = [1] * n\n        for i in range(1, n):\n            if ratings[i] > ratings[i - 1]:\n                left[i] = left[i - 1] + 1\n        for i in range(n - 2, -1, -1):\n            if ratings[i] > ratings[i + 1]:\n                right[i] = right[i + 1] + 1\n        return sum(max(a, b) for a, b in zip(left, right))",
    "136. Single Number": "'''\n>>> from functools import reduce\n>>> reduce(lambda x, y: x ^ y, [3, 5, 3])\n5\n'''\n\nfrom functools import reduce\n\nclass Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        return reduce(lambda x, y: x ^ y, nums)\n\n############\n\nclass Solution(object):\n  def singleNumber(self, nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    for i in range(1, len(nums)):\n      nums[0] ^= nums[i]\n    return nums[0]",
    "137. Single Number II": "'''\nA 32-bit number can be created to count the number of occurrences of 1 in each digit.\n\nIf a certain digit is 1, then if the integer appears three times, the remainder of 3 is 0,\nso that the numbers of each digit position are added up then take the remainder of 3,\nand the final number remaining is a single number.\n'''\nclass Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        ans = 0\n        for i in range(32):\n            cnt = sum(num >> i & 1 for num in nums)\n            if cnt % 3:\n                if i == 31: # int overflow\uff0c or just throw exception\n                    ans -= 1 << i\n                else:\n                    ans |= 1 << i\n        return ans\n\n############\n\n",
    "138. Copy List with Random Pointer": "# Definition for singly-linked list with a random pointer.\n# class RandomListNode(object):\n#     def __init__(self, x):\n#         self.label = x\n#         self.next = None\n#         self.random = None\n\nclass Solution:\n    def copyRandomList(self, head: \"Node\") -> \"Node\":\n        if head is None:\n            return None\n        cur = head\n        while cur: # copy nodes\n            node = Node(cur.val, cur.next)\n            cur.next = node\n            cur = node.next\n\n        cur = head\n        while cur: # copy random pointers\n            if cur.random:\n                cur.next.random = cur.random.next\n            cur = cur.next.next\n\n        ans = head.next\n        cur = head\n        while cur: # cut into 2 lists\n            nxt = cur.next\n            if nxt:\n                cur.next = nxt.next\n            cur = nxt\n        return ans\n\n\n",
    "139. Word Break": "class Solution:\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\n        words = set(wordDict)\n        n = len(s)\n\n        # f[j] meaining s from 0 to index=i-1 is breakable\n        f = [True] + [False] * n # so actually size is n+1\n        for i in range(1, n + 1):\n            f[i] = any( (f[j] and s[j:i] in words) for j in range(i) )\n        return f[n]\n\n#############\n\n",
    "140. Word Break II": "class Trie:\n    def __init__(self):\n        self.children = [None] * 26\n        self.is_end = False\n\n    def insert(self, word):\n        node = self\n        for c in word:\n            idx = ord(c) - ord('a')\n            if node.children[idx] is None:\n                node.children[idx] = Trie()\n            node = node.children[idx]\n        node.is_end = True\n\n    def search(self, word):\n        node = self\n        for c in word:\n            idx = ord(c) - ord('a')\n            if node.children[idx] is None:\n                return False\n            node = node.children[idx]\n        return node.is_end\n\n\nclass Solution:\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\n        def dfs(s):\n            if not s:\n                return [[]] # list of list\n            res = []\n            for i in range(1, len(s) + 1): # starts from 1, i is excluded in s[:i]\n                if trie.search(s[:i]):\n                    # if below dfs() returns empty, then returned res also empty\n                    for v in dfs(s[i:]):\n                        res.append([s[:i]] + v) # [1] + [2,3] ==> [1, 2, 3]\n            return res\n\n        trie = Trie()\n        for w in wordDict:\n            trie.insert(w)\n        ans = dfs(s)\n        return [' '.join(v) for v in ans]\n\n#############\n\n",
    "141. Linked List Cycle": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def hasCycle(self, head: ListNode) -> bool:\n        slow = fast = head\n        while fast and fast.next:\n            slow, fast = slow.next, fast.next.next\n            if slow == fast:\n                return True\n        return False",
    "142. Linked List Cycle II": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def detectCycle(self, head: ListNode) -> ListNode:\n        slow = fast = head\n        has_cycle = False\n        while not has_cycle and fast and fast.next:\n            slow, fast = slow.next, fast.next.next\n            has_cycle = slow == fast\n        if not has_cycle:\n            return None\n        p = head\n        while p != slow:\n            p, slow = p.next, slow.next\n        return p\n\n#############\n\n",
    "143. Reorder List": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def reorderList(self, head: Optional[ListNode]) -> None:\n        fast = slow = head\n        while fast.next and fast.next.next:\n            slow = slow.next\n            fast = fast.next.next\n\n        cur = slow.next\n        slow.next = None\n\n        pre = None\n        while cur:\n            t = cur.next\n            cur.next = pre\n            pre, cur = cur, t\n        cur = head\n\n        while pre:\n            t = pre.next\n            pre.next = cur.next\n            cur.next = pre\n            cur, pre = pre.next, t",
    "144. Binary Tree Preorder Traversal": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\n        ans = []\n        while root:\n            if root.left is None:\n                ans.append(root.val)\n                root = root.right\n            else:\n                prev = root.left\n                while prev.right and prev.right != root:\n                    prev = prev.right\n                if prev.right is None:\n                    ans.append(root.val)\n                    prev.right = root\n                    root = root.left\n                else:\n                    prev.right = None\n                    root = root.right\n        return ans",
    "145. Binary Tree Postorder Traversal": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\n        ans = []\n        while root:\n            if root.right is None:\n                ans.append(root.val)\n                root = root.left\n            else:\n                next = root.right\n                while next.left and next.left != root:\n                    next = next.left\n                if next.left != root:\n                    ans.append(root.val)\n                    next.left = root\n                    root = root.right\n                else:\n                    next.left = None\n                    root = root.left\n        return ans[::-1]",
    "146. LRU Cache": "class Node:\n    def __init__(self, key=0, val=0):\n        self.key = key\n        self.val = val\n        self.prev = None\n        self.next = None\n\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.cache = {} # key ==> Node(val)\n        self.head = Node() # dummy node\n        self.tail = Node() # dummy node\n        self.capacity = capacity\n        self.size = 0\n        self.head.next = self.tail # note: key setup\n        self.tail.prev = self.head\n\n    def get(self, key: int) -> int:\n        if key not in self.cache:\n            return -1\n        node = self.cache[key]\n        self.move_to_head(node)\n        return node.val\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.cache:\n            node = self.cache[key]\n            node.val = value\n            self.move_to_head(node)\n        else:\n            node = Node(key, value)\n            self.cache[key] = node\n            self.add_to_head(node)\n            self.size += 1\n            if self.size > self.capacity:\n                tail = self.remove_tail()\n                self.cache.pop(tail.key)\n                self.size -= 1\n\n    def move_to_head(self, node):\n        self.remove_node(node)\n        self.add_to_head(node)\n\n    def remove_node(self, node):\n        node.prev.next = node.next\n        node.next.prev = node.prev\n\n    def add_to_head(self, node):\n        node.next = self.head.next\n        node.prev = self.head\n        self.head.next = node\n        node.next.prev = node\n\n    def remove_tail(self):\n        node = self.tail.prev\n        self.remove_node(node)\n        return node\n\n\n# Your LRUCache object will be instantiated and called as such:\n# obj = LRUCache(capacity)\n# param_1 = obj.get(key)\n# obj.put(key,value)\n\n############\n\n'''\nexample:\n\n>>> od = collections.OrderedDict()\n>>>\n>>> od[1]=1\n>>> od[2]=2\n>>> od[3]=3\n>>>\n>>> od\nOrderedDict([(1, 1), (2, 2), (3, 3)])\n>>> od.move_to_end(1)\n>>> od\nOrderedDict([(2, 2), (3, 3), (1, 1)])\n>>>\n>>> od.get(1)\n1\n>>> od.popitem()\n(1, 1)\n>>> od\nOrderedDict([(2, 2), (3, 3)])\n>>>\n>>> od[1]=1\n>>> od\nOrderedDict([(2, 2), (3, 3), (1, 1)])\n>>>\n>>> od.popitem(last=False)\n(2, 2)\n>>> od\nOrderedDict([(3, 3), (1, 1)])\n\n'''\n\nimport collections\n\nclass LRUCache:\n    def __init__(self, capacity: 'int'):\n        self.cache = collections.OrderedDict()\n        self.remain = capacity\n\n    def get(self, key: 'int') -> 'int':\n        if key not in self.cache:\n            return -1\n        self.cache.move_to_end(key) # meaning end is the most recently used\n        return self.cache.get(key)\n\n    def put(self, key: 'int', value: 'int') -> 'None':\n        if key not in self.cache:\n            if self.remain > 0:\n                self.remain -= 1\n            else:\n                self.cache.popitem(last=False) # pop start position\n        else:\n            self.cache.pop(key)\n        self.cache[key] = value # add to end of dict, meaning most recently used\n\n\n############\n\n### below solution with no ordered-dict\nclass DLinkedNode:\n\n    def __init__(self, key=0, value=0):\n        self.key = key\n        self.val = value\n        self.next = None\n        self.prev = None\n\n\nclass DLinkedList:\n\n    def __init__(self):\n        self.head = DLinkedNode() # dummy head, its next is real head\n        self.tail = DLinkedNode() # dummy tail, its prev is real tail\n        self.head.next, self.tail.prev = self.tail, self.head\n\n    def add_node(self, node): # add to head\n        node.prev, node.next = self.head, self.head.next\n        node.next.prev, node.prev.next = node, node\n\n    def remove_node(self, node):\n        node.prev.next, node.next.prev = node.next, node.prev\n        return node.key\n\n    def remove_tail(self):\n        return self.remove_node(self.tail.prev) # dummy tail's prev is real tail\n\n    def move_to_head(self, node):\n        self.remove_node(node)\n        self.add_node(node)\n\n    # def __repr__(self):\n    #     ans = []\n    #     h = self.head\n    #     while h:\n    #         ans.append(str(h.val))\n    #         h = h.next\n    #     return '<DLinkedList: {}>'.format('->'.join(ans))\n\nclass LRUCache:\n\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.nodes_map = {}\n        self.cache_list = DLinkedList()\n\n    def get(self, key: int) -> int:\n        node = self.nodes_map.get(key, None)\n        if node:\n            self.cache_list.move_to_head(node)\n            return node.val\n        else:\n            return -1\n\n    def put(self, key: int, value: int) -> None:\n        node = self.nodes_map.get(key, None)\n        if not node:\n            if self.capacity > 0:\n                self.capacity -= 1\n            else:\n                rm_key = self.cache_list.remove_tail()\n                self.nodes_map.pop(rm_key) # note api\n            new_node = DLinkedNode(key, value)\n            self.nodes_map[key] = new_node\n            self.cache_list.add_node(new_node)\n        else:\n            self.cache_list.move_to_head(node)\n            node.val = value",
    "147. Insertion Sort List": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def insertionSortList(self, head: ListNode) -> ListNode:\n        if head is None or head.next is None:\n            return head\n        dummy = ListNode(head.val, head)\n        pre, cur = dummy, head\n        while cur:\n            if pre.val <= cur.val:\n                pre, cur = cur, cur.next\n                continue\n            p = dummy\n            while p.next.val <= cur.val:\n                p = p.next\n            t = cur.next\n            cur.next = p.next\n            p.next = cur\n            pre.next = t\n            cur = t\n        return dummy.next",
    "148. Sort List": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def sortList(self, head: ListNode) -> ListNode:\n        if head is None or head.next is None:\n            return head\n        slow, fast = head, head.next\n        while fast and fast.next:\n            slow, fast = slow.next, fast.next.next\n        t = slow.next\n        slow.next = None\n        l1, l2 = self.sortList(head), self.sortList(t)\n        dummy = ListNode()\n        cur = dummy\n        while l1 and l2:\n            if l1.val <= l2.val:\n                cur.next = l1\n                l1 = l1.next\n            else:\n                cur.next = l2\n                l2 = l2.next\n            cur = cur.next\n        cur.next = l1 or l2 # add the rest\n        return dummy.next",
    "149. Max Points on a Line": "class Solution:\n    def maxPoints(self, points: List[List[int]]) -> int:\n        def gcd(a, b):\n            return a if b == 0 else gcd(b, a % b)\n\n        n = len(points)\n        ans = 1\n        for i in range(n):\n            x1, y1 = points[i]\n            cnt = Counter()\n            for j in range(i + 1, n):\n                x2, y2 = points[j]\n                dx, dy = x2 - x1, y2 - y1\n                g = gcd(dx, dy)\n                k = (dx // g, dy // g)\n                cnt[k] += 1\n                ans = max(ans, cnt[k] + 1)\n        return ans",
    "150. Evaluate Reverse Polish Notation": "class Solution:\n    def evalRPN(self, tokens: List[str]) -> int:\n        nums = []\n        for t in tokens:\n            if len(t) > 1 or t.isdigit():\n                nums.append(int(t))\n            else:\n                if t == \"+\":\n                    nums[-2] += nums[-1]\n                elif t == \"-\":\n                    nums[-2] -= nums[-1]\n                elif t == \"*\":\n                    nums[-2] *= nums[-1]\n                else:\n                    nums[-2] = int(nums[-2] / nums[-1])\n                nums.pop()\n        return nums[0]",
    "151. Reverse Words in a String": "class Solution:\n    def reverseWords(self, s: str) -> str:\n        words = s.strip().split()\n        return ' '.join(words[::-1])\n\n############\n\n\n",
    "152. Maximum Product Subarray": "class Solution:\n    def maxProduct(self, nums: List[int]) -> int:\n        ans = f = g = nums[0]\n        for x in nums[1:]:\n            ff, gg = f, g\n            f = max(x, ff * x, gg * x)\n            g = min(x, ff * x, gg * x)\n            ans = max(ans, f)\n        return ans",
    "153. Find Minimum in Rotated Sorted Array": "class Solution:\n    def findMin(self, nums: List[int]) -> int:\n        if nums[0] <= nums[-1]:\n            return nums[0]\n        left, right = 0, len(nums) - 1\n        while left < right:\n            mid = (left + right) >> 1\n            if nums[0] <= nums[mid]:\n                left = mid + 1\n            else:\n                right = mid\n        return nums[left]",
    "154. Find Minimum in Rotated Sorted Array II": "class Solution:\n    def findMin(self, nums: List[int]) -> int:\n        left, right = 0, len(nums) - 1\n        while left < right:\n            mid = (left + right) >> 1\n            if nums[mid] > nums[right]:\n                left = mid + 1\n            elif nums[mid] < nums[right]:\n                right = mid\n            else:\n                right -= 1\n        return nums[left]",
    "155. Min Stack": "class MinStack:\n    def __init__(self):\n        self.sk = []\n        self.minsk = [inf] # trick, avoid later empty-check for min-stack\n\n    def push(self, x: int) -> None:\n        self.sk.append(x)\n        self.minsk.append(min(x, self.minsk[-1]))\n\n    def pop(self) -> None:\n  if not self.sk:\n   return\n        self.sk.pop()\n        self.minsk.pop()\n\n    def top(self) -> int:\n        return self.sk[-1]\n\n    def getMin(self) -> int:\n        return self.minsk[-1]\n\n\n# Your MinStack object will be instantiated and called as such:\n# obj = MinStack()\n# obj.push(x)\n# obj.pop()\n# param_3 = obj.top()\n# param_4 = obj.getMin()\n\n############\n\nclass MinStack:\n\n def __init__(self):\n  self.sk = []\n  self.minsk = []\n\n def push(self, val: int) -> None:\n  self.sk.append(val)\n\n        # empty check\n  self.minsk.append(val if not self.minsk else min(val, self.minsk[-1]))\n\n def pop(self) -> None:\n  if not self.sk:\n   return\n\n  self.sk.pop()\n  self.minsk.pop()\n\n def top(self) -> int:\n  return self.sk[-1]\n\n def getMin(self) -> int:\n  return self.minsk[-1]\n\n# optimize above, using only 1 stack, with stack element as tuple: (val, its associated min)\nclass MinStack:\n\n    def __init__(self):\n        self._stack = []\n\n    def push(self, x: int) -> None:\n        cur_min = self.getMin()\n        if x < cur_min:\n            cur_min = x\n        self._stack.append((x, cur_min))\n\n    def pop(self) -> None:\n        self._stack.pop()\n\n    def top(self) -> int:\n        if not self._stack:\n            return None\n        else:\n            return self._stack[-1][0]\n\n    def getMin(self) -> int:\n        if not self._stack:\n            return float('inf')\n        else:\n            return self._stack[-1][1]",
    "160. Intersection of Two Linked Lists": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\n\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n        a, b = headA, headB\n        while a != b:\n            a = a.next if a else headB\n            b = b.next if b else headA\n        return a",
    "162. Find Peak Element": "class Solution:\n    def findPeakElement(self, nums: List[int]) -> int:\n        left, right = 0, len(nums) - 1\n        while left < right:\n            mid = (left + right) >> 1\n            if nums[mid] > nums[mid + 1]:\n                right = mid\n            else:\n                left = mid + 1\n        return left",
    "164. Maximum Gap": "'''\n>>> math.inf\ninf\n>>> 1 + math.inf\ninf\n>>> -1 - math.inf\n-inf\n'''\nclass Solution:\n    def maximumGap(self, nums: List[int]) -> int:\n        n = len(nums)\n        if n < 2:\n            return 0\n        mi, mx = min(nums), max(nums)\n        # also passing OJ: \n        # bucket_size = max(1, (mx - mi) // (n - 1))\n        bucket_size = max(1, (mx - mi) // n)\n        bucket_count = (mx - mi) // bucket_size + 1\n        buckets = [[inf, -inf] for _ in range(bucket_count)]\n        for v in nums:\n            i = (v - mi) // bucket_size\n            buckets[i][0] = min(buckets[i][0], v)\n            buckets[i][1] = max(buckets[i][1], v)\n        ans = 0\n        prev = inf\n        for curmin, curmax in buckets:\n            if curmin > curmax:\n                continue\n            ans = max(ans, curmin - prev)\n            prev = curmax\n        return ans\n\n############\n\nclass Solution(object):\n  def maximumGap(self, nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    if len(nums) < 2:\n      return 0\n    a, b = min(nums), max(nums)\n    if a == b:\n      return 0\n    ans = 0\n    gap = int(math.ceil((b - a + 0.0) / (len(nums) - 1)))\n    bucketMin = [None for _ in range(0, len(nums) + 1)]\n    bucketMax = [None for _ in range(0, len(nums) + 1)]\n\n    for num in nums:\n      index = (num - a) / gap\n      if bucketMin[index] is None:\n        bucketMin[index] = num\n      else:\n        bucketMin[index] = min(bucketMin[index], num)\n      if bucketMax[index] is None:\n        bucketMax[index] = num\n      else:\n        bucketMax[index] = max(bucketMax[index], num)\n    bucketMin = [b for b in bucketMin if b is not None]\n    bucketMax = [b for b in bucketMax if b is not None]\n    for i in range(0, len(bucketMin) - 1):\n      ans = max(ans, bucketMin[i + 1] - bucketMax[i])\n    return ans",
    "165. Compare Version Numbers": "class Solution:\n    def compareVersion(self, version1: str, version2: str) -> int:\n        m, n = len(version1), len(version2)\n        i = j = 0\n        while i < m or j < n:\n            a = b = 0\n            while i < m and version1[i] != '.':\n                a = a * 10 + int(version1[i])\n                i += 1\n            while j < n and version2[j] != '.':\n                b = b * 10 + int(version2[j])\n                j += 1\n            if a != b:\n                return -1 if a < b else 1\n            i, j = i + 1, j + 1\n        return 0",
    "166. Fraction to Recurring Decimal": "class Solution:\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\n        if numerator == 0:\n            return '0'\n        res = []\n        neg = (numerator > 0) ^ (denominator > 0)\n        if neg:\n            res.append('-')\n        num, d = abs(numerator), abs(denominator)\n        res.append(str(num // d))\n        num %= d\n        if num == 0:\n            return ''.join(res)\n        res.append('.')\n        mp = {}\n        while num != 0:\n            mp[num] = len(res)\n            num *= 10\n            res.append(str(num // d))\n            num %= d\n            if num in mp:\n                idx = mp[num]\n                res.insert(idx, '(')\n                res.append(')')\n                break\n        return ''.join(res)",
    "167. Two Sum II - Input array is sorted": "class Solution:\n    def twoSum(self, numbers: List[int], target: int) -> List[int]:\n        i, j = 1, len(numbers)\n        while i < j:\n            x = numbers[i - 1] + numbers[j - 1]\n            if x == target:\n                return [i, j]\n            if x < target:\n                i += 1\n            else:\n                j -= 1\n        return [-1, -1]\n\n############\n\nclass Solution(object):\n  def twoSum(self, nums, target):\n    \"\"\"\n    :type numbers: List[int]\n    :type target: int\n    :rtype: List[int]\n    \"\"\"\n    start, end = 0, len(nums) - 1\n    while start < end:\n      s = nums[start] + nums[end]\n      if s > target:\n        end -= 1\n      elif s < target:\n        start += 1\n      else:\n        return (start + 1, end + 1)",
    "168. Excel Sheet Column Title": "class Solution:\n    def convertToTitle(self, columnNumber: int) -> str:\n        res = []\n        while columnNumber:\n            columnNumber -= 1\n            res.append(chr(ord('A') + columnNumber % 26))\n            columnNumber //= 26\n        return ''.join(res[::-1])",
    "169. Majority Element": "class Solution:\n    def majorityElement(self, nums: List[int]) -> int:\n        cnt = m = 0\n        for x in nums:\n            if cnt == 0:\n                m, cnt = x, 1\n            else:\n                cnt += 1 if m == x else -1\n        return m",
    "171. Excel Sheet Column Number": "class Solution:\n    def titleToNumber(self, columnTitle: str) -> int:\n        res = 0\n        for c in columnTitle:\n            res = res * 26 + (ord(c) - ord('A') + 1)\n        return res",
    "172. Factorial Trailing Zeroes": "class Solution:\n    def trailingZeroes(self, n: int) -> int:\n        ans = 0\n        while n:\n            n //= 5\n            ans += n\n        return ans",
    "173. Binary Search Tree Iterator": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass BSTIterator:\n    def __init__(self, root: TreeNode):\n        self.stack = []\n        self._leftmost_inorder(root)\n\n    def _leftmost_inorder(self, node):\n        while node:\n            self.stack.append(node)\n            node = node.left\n\n    def next(self) -> int:\n        cur = self.stack.pop()\n        node = cur.right\n        self._leftmost_inorder(node)\n        return cur.val\n\n    def hasNext(self) -> bool:\n        return len(self.stack) > 0\n\n# Your BSTIterator object will be instantiated and called as such:\n# obj = BSTIterator(root)\n# param_1 = obj.next()\n# param_2 = obj.hasNext()\n\n#############\n\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass BSTIterator:\n    def __init__(self, root: TreeNode):\n        self.stack = []\n        while root:\n            self.stack.append(root)\n            root = root.left\n\n    def next(self) -> int:\n        cur = self.stack.pop()\n        node = cur.right\n        while node: # deplicated while block\n            self.stack.append(node)\n            node = node.left \n        return cur.val\n\n    def hasNext(self) -> bool:\n        return len(self.stack) > 0\n\n\n# Your BSTIterator object will be instantiated and called as such:\n# obj = BSTIterator(root)\n# param_1 = obj.next()\n# param_2 = obj.hasNext()",
    "174. Dungeon Game": "class Solution:\n    def calculateMinimumHP(self, dungeon: List[List[int]]) -> int:\n        m, n = len(dungeon), len(dungeon[0])\n        dp = [[inf] * (n + 1) for _ in range(m + 1)]\n        dp[m][n - 1] = dp[m - 1][n] = 1\n        for i in range(m - 1, -1, -1):\n            for j in range(n - 1, -1, -1):\n                dp[i][j] = max(1, min(dp[i + 1][j], dp[i][j + 1]) - dungeon[i][j])\n        return dp[0][0]",
    "179. Largest Number": "class Solution:\n    def largestNumber(self, nums: List[int]) -> str:\n        nums = [str(v) for v in nums]\n        nums.sort(key=cmp_to_key(lambda a, b: 1 if a + b < b + a else -1))\n        return \"0\" if nums[0] == \"0\" else \"\".join(nums)",
    "187. Repeated DNA Sequences": "class Solution:\n    def findRepeatedDnaSequences(self, s: str) -> List[str]:\n        words = set() # for encoded words\n        repeated = set() # for encoded words\n        result = [] # not encoded words\n\n        # A => binary: 00\n        # C => binary: 01\n        # G => binary: 10\n        # T => binary: 11\n        mapping = {'A': 0, 'C': 1, 'G': 2, 'T': 3}\n\n        for i in range(len(s) - 9):\n            v = 0\n            for j in range(i, i + 10):\n                # every time, use the new 2 bits after shifting for current char\n                v <<= 2\n                v |= mapping[s[j]]\n            if v in words and v not in repeated:\n                repeated.add(v)\n                result.append(s[i:i + 10])\n\n            words.add(v)\n\n        return result\n\n############\n\n",
    "188. Best Time to Buy and Sell Stock IV": "class Solution:\n    def maxProfit(self, k: int, prices: List[int]) -> int:\n        n = len(prices)\n        if n < 2:\n            return 0\n        # 3-D dp: n days * k completed transactions * 2 ops buy/sell\n        # my understanding, one transaction, meaning both buy then sell completed\n        dp = [[[0] * 2 for _ in range(k + 1)] for _ in range(n)]\n        for i in range(1, k + 1):\n            dp[0][i][1] = -prices[0] # dp[][][ 0/1 ], 1 is buy, 0 is sell\n        for i in range(1, n):\n            for j in range(1, k + 1):\n                dp[i][j][0] = max(dp[i - 1][j][1] + prices[i], dp[i - 1][j][0]) # [1] => sell happening <= that day\n                dp[i][j][1] = max(dp[i - 1][j - 1][0] - prices[i], dp[i - 1][j][1])\n        return dp[-1][k][0]\n\n##############\n\n",
    "189. Rotate Array": "class Solution:\n    def rotate(self, nums: List[int], k: int) -> None:\n        k %= len(nums)\n        nums[:] = nums[-k:] + nums[:-k]\n\n############\n\n",
    "190. Reverse Bits": "class Solution:\n    def reverseBits(self, n: int) -> int:\n        res = 0\n        for i in range(32):\n            res |= (n & 1) << (31 - i)\n            n >>= 1\n        return res",
    "191. Number of 1 Bits": "class Solution:\n    def hammingWeight(self, n: int) -> int:\n        ans = 0\n        while n:\n            n &= n - 1\n            ans += 1\n        return ans",
    "198. House Robber": "# greedy\nclass Solution:\n    def rob(self, nums: List[int]) -> int:\n        not_rob, rob = 0, nums[0]\n        for num in nums[1:]:\n            # must max check\n            # eg. first robbed 99999, then following ones are just 3,3,3,3,3\n            not_rob, rob = rob, max(num + not_rob, rob)\n        return rob\n\n############\n\nclass Solution(object):\n  def rob(self, nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    if len(nums) == 0:\n      return 0\n    if len(nums) <= 2:\n      return max(nums)\n    dp = [0 for i in range(0, 2)]\n    dp[0] = nums[0]\n    dp[1] = max(nums[1], nums[0])\n    for i in range(2, len(nums)):\n      dp[i % 2] = max(dp[(i - 1) % 2], dp[(i - 2) % 2] + nums[i])\n    return dp[(len(nums) - 1) % 2]",
    "199. Binary Tree Right Side View": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:\n        ans = []\n        if root is None:\n            return ans\n        q = deque([root])\n        while q:\n            ans.append(q[-1].val) # add last node of previous level traversal results\n            for _ in range(len(q)):\n                node = q.popleft()\n                if node.left:\n                    q.append(node.left)\n                if node.right:\n                    q.append(node.right)\n        return ans\n\n#############\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\nfrom collections import deque\n\n\nclass Solution(object):\n  def rightSideView(self, root):\n    \"\"\"\n    :type root: TreeNode\n    :rtype: List[int]\n    \"\"\"\n\n    def dfs(root, h):\n      if root:\n        if h == len(ans):\n          ans.append(root.val)\n          # pre-order, all the way to the right\n        dfs(root.right, h + 1)\n        dfs(root.left, h + 1)\n\n    ans = []\n    dfs(root, 0)\n    return ans",
    "200. Number of Islands": "# dfs\nclass Solution:\n    def numIslands(self, grid: List[List[str]]) -> int:\n        def dfs(i, j):\n            if not (0 <= i < m and 0 <= j < n and grid[i][j] == '1'):\n                return\n            grid[i][j] = '0'\n            for a, b in pairwise(dirs):\n                x, y = i + a, j + b\n                dfs(x, y)\n\n        ans = 0\n        dirs = (-1, 0, 1, 0, -1)\n        m, n = len(grid), len(grid[0])\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == '1':\n                    dfs(i, j)\n                    ans += 1\n        return ans\n\n###############\n\n# bfs\nfrom collections import deque\n\n",
    "201. Bitwise AND of Numbers Range": "class Solution:\n    def rangeBitwiseAnd(self, left: int, right: int) -> int:\n        while left < right:\n            right &= right - 1\n        return right",
    "202. Happy Number": "class Solution:\n    def isHappy(self, n: int) -> bool:\n        def next(x):\n            y = 0\n            while x:\n                x, v = divmod(x, 10)\n                y += v * v\n            return y\n\n        slow, fast = n, next(n)\n        while slow != fast:\n            slow, fast = next(slow), next(next(fast))\n        return slow == 1",
    "203. Remove Linked List Elements": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def removeElements(self, head: ListNode, val: int) -> ListNode:\n        dummy = ListNode(-1, head)\n        pre = dummy\n        while pre.next:\n            if pre.next.val != val:\n                pre = pre.next\n            else:\n                pre.next = pre.next.next\n        return dummy.next",
    "204. Count Primes": "class Solution:\n    def countPrimes(self, n: int) -> int:\n        primes = [True] * n\n        ans = 0\n        for i in range(2, n):\n            if primes[i]:\n                ans += 1\n                for j in range(i + i, n, i):\n                    primes[j] = False\n        return ans",
    "205. Isomorphic Strings": "class Solution:\n    def isIsomorphic(self, s: str, t: str) -> bool:\n        d1, d2 = [0] * 256, [0] * 256\n        for i, (a, b) in enumerate(zip(s, t), 1):\n            a, b = ord(a), ord(b)\n            if d1[a] != d2[b]:\n                return False\n            d1[a] = d2[b] = i\n        return True",
    "206. Reverse Linked List": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        pre, p = None, head\n        while p:\n            q = p.next\n            p.next = pre\n            pre = p\n            p = q\n        return pre\n\n\nclass Solution(object): # recursive\n  def reverseList(self, root):\n    if not root or not root.next:\n      return root\n\n    ret = self.reverseList(root.next)\n    root.next.next = root # root.next is end of the newly reversed list ret\n    root.next = None\n    return ret\n\n\n",
    "207. Course Schedule": "'''\n>>> from collections import defaultdict\n\n>>> a = defaultdict(int)\n>>> a\ndefaultdict(<type 'int'>, {})\n>>>\n>>> a['hehehe']\n0\n>>> a\ndefaultdict(<type 'int'>, {'hehehe': 0})\n\n\n>>> a = defaultdict(list)\n>>> a\ndefaultdict(<type 'list'>, {})\n>>> a['hehehe']\n[]\n>>> a\ndefaultdict(<type 'list'>, {'hehehe': []})\n'''\nclass Solution:\n    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:\n        g = defaultdict(list)\n        indeg = [0] * numCourses\n        for a, b in prerequisites:\n            g[b].append(a)\n            indeg[a] += 1\n        cnt = 0\n        q = deque([i for i, v in enumerate(indeg) if v == 0])\n        while q:\n            i = q.popleft()\n            cnt += 1\n            for j in g[i]:\n                indeg[j] -= 1\n                if indeg[j] == 0:\n                    q.append(j)\n        return cnt == numCourses",
    "208. Implement Trie (Prefix Tree)": "import collections\n\nclass TrieNode:\n\n def __init__(self):\n    '''\n    Usually, a Python dictionary throws a KeyError if you try to get an item with a key that is not currently in the dictionary.\n    The defaultdict in contrast will simply create any items that you try to access\n\n    https://stackoverflow.com/questions/5900578/how-does-collections-defaultdict-work\n    '''\n  self.child = collections.defaultdict(TrieNode)\n  self.is_word = False\n\nclass Trie:\n\n def __init__(self):\n  self.root = TrieNode()\n\n def insert(self, word: str) -> None:\n  cur = self.root\n  for letter in word:\n   cur = cur.child[letter]\n  cur.is_word = True\n\n def search(self, word: str) -> bool:\n  cur = self.root\n  for letter in word:\n   # cur = cur.child[letter] ==> will not work, it will creat a default node for this letter\n   cur = cur.child.get(letter)\n   if not cur:\n    return False\n  return cur.is_word\n\n def startsWith(self, prefix: str) -> bool:\n  cur = self.root\n  for letter in prefix:\n   # cur = cur.child[letter] ==> will not work, it will creat a default node for this letter\n   cur = cur.child.get(letter)\n   if not cur:\n    return False\n  return True\n\n# Your Trie object will be instantiated and called as such:\n# obj = Trie()\n# obj.insert(word)\n# param_2 = obj.search(word)\n# param_3 = obj.startsWith(prefix)\n\n\n############\n\nclass Trie:\n    def __init__(self):\n        self.children = [None] * 26\n        self.is_end = False\n\n    def insert(self, word: str) -> None:\n        node = self\n        for c in word:\n            idx = ord(c) - ord('a')\n            if node.children[idx] is None:\n                node.children[idx] = Trie()\n            node = node.children[idx]\n        node.is_end = True\n\n    def search(self, word: str) -> bool:\n        node = self._search_prefix(word)\n        return node is not None and node.is_end\n\n    def startsWith(self, prefix: str) -> bool:\n        node = self._search_prefix(prefix)\n        return node is not None\n\n    def _search_prefix(self, prefix: str):\n        node = self\n        for c in prefix:\n            idx = ord(c) - ord('a')\n            if node.children[idx] is None:\n                return None\n            node = node.children[idx]\n        return node\n\n\n# Your Trie object will be instantiated and called as such:\n# obj = Trie()\n# obj.insert(word)\n# param_2 = obj.search(word)\n# param_3 = obj.startsWith(prefix)\n\n\n\n# below is using reduce()\nclass Trie(object):\n\n    def __init__(self):\n        T = lambda: collections.defaultdict(T)\n        self.root = T()\n\n    def insert(self, word):\n        reduce(dict.__getitem__, word, self.root)['#'] = True\n\n    def search(self, word):\n        return '#' in reduce(lambda cur, c: cur.get(c, {}), word, self.root)\n\n    def startsWith(self, prefix):\n        return bool(reduce(lambda cur, c: cur.get(c, {}), prefix, self.root))",
    "209. Minimum Size Subarray Sum": "class Solution:\n    def minSubArrayLen(self, target: int, nums: List[int]) -> int:\n        n = len(nums)\n        ans = n + 1\n        s = j = 0\n        for i, x in enumerate(nums):\n            s += x\n            while j < n and s >= target:\n                ans = min(ans, i - j + 1)\n                s -= nums[j]\n                j += 1\n        return ans if ans <= n else 0",
    "210. Course Schedule II": "class Solution:\n    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:\n        g = defaultdict(list)\n        indeg = [0] * numCourses\n        for a, b in prerequisites:\n            g[b].append(a)\n            indeg[a] += 1\n        q = deque([i for i, v in enumerate(indeg) if v == 0])\n        ans = [] # added from previous question\n        while q:\n            i = q.popleft()\n            ans.append(i)\n            # assumption is only one path\n            # as in question 'You may assume that there are no duplicate edges in the input prerequisites.'\n            for j in g[i]:\n                indeg[j] -= 1\n                if indeg[j] == 0:\n                    q.append(j)\n        return ans if len(ans) == numCourses else []",
    "211. Add and Search Word - Data structure design": "class Trie:\n    def __init__(self):\n        self.children = [None] * 26\n        self.is_end = False\n\n\nclass WordDictionary:\n    def __init__(self):\n        self.trie = Trie()\n\n    def addWord(self, word: str) -> None:\n        node = self.trie\n        for c in word:\n            idx = ord(c) - ord('a')\n            if node.children[idx] is None:\n                node.children[idx] = Trie()\n            node = node.children[idx]\n        node.is_end = True\n\n    def search(self, word: str) -> bool:\n        def search(word, node):\n            for i in range(len(word)):\n                c = word[i]\n                idx = ord(c) - ord('a')\n                if c != '.' and node.children[idx] is None:\n                    return False\n                if c == '.':\n                    for child in node.children:\n                        if child is not None and search(word[i + 1 :], child):\n                            return True\n                    return False\n                node = node.children[idx]\n            return node.is_end\n\n        return search(word, self.trie)\n\n\n# Your WordDictionary object will be instantiated and called as such:\n# obj = WordDictionary()\n# obj.addWord(word)\n# param_2 = obj.search(word)",
    "212. Word Search II": "class Trie:\n    def __init__(self):\n        self.children = [None] * 26\n        self.w = ''\n        # minor ajust, not a boolean is_end, but the whole word\n        # so it's easier for dfs to save the word\n\n    def insert(self, w):\n        node = self\n        for c in w:\n            idx = ord(c) - ord('a')\n            if node.children[idx] is None:\n                node.children[idx] = Trie()\n            node = node.children[idx]\n        node.w = w\n\n\nclass Solution:\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\n        def dfs(node, i, j):\n            idx = ord(board[i][j]) - ord('a')\n            if node.children[idx] is None:\n                return\n            node = node.children[idx]\n            if node.w:\n                ans.add(node.w)\n            c = board[i][j]\n            board[i][j] = '0' # 0 for visited already\n            for a, b in [[0, -1], [0, 1], [1, 0], [-1, 0]]:\n                x, y = i + a, j + b\n                if 0 <= x < m and 0 <= y < n and board[x][y] != '0':\n                    dfs(node, x, y)\n            board[i][y] = c\n\n        trie = Trie()\n        for w in words:\n            trie.insert(w)\n        ans = set()\n        m, n = len(board), len(board[0])\n        for i in range(m):\n            for j in range(n):\n                dfs(trie, i, j)\n        return list(ans)\n\n\n################\n\n\nclass Trie:\n    def __init__(self):\n        self.children: List[Trie | None] = [None] * 26\n        self.ref: int = -1\n\n    def insert(self, w: str, ref: int):\n        node = self\n        for c in w:\n            idx = ord(c) - ord('a')\n            if node.children[idx] is None:\n                node.children[idx] = Trie()\n            node = node.children[idx]\n        node.ref = ref\n\n\n",
    "213. House Robber II": "class Solution:\n    def rob(self, nums: List[int]) -> int:\n        def robRange(nums, l, r): # re-use LC-198 solution\n            not_rob, rob = 0, nums[l]\n            for num in nums[l + 1 : r + 1]: # to include 'r'\n                not_rob, rob = rob, max(num + not_rob, rob)\n            return rob\n\n        n = len(nums)\n        if n == 1:\n            return nums[0]\n        s1, s2 = robRange(nums, 0, n - 2), robRange(nums, 1, n - 1) # inclusive\n        return max(s1, s2)\n\n############\n\n",
    "214. Shortest Palindrome": "'''\nreversed(): returns a reverse iterator\n\n>>> s = \"aabbcc\"\n>>> reversed(s)\n<reversed object at 0x108384a60>\n>>> ''.join(reversed(s))\n'ccbbaa'\n\n\n>>> s = \"aabbcc\"\n>>> s[::-1]\n'ccbbaa'\n'''\nclass Solution:\n    def shortestPalindrome(self, s: str) -> str:\n        if not s:\n            return \"\"\n\n        i, n = 0, len(s)\n        for j in range(n - 1, -1, -1):\n            if s[i] == s[j]:\n                i += 1\n\n        if i == n:\n            return s\n\n        remaining = s[i:]\n        rem_rev = remaining[::-1]\n        return rem_rev + self.shortestPalindrome(s[:i]) + remaining\n\n############\n\n",
    "215. Kth Largest Element in an Array": "class Solution:\n    def findKthLargest(self, nums: List[int], k: int) -> int:\n        lo, hi = 0, len(nums) - 1\n\n        while lo <= hi:\n            pos = self.partition(nums, lo, hi)\n            if pos == k - 1: # pos starting from 0, so -1\n                return nums[pos]  # partially sorted, desc\n            elif pos > k - 1:\n                hi = pos - 1\n            else:  # pos < k - 1\n                lo = pos + 1\n\n        return -1  # or raise exception\n\n    def partition(self, nums: List[int], lo: int, hi: int) -> int:\n        pivot, l, r = nums[lo], lo + 1, hi\n        while l <= r:\n            if nums[l] < pivot and nums[r] > pivot:\n                # larger num at left of pivot, easier to count for k-th lagest\n                nums[l], nums[r] = nums[r], nums[l]\n                l += 1\n                r -= 1\n            if nums[l] >= pivot:\n                l += 1\n            if nums[r] <= pivot:\n                r -= 1\n        # use nums[l] will lead to infinate looping\n        nums[lo], nums[r] = nums[r], nums[lo]\n        # possible there is duplicated num, but will be covered here\n        return r\n\n##############\n\n",
    "216. Combination Sum III": "class Solution:\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\n        def dfs(start, s, t): # s: sum, t: list\n            if s > n or len(t) > k:\n                return\n            if s == n and len(t) == k:\n                ans.append(t.copy())\n                return\n\n            for i in range(start, 10):\n                t.append(i)\n                dfs(i + 1, s + i, t)\n                t.pop()\n\n        ans = []\n        dfs(1, 0, [])\n        return ans",
    "217. Contains Duplicate": "class Solution:\n    def containsDuplicate(self, nums: List[int]) -> bool:\n        return len(set(nums)) < len(nums)\n\n############\n\nclass Solution(object):\n  def containsDuplicate(self, nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: bool\n    \"\"\"\n    nums.sort()\n    for i in range(0, len(nums) - 1):\n      if nums[i] == nums[i + 1]:\n        return True\n    return False",
    "218. The Skyline Problem": "'''\n>>> a = []\n>>> a.append((3, 5))\n>>> a.append((3, -5))\n>>> a.append((2, -10))\n>>> a.append((2, 10))\n>>> a\n[(3, 5), (3, -5), (2, -10), (2, 10)]\n\n>>> a.sort()\n>>> a\n[(2, -10), (2, 10), (3, -5), (3, 5)]\n\n\n\n>>> from queue import PriorityQueue\n>>> pq = PriorityQueue()\n>>>\n>>> pq.put([1,2,3])\n>>> pq.put([-10,20,30])\n>>> pq.put([11,22,33])\n>>>\n>>> pq\n<Queue.PriorityQueue instance at 0x10aec51b8>\n>>> pq.queue[0][0]\n-10\n>>> pq.get()\n[-10, 20, 30]\n>>> pq.queue[0][0]\n1\n'''\n\nfrom queue import PriorityQueue\nclass Solution:\n    def getSkyline(self, buildings: List[List[int]]) -> List[List[int]]:\n        ans, lines, pq = [], [], PriorityQueue()\n        for build in buildings:\n            lines.extend([build[0], build[1]])\n        lines.sort()\n        curbuilding, n = 0, len(buildings)\n        for line in lines: # \u5bf9\u4e8e\u6bcf\u4e00\u4e2a\u8fb9\u754c\u7ebf lines[i]\uff0c\u627e\u51fa\u6240\u6709\u5305\u542b lines[i] \u7684\u5efa\u7b51\u7269\n            while curbuilding < n and buildings[curbuilding][0] <= line:\n                pq.put([-buildings[curbuilding][2], buildings[curbuilding][0], buildings[curbuilding][1]]) # \u5efa\u7b51\u7269\u7684\u9ad8\u5ea6\u6784\u5efa\u4f18\u5148\u961f\u5217\uff08\u5927\u6839\u5806\uff09\uff0c\u8fd9\u91cc\u4f1a\u5305\u62ecline\u81ea\u5df1\u7684building\n                curbuilding += 1\n            while not pq.empty() and pq.queue[0][2] <= line: # higher at heap top after negated\n                pq.get() # i.e. pop(), remove no-overlapping building\n            high = 0 # \u5efa\u7b51\u7269\u7684\u5de6\u8fb9\u754c\u5c0f\u4e8e\u7b49\u4e8e lines[i]\uff0c\u53f3\u8fb9\u754c\u5927\u4e8e lines[i]\uff0c\u5219\u8fd9\u4e9b\u5efa\u7b51\u7269\u4e2d\u9ad8\u5ea6\u6700\u9ad8\u7684\u5efa\u7b51\u7269\u7684\u9ad8\u5ea6\u5c31\u662f\u8be5\u7ebf\u8f6e\u5ed3\u70b9\u7684\u9ad8\u5ea6\n            if not pq.empty():\n                high = -pq.queue[0][0]\n            if len(ans) > 0 and ans[-1][1] == high: # \u7eff\u8272\u5efa\u7b51\u7684\u5de6\u8fb9\u7684line\uff0c\u5c31\u8981\u8df3\u8fc7\n                continue\n            ans.append([line, high])\n        return ans\n\n############\n\n'''\nThe solution uses a list called points to store the critical points and heights of the buildings. Each point is represented as a tuple (x, h), where x is the x-coordinate and h is the height. The points are sorted in ascending order based on the x-coordinate.\n\nThe solution also uses a heap to store the heights in descending order. The heap is initialized with a height of 0. For each point, if the height is negative, it means it is the start of a building, so the negative height is added to the heap. If the height is positive, it means it is the end of a building, so the corresponding negative height is removed from the heap.\n\nAfter processing each point, the maximum height is obtained from the heap, and if it is different from the previous maximum height, the current point is added to the skyline.\n\nFinally, the skyline is returned, excluding the initial point (0, 0) that was added as a starting point.\n\nNote: The solution assumes that the input buildings is a list of tuples (left, right, height), where left and right represent the x-coordinates of the building's left and right edges, and height represents the height of the building.\n'''\n\nimport heapq\n\n",
    "219. Contains Duplicate II": "class Solution:\n    def containsNearbyDuplicate(self, nums: List[int], k: int) -> bool:\n        mp = {}\n        for i, v in enumerate(nums):\n            if v in mp and i - mp[v] <= k:\n                return True\n            mp[v] = i\n        return False",
    "220. Contains Duplicate III": "'''\nSorted Containers is an Apache2 licensed sorted collections library, written in pure-Python, and fast as C-extensions.\n\n\n>>> from sortedcontainers import SortedList\n>>> sl = SortedList(['e', 'a', 'c', 'd', 'b'])\n>>> sl\nSortedList(['a', 'b', 'c', 'd', 'e'])\n>>> sl *= 10_000_000\n>>> sl.count('c')\n10000000\n>>> sl[-3:]\n['e', 'e', 'e']\n\n>>> from sortedcontainers import SortedDict\n>>> sd = SortedDict({'c': 3, 'a': 1, 'b': 2})\n>>> sd\nSortedDict({'a': 1, 'b': 2, 'c': 3})\n>>> sd.popitem(index=-1)\n('c', 3)\n\n>>> from sortedcontainers import SortedSet\n>>> ss = SortedSet('abracadabra')\n>>> ss\nSortedSet(['a', 'b', 'c', 'd', 'r'])\n>>> ss.bisect_left('c')\n2\n\n\nref: https://pypi.org/project/sortedcontainers/\n'''\n\nfrom sortedcontainers import SortedSet\n\nclass Solution:\n    def containsNearbyAlmostDuplicate(\n        self, nums: List[int], indexDiff: int, valueDiff: int\n    ) -> bool:\n        s = SortedSet()\n        for i, v in enumerate(nums):\n            j = s.bisect_left(v - valueDiff) # then true: s[j] <= v - valueDiff\n            if j < len(s) and s[j] <= v + valueDiff:\n                return True\n            s.add(v)\n            if i >= indexDiff:\n                s.remove(nums[i - indexDiff])\n        return False\n\n############\n\n'''\nbisect: maintaining a list in sorted order without having to sort the list after each insertion.\nhttps://docs.python.org/3/library/bisect.html\n\nbisect.bisect_left()\nLocate the insertion point for x in a to maintain sorted order.\n\nbisect.bisect_right() or bisect.bisect()\nSimilar to bisect_left(), but returns an insertion point which comes after (to the right of) any existing entries of x in a.\n\n\nbisect.insort_left(a, x, lo=0, hi=len(a), *, key=None)\nInsert x in a in sorted order.\nKeep in mind that the O(log n) search is dominated by the slow O(n) insertion step.\n\n\nbisect.insort_right(a, x, lo=0, hi=len(a), *, key=None)\nbisect.insort(a, x, lo=0, hi=len(a), *, key=None)\nSimilar to insort_left(), but inserting x in a after any existing entries of x.\n\n\n>>> import bisect\n>>> bisect.bisect_left([1,2,3], 2)\n1\n>>> bisect.bisect_right([1,2,3], 2)\n2\n\n>>> a = [1, 1, 1, 2, 3]\n>>> bisect.insort_left(a, 1.0)\n>>> a\n[1.0, 1, 1, 1, 2, 3]\n\n>>> a = [1, 1, 1, 2, 3]\n>>> bisect.insort_right(a, 1.0)\n>>> a\n[1, 1, 1, 1.0, 2, 3]\n\n>>> a = [1, 1, 1, 2, 3]\n>>> bisect.insort(a, 1.0)\n>>> a\n[1, 1, 1, 1.0, 2, 3]\n'''\n\nimport bisect\n\nclass Solution(object):\n  def containsNearbyAlmostDuplicate(self, nums, k, t):\n    \"\"\"\n    :type nums: List[int]\n    :type k: int\n    :type t: int\n    :rtype: bool\n    \"\"\"\n    if k == 0:\n      return False\n    bst = []\n    if k < 0 or t < 0:\n      return False\n    for i, num in enumerate(nums):\n      idx = bisect.bisect_left(bst, num)\n      if idx < len(bst) and abs(bst[idx] - num) <= t:\n        return True\n      if idx > 0 and abs(bst[idx - 1] - num) <= t: # idx-1 is because, [3,4,5] and 3.5 insertion-index is 1, but here should check index=0 (i.e. 3), so idx-1\n        return True\n      if len(bst) >= k:\n        del bst[bisect.bisect_left(bst, nums[i - k])]\n      bisect.insort(bst, num)\n    return False",
    "221. Maximal Square": "'''\neg. a 10*10 sqaure with full of 1s\n    this square move 1 line down\n    this square move 1 line right\n\n    so there needs an extra single 1 at bottom right, to make it a larger full square\n'''\nclass Solution:\n    def maximalSquare(self, matrix: List[List[str]]) -> int:\n        m, n = len(matrix), len(matrix[0])\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        mx = 0\n        for i in range(m):\n            for j in range(n):\n                if matrix[i][j] == '1':\n                    dp[i + 1][j + 1] = 1 + min(dp[i][j + 1], dp[i + 1][j], dp[i][j])\n                    mx = max(mx, dp[i + 1][j + 1])\n        return mx * mx",
    "222. Count Complete Tree Nodes": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def countNodes(self, root: Optional[TreeNode]) -> int:\n        def depth(root):\n            d = 0\n            while root:\n                d += 1\n                root = root.left\n            return d\n\n        if root is None:\n            return 0\n        left, right = depth(root.left), depth(root.right)\n        if left == right:\n            # left child subtree: (1<<left)-1\n            # plus root: +1\n            # so total except right subtree: (1<<left)\n            return (1 << left) + self.countNodes(root.right)\n        else: # left = right+1\n            return (1 << right) + self.countNodes(root.left)\n\n############\n\n'''\n>>> 2 ** 3\n8\n>>> 3 ** 2\n9\n'''\n\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution(object):\n  def getHeight(self, root):\n    height = 0\n    while root:\n      height += 1\n      root = root.left\n    return height\n\n  def countNodes(self, root):\n    count = 0\n    while root:\n      l, r = map(self.getHeight, (root.left, root.right))\n      if l == r:\n        count += 2 ** l\n        root = root.right\n      else:\n        count += 2 ** r\n        root = root.left\n    return count",
    "223. Rectangle Area": "class Solution:\n    def computeArea(\n        self,\n        ax1: int,\n        ay1: int,\n        ax2: int,\n        ay2: int,\n        bx1: int,\n        by1: int,\n        bx2: int,\n        by2: int,\n    ) -> int:\n        a = (ax2 - ax1) * (ay2 - ay1)\n        b = (bx2 - bx1) * (by2 - by1)\n        width = min(ax2, bx2) - max(ax1, bx1)\n        height = min(ay2, by2) - max(ay1, by1)\n        return a + b - max(height, 0) * max(width, 0)\n\n############\n\nclass Solution(object):\n  def computeArea(self, A, B, C, D, E, F, G, H):\n    \"\"\"\n    :type A: int\n    :type B: int\n    :type C: int\n    :type D: int\n    :type E: int\n    :type F: int\n    :type G: int\n    :type H: int\n    :rtype: int\n    \"\"\"\n    area = (C - A) * (D - B) + (G - E) * (H - F)\n    overlap = max(min(C, G) - max(A, E), 0) * max(min(D, H) - max(B, F), 0)\n    return area - overlap",
    "224. Basic Calculator": "# only + and - , no * , no / \nclass Solution:\n    def calculate(self, s: str) -> int:\n        stk = []\n        ans, sign = 0, 1\n        i, n = 0, len(s)\n        while i < n:\n            if s[i].isdigit():\n                x = 0\n                j = i\n                # with this while, no need to do final calculation like below solution\n                while j < n and s[j].isdigit():\n                    x = x * 10 + int(s[j])\n                    j += 1\n                ans += sign * x\n                i = j - 1\n            elif s[i] == \"+\":\n                sign = 1\n            elif s[i] == \"-\":\n                sign = -1\n            elif s[i] == \"(\":\n                stk.append(ans)\n                stk.append(sign)\n                ans, sign = 0, 1\n            elif s[i] == \")\":\n                ans = stk.pop() * ans + stk.pop()\n            i += 1\n        return ans\n\n#############\n\n",
    "225. Implement Stack using Queues": "# one queue\n\n'''\npush(1), [1]\npush(2), [1,2] => [2,1]\npush(3), [2,1,3] => [1,3,2] => [3,2,1]\npush(4), [3,2,1,4] => switch 3 time to get [4,3,2,1]\npush(5), [4,3,2,1,5] => switch 4 time to get [5,4,3,2,1]\n'''\nclass Stack:\n\n    def __init__(self):\n        self._queue = collections.deque()\n\n    def push(self, x):\n        q = self._queue\n        q.append(x)\n        for _ in range(len(q) - 1):\n            q.append(q.popleft())\n        \n    def pop(self):\n        return self._queue.popleft()\n\n    def top(self):\n        return self._queue[0]\n    \n    def empty(self):\n        return not len(self._queue)\n\n# Your MyStack object will be instantiated and called as such:\n# obj = MyStack()\n# obj.push(x)\n# param_2 = obj.pop()\n# param_3 = obj.top()\n# param_4 = obj.empty()\n\n############\n\nfrom collections import deque\n\n# two queues\nclass MyStack:\n\n def __init__(self):\n  self.q1 = deque()\n  self.q2 = deque()\n\n def push(self, x: int) -> None:\n  self.q1.append(x)\n\n def pop(self) -> int:\n  while len(self.q1) != 1:\n   self.q2.append(self.q1.popleft())\n\n  val = self.q1.popleft()\n  self.q1, self.q2 = self.q2, self.q1\n  return val\n\n def top(self) -> int:\n  while len(self.q1) != 1:\n   self.q2.append(self.q1.popleft())\n\n        # tried to re-use while part, but seems not achievable, since val is retrieved in-between \n  val = self.q1[0]\n  self.q2.append(self.q1.popleft())  # note: add back to q2, so q1 will always be empty\n\n  self.q1, self.q2 = self.q2, self.q1\n  return val\n\n\n def empty(self) -> bool:\n  return not self.q1\n\n# Your MyStack object will be instantiated and called as such:\n# obj = MyStack()\n# obj.push(x)\n# param_2 = obj.pop()\n# param_3 = obj.top()\n# param_4 = obj.empty()",
    "226. Invert Binary Tree": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def invertTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\n        def dfs(root):\n            if root is None:\n                return\n            root.left, root.right = root.right, root.left\n            dfs(root.left)\n            dfs(root.right)\n\n        dfs(root)\n        return root",
    "227. Basic Calculator II": "class Solution:\n    def calculate(self, s: str) -> int:\n        v, n = 0, len(s)\n        sign = '+'\n        stk = []\n        for i, c in enumerate(s):\n            if c.isdigit():\n                v = v * 10 + int(c)\n            if i == n - 1 or c in '+-*/':\n                if sign == '+':\n                    stk.append(v)\n                # for \"10-2*5\": when '-' encountered, var 'sign' is still '+'\n                # so '10' will be pushed to stk before setting sign to '-'\n                elif sign == '-':\n                    stk.append(-v)\n                elif sign == '*':\n                    stk.append(stk.pop() * v)\n                elif sign == '/':\n                    stk.append(int(stk.pop() / v))\n                else:\n                    print(\"operator not supported\")\n\n                sign = c # reset inside 'if'\n                v = 0\n        return sum(stk)",
    "228. Summary Ranges": "class Solution:\n    def summaryRanges(self, nums: List[int]) -> List[str]:\n        def f(i: int, j: int) -> str:\n            return str(nums[i]) if i == j else f'{nums[i]}->{nums[j]}'\n\n        i = 0\n        n = len(nums)\n        ans = []\n        while i < n:\n            j = i\n            while j + 1 < n and nums[j + 1] == nums[j] + 1:\n                j += 1\n            ans.append(f(i, j))\n            i = j + 1\n        return ans",
    "229. Majority Element II": "class Solution:\n    def majorityElement(self, nums: List[int]) -> List[int]:\n        n1 = n2 = 0\n        m1, m2 = 0, 1\n        for m in nums:\n            if m == m1:\n                n1 += 1\n            elif m == m2:\n                n2 += 1\n            elif n1 == 0:\n                m1, n1 = m, 1\n            elif n2 == 0:\n                m2, n2 = m, 1\n            else:\n                n1, n2 = n1 - 1, n2 - 1\n        return [m for m in [m1, m2] if nums.count(m) > len(nums) // 3]",
    "230. Kth Smallest Element in a BST": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def kthSmallest(self, root: Optional[TreeNode], k: int) -> int:\n        stk = []\n        while root or stk:\n            if root:\n                stk.append(root)\n                root = root.left\n            else:\n                root = stk.pop()\n                k -= 1\n                if k == 0:\n                    return root.val\n                root = root.right\n\n############\n\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution_followUp:\n    def kthSmallest(self, root: TreeNode, k: int) -> int:\n        node = self.build(root)\n        return self.dfs(node, k)\n\n    class MyTreeNode:\n        def __init__(self, x):\n            self.val = x\n            self.count = 1 # default 1\n            self.left = None\n            self.right = None\n\n    def build(self, root: TreeNode) -> MyTreeNode:\n        if not root:\n            return None\n        node = self.MyTreeNode(root.val) # default count already is 1\n        node.left = self.build(root.left)\n        node.right = self.build(root.right)\n        if node.left:\n            node.count += node.left.count\n        if node.right:\n            node.count += node.right.count\n        return node\n\n    def dfs(self, node: MyTreeNode, k: int) -> int:\n        if node.left:\n            cnt = node.left.count\n            if k < cnt + 1:\n                return self.dfs(node.left, k)\n            elif k > cnt + 1:\n                return self.dfs(node.right, k - 1 - cnt)\n            else: # k == cnt+1\n                return node.val\n        else:\n            if k == 1: # cannot move to beginning of dfs()\n                return node.val\n            return self.dfs(node.right, k - 1)",
    "231. Power of Two": "class Solution:\n    def isPowerOfTwo(self, n: int) -> bool:\n        return n > 0 and (n & (n - 1)) == 0",
    "232. Implement Queue using Stacks": "class MyQueue:\n    def __init__(self):\n        self.stk1 = []\n        self.stk2 = [] # reversed order\n\n    def push(self, x: int) -> None:\n        self.stk1.append(x)\n\n    def pop(self) -> int:\n        self.move()\n        return self.stk2.pop()\n\n    def peek(self) -> int:\n        self.move()\n        return self.stk2[-1]\n\n    def empty(self) -> bool:\n        return not self.stk1 and not self.stk2\n\n    def move(self):\n        if not self.stk2: # only when skt2 is empty\n            while self.stk1:\n                self.stk2.append(self.stk1.pop())\n\n\n# Your MyQueue object will be instantiated and called as such:\n# obj = MyQueue()\n# obj.push(x)\n# param_2 = obj.pop()\n# param_3 = obj.peek()\n# param_4 = obj.empty()\n\n############\n\nclass MyQueue:\n\n    def __init__(self):\n        self.sk = []\n        self.rsk = [] # reversed\n\n    def push(self, x: int) -> None:\n        self.sk.append(x);\n        \n\n    def pop(self) -> int:\n        self.peek()\n        return self.rsk.pop()\n\n    def peek(self) -> int:\n        if self.rsk:\n            return self.rsk[-1]\n        else:\n            while self.sk:\n                self.rsk.append(self.sk.pop())\n            return self.rsk[-1]\n        \n\n    def empty(self) -> bool:\n        \n        return not (self.sk or self.rsk)\n        \n\n\n# Your MyQueue object will be instantiated and called as such:\n# obj = MyQueue()\n# obj.push(x)\n# param_2 = obj.pop()\n# param_3 = obj.peek()\n# param_4 = obj.empty()",
    "233. Number of Digit One": "class Solution:\n    def countDigitOne(self, n: int) -> int:\n        @cache\n        def dfs(pos, cnt, limit):\n            if pos <= 0:\n                return cnt\n            up = a[pos] if limit else 9\n            ans = 0\n            for i in range(up + 1):\n                ans += dfs(pos - 1, cnt + (i == 1), limit and i == up)\n            return ans\n\n        a = [0] * 12\n        l = 1\n        while n:\n            a[l] = n % 10\n            n //= 10\n            l += 1\n        return dfs(l, 0, True)",
    "234. Palindrome Linked List": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def isPalindrome(self, head: Optional[ListNode]) -> bool:\n        slow, fast = head, head.next\n        while fast and fast.next:\n            slow, fast = slow.next, fast.next.next\n        pre, cur = None, slow.next\n        while cur:\n            t = cur.next\n            cur.next = pre\n            pre, cur = cur, t\n        while pre:\n            if pre.val != head.val:\n                return False\n            pre, head = pre.next, head.next\n        return True",
    "235. Lowest Common Ancestor of a Binary Search Tree": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def lowestCommonAncestor(\n        self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode'\n    ) -> 'TreeNode':\n        while 1:\n            if root.val < min(p.val, q.val): # no =, so root is p or q is in else block\n                root = root.right\n            elif root.val > max(p.val, q.val):\n                root = root.left\n            else:\n                return root\n\n############\n\n",
    "236. Lowest Common Ancestor of a Binary Tree": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def lowestCommonAncestor(\n        self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode'\n    ) -> 'TreeNode':\n        if root is None or root == p or root == q:\n            return root\n        left = self.lowestCommonAncestor(root.left, p, q)\n        right = self.lowestCommonAncestor(root.right, p, q)\n        return root if left and right else (left or right)\n\n############\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution(object):\n  def lowestCommonAncestor(self, root, p, q):\n    \"\"\"\n    :type root: TreeNode\n    :type p: TreeNode\n    :type q: TreeNode\n    :rtype: TreeNode\n    \"\"\"\n\n    if not root:\n      return root\n\n    left = self.lowestCommonAncestor(root.left, p, q)\n    right = self.lowestCommonAncestor(root.right, p, q)\n\n    if left and right:\n      return root\n\n    if root == p or root == q:\n      return root\n\n    if left:\n      return left\n    if right:\n      return right\n    return None",
    "237. Delete Node in a Linked List": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\n\nclass Solution:\n    def deleteNode(self, node):\n        \"\"\"\n        :type node: ListNode\n        :rtype: void Do not return anything, modify node in-place instead.\n        \"\"\"\n        node.val = node.next.val\n        node.next = node.next.next",
    "238. Product of Array Except Self": "class Solution: # 2 extra arrays\n    def productExceptSelf(self, nums):\n        if nums is None or len(nums) == 0:\n            return nums\n\n        # Product from index=0 to index=i-1\n        from_left = [1] * len(nums)\n        for i in range(1, len(nums)):\n            from_left[i] = nums[i - 1] * from_left[i - 1]\n\n        # Product from index=n-1 to current position\n        from_right = [1] * len(nums)\n        for i in range(len(nums) - 2, -1, -1):\n            from_right[i] = nums[i + 1] * from_right[i + 1]\n\n        # Calculate result\n        result = [0] * len(nums)\n        for i in range(len(nums)):\n            result[i] = from_left[i] * from_right[i]\n\n        return result\n\n############\n\n",
    "239. Sliding Window Maximum": "from collections import deque\n\nclass Solution:\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n        q = deque()\n        ans = []\n        for i, v in enumerate(nums):\n            if q and i - k + 1 > q[0]:\n                q.popleft() # remove index if out of window left\n            while q and nums[q[-1]] <= v: # `<=`, not `<`, to ensure the bigger index stored in deque\n                q.pop()\n            q.append(i)\n            if i >= k - 1:\n                ans.append(nums[q[0]])\n        return ans\n\n############\n\nclass Solution(object):\n  def maxSlidingWindow(self, nums, k):\n    \"\"\"\n    :type nums: List[int]\n    :type k: int\n    :rtype: List[int]\n    \"\"\"\n    if k == 0:\n      return []\n    ans = [0 for _ in range(len(nums) - k + 1)]\n    stack = collections.deque([])\n    for i in range(0, k):\n      while stack and nums[stack[-1]] < nums[i]:\n        stack.pop()\n      stack.append(i)\n    ans[0] = nums[stack[0]]\n    idx = 0\n    for i in range(k, len(nums)):\n      idx += 1\n      if stack and stack[0] == i - k:\n        stack.popleft()\n      while stack and nums[stack[-1]] < nums[i]:\n        stack.pop()\n      stack.append(i)\n      ans[idx] = nums[stack[0]]\n\n    return ans",
    "240. Search a 2D Matrix II": "# Binary Search Variant\ndef binarySearch(row: List[int], target: int) -> bool:\n    left, right = 0, len(row) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if row[mid] == target:\n            return True\n        elif row[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return False\n\ndef searchMatrix(matrix: List[List[int]], target: int) -> bool:\n    for row in matrix:\n        if binarySearch(row, target):\n            return True\n    return False\n\n##############\n\n# start from top-right corner\nclass Solution:\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\n        if not matrix or not matrix[0]:\n            return False\n        \n        row, col = len(matrix), len(matrix[0])\n        i, j = 0, col - 1\n        \n        while i < row and j >= 0:\n            val = matrix[i][j]\n            if val == target:\n                return True\n            elif target < val:\n                j -= 1  # all numbers in that column are even larger\n            else:\n                i += 1  # all numbers in that row are even smaller\n        \n        return False\n\n# start from bottom-left corner\n",
    "241. Different Ways to Add Parentheses": "class Solution:\n    def diffWaysToCompute(self, expression: str) -> List[int]:\n        @cache # note\n        def dfs(exp):\n            if exp.isdigit():\n                return [int(exp)] # return list\n            ans = []\n            for i, c in enumerate(exp):\n                if c in '-+*':\n                    left, right = dfs(exp[:i]), dfs(exp[i + 1 :])\n                    for a in left:\n                        for b in right:\n                            if c == '-':\n                                ans.append(a - b)\n                            elif c == '+':\n                                ans.append(a + b)\n                            else:\n                                ans.append(a * b)\n            return ans\n\n        return dfs(expression)\n\n############\n\n'''\n>>> from operator import *\n>>> add(1,2)\n3\n>>> sub(1,2)\n-1\n>>> mul(1,2)\n2\n>>> div(1,2)\n0\n\n### append() vs extend()\n\n>>> x = [1, 2, 3]\n>>> x.append([4, 5])\n>>> print(x)\n[1, 2, 3, [4, 5]]\n\n\n>>> x = [1, 2, 3]\n>>> x.extend([4, 5])\n>>> print(x)\n[1, 2, 3, 4, 5]\n\n\nhttps://stackoverflow.com/questions/252703/what-is-the-difference-between-pythons-list-methods-append-and-extend\n'''\n\nfrom operator import *\n\nclass Solution(object):\n  def diffWaysToCompute(self, input):\n    \"\"\"\n    :type input: str\n    :rtype: List[int]\n    \"\"\"\n    ops = {\"+\": add, \"-\": sub, \"*\": mul, \"/\": div}\n    ans = []\n    for i, c in enumerate(input):\n      if c in ops:\n        left = self.diffWaysToCompute(input[:i])\n        right = self.diffWaysToCompute(input[i + 1:])\n        ans.extend([ops[c](a, b) for a in left for b in right])\n    return ans if ans else [int(input)]",
    "242. Valid Anagram": "class Solution:\n    def isAnagram(self, s: str, t: str) -> bool:\n        if len(s) != len(t):\n            return False\n        cnt = Counter(s)\n        for c in t:\n            cnt[c] -= 1\n            if cnt[c] < 0:\n                return False\n        return True"
}