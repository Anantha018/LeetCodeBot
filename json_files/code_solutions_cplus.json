{
    "1. Two Sum": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> m;\n        for (int i = 0;; ++i) {\n            int x = nums[i];\n            int y = target - x;\n            if (m.count(y)) {\n                return {m[y], i};\n            }\n            m[x] = i;\n        }\n    }\n};",
    "2. Add Two Numbers": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n        ListNode* dummy = new ListNode();\n        int carry = 0;\n        ListNode* cur = dummy;\n        while (l1 || l2 || carry) {\n            int s = (l1 ? l1->val : 0) + (l2 ? l2->val : 0) + carry;\n            carry = s / 10;\n            cur->next = new ListNode(s % 10);\n            cur = cur->next;\n            l1 = l1 ? l1->next : nullptr;\n            l2 = l2 ? l2->next : nullptr;\n        }\n        return dummy->next;\n    }\n};",
    "4. Median of Two Sorted Arrays": "class Solution {\npublic:\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\n        int m = nums1.size(), n = nums2.size();\n        function<int(int, int, int)> f = [&](int i, int j, int k) {\n            if (i >= m) {\n                return nums2[j + k - 1];\n            }\n            if (j >= n) {\n                return nums1[i + k - 1];\n            }\n            if (k == 1) {\n                return min(nums1[i], nums2[j]);\n            }\n            int p = k / 2;\n            int x = i + p - 1 < m ? nums1[i + p - 1] : 1 << 30;\n            int y = j + p - 1 < n ? nums2[j + p - 1] : 1 << 30;\n            return x < y ? f(i + p, j, k - p) : f(i, j + p, k - p);\n        };\n        int a = f(0, 0, (m + n + 1) / 2);\n        int b = f(0, 0, (m + n + 2) / 2);\n        return (a + b) / 2.0;\n    }\n};",
    "5. Longest Palindromic Substring": "class Solution {\npublic:\n    string longestPalindrome(string s) {\n        int n = s.size();\n        vector<vector<bool>> f(n, vector<bool>(n, true));\n        int k = 0, mx = 1;\n        for (int i = n - 2; ~i; --i) {\n            for (int j = i + 1; j < n; ++j) {\n                f[i][j] = false;\n                if (s[i] == s[j]) {\n                    f[i][j] = f[i + 1][j - 1];\n                    if (f[i][j] && mx < j - i + 1) {\n                        mx = j - i + 1;\n                        k = i;\n                    }\n                }\n            }\n        }\n        return s.substr(k, mx);\n    }\n};",
    "6. ZigZag Conversion": "// OJ: https://leetcode.com/problems/zigzag-conversion/\n// Time: O(N)\n// Space: O(1)\nclass Solution {\npublic:\n    string convert(string s, int numRows) {\n        if (numRows == 1) return s;\n        int N = s.size(), d = (numRows - 1) * 2;\n        string ans;\n        for (int i = 0; i < numRows; ++i) {\n            int w = 2 * i;\n            for (int j = i; j < N;) {\n                ans += s[j];\n                w = d - w;\n                if (!w) w = d;\n                j += w;\n            }\n        }\n        return ans;\n    }\n};",
    "7. Reverse Integer": "class Solution {\npublic:\n    int reverse(int x) {\n        int ans = 0;\n        for (; x; x /= 10) {\n            if (ans < INT_MIN / 10 || ans > INT_MAX / 10) {\n                return 0;\n            }\n            ans = ans * 10 + x % 10;\n        }\n        return ans;\n    }\n};",
    "9. Palindrome Number": "class Solution {\npublic:\n    bool isPalindrome(int x) {\n        if (x < 0 || (x && x % 10 == 0)) {\n            return false;\n        }\n        int y = 0;\n        for (; y < x; x /= 10) {\n            y = y * 10 + x % 10;\n        }\n        return x == y || x == y / 10;\n    }\n};",
    "10. Regular Expression Matching": "class Solution {\npublic:\n    bool isMatch(string s, string p) {\n        int m = s.size(), n = p.size();\n        bool f[m + 1][n + 1];\n        memset(f, false, sizeof f);\n        f[0][0] = true;\n        for (int i = 0; i <= m; ++i) {\n            for (int j = 1; j <= n; ++j) {\n                if (p[j - 1] == '*') {\n                    f[i][j] = f[i][j - 2];\n                    if (i && (p[j - 2] == '.' || p[j - 2] == s[i - 1])) {\n                        f[i][j] |= f[i - 1][j];\n                    }\n                } else if (i && (p[j - 1] == '.' || p[j - 1] == s[i - 1])) {\n                    f[i][j] = f[i - 1][j - 1];\n                }\n            }\n        }\n        return f[m][n];\n    }\n};",
    "11. Container With Most Water": "class Solution {\npublic:\n    int maxArea(vector<int>& height) {\n        int i = 0, j = height.size() - 1;\n        int ans = 0;\n        while (i < j) {\n            int t = min(height[i], height[j]) * (j - i);\n            ans = max(ans, t);\n            if (height[i] < height[j]) {\n                ++i;\n            } else {\n                --j;\n            }\n        }\n        return ans;\n    }\n};",
    "12. Integer to Roman": "class Solution {\npublic:\n    string intToRoman(int num) {\n        vector<string> cs = {\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"};\n        vector<int> vs = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n        string ans;\n        for (int i = 0; i < cs.size(); ++i) {\n            while (num >= vs[i]) {\n                num -= vs[i];\n                ans += cs[i];\n            }\n        }\n        return ans;\n    }\n};",
    "13. Roman to Integer": "class Solution {\npublic:\n    int romanToInt(string s) {\n        unordered_map<char, int> nums{\n            {'I', 1},\n            {'V', 5},\n            {'X', 10},\n            {'L', 50},\n            {'C', 100},\n            {'D', 500},\n            {'M', 1000},\n        };\n        int ans = nums[s.back()];\n        for (int i = 0; i < s.size() - 1; ++i) {\n            int sign = nums[s[i]] < nums[s[i + 1]] ? -1 : 1;\n            ans += sign * nums[s[i]];\n        }\n        return ans;\n    }\n};",
    "14. Longest Common Prefix": "class Solution {\npublic:\n    string longestCommonPrefix(vector<string>& strs) {\n        int n = strs.size();\n        for (int i = 0; i < strs[0].size(); ++i) {\n            for (int j = 1; j < n; ++j) {\n                if (strs[j].size() <= i || strs[j][i] != strs[0][i]) {\n                    return strs[0].substr(0, i);\n                }\n            }\n        }\n        return strs[0];\n    }\n};",
    "15. 3Sum": "class Solution {\npublic:\n    vector<vector<int>> threeSum(vector<int>& nums) {\n        sort(nums.begin(), nums.end());\n        vector<vector<int>> ans;\n        int n = nums.size();\n        for (int i = 0; i < n - 2 && nums[i] <= 0; ++i) {\n            if (i && nums[i] == nums[i - 1]) {\n                continue;\n            }\n            int j = i + 1, k = n - 1;\n            while (j < k) {\n                int x = nums[i] + nums[j] + nums[k];\n                if (x < 0) {\n                    ++j;\n                } else if (x > 0) {\n                    --k;\n                } else {\n                    ans.push_back({nums[i], nums[j++], nums[k--]});\n                    while (j < k && nums[j] == nums[j - 1]) {\n                        ++j;\n                    }\n                    while (j < k && nums[k] == nums[k + 1]) {\n                        --k;\n                    }\n                }\n            }\n        }\n        return ans;\n    }\n};",
    "16. 3Sum Closest": "class Solution {\npublic:\n    int threeSumClosest(vector<int>& nums, int target) {\n        sort(nums.begin(), nums.end());\n        int ans = 1 << 30;\n        int n = nums.size();\n        for (int i = 0; i < n; ++i) {\n            int j = i + 1, k = n - 1;\n            while (j < k) {\n                int t = nums[i] + nums[j] + nums[k];\n                if (t == target) return t;\n                if (abs(t - target) < abs(ans - target)) ans = t;\n                if (t > target)\n                    --k;\n                else\n                    ++j;\n            }\n        }\n        return ans;\n    }\n};",
    "17. Letter Combinations of a Phone Number": "class Solution {\npublic:\n    vector<string> letterCombinations(string digits) {\n        if (digits.empty()) {\n            return {};\n        }\n        vector<string> d = {\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\n        vector<string> ans = {\"\"};\n        for (auto& i : digits) {\n            string s = d[i - '2'];\n            vector<string> t;\n            for (auto& a : ans) {\n                for (auto& b : s) {\n                    t.push_back(a + b);\n                }\n            }\n            ans = move(t);\n        }\n        return ans;\n    }\n};",
    "18. 4Sum": "class Solution {\npublic:\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\n        int n = nums.size();\n        vector<vector<int>> ans;\n        if (n < 4) {\n            return ans;\n        }\n        sort(nums.begin(), nums.end());\n        for (int i = 0; i < n - 3; ++i) {\n            if (i && nums[i] == nums[i - 1]) {\n                continue;\n            }\n            for (int j = i + 1; j < n - 2; ++j) {\n                if (j > i + 1 && nums[j] == nums[j - 1]) {\n                    continue;\n                }\n                int k = j + 1, l = n - 1;\n                while (k < l) {\n                    long long x = (long long) nums[i] + nums[j] + nums[k] + nums[l];\n                    if (x < target) {\n                        ++k;\n                    } else if (x > target) {\n                        --l;\n                    } else {\n                        ans.push_back({nums[i], nums[j], nums[k++], nums[l--]});\n                        while (k < l && nums[k] == nums[k - 1]) {\n                            ++k;\n                        }\n                        while (k < l && nums[l] == nums[l + 1]) {\n                            --l;\n                        }\n                    }\n                }\n            }\n        }\n        return ans;\n    }\n};",
    "19. Remove Nth Node From End of List": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\n        ListNode* dummy = new ListNode(0, head);\n        ListNode* fast = dummy;\n        ListNode* slow = dummy;\n        while (n--) {\n            fast = fast->next;\n        }\n        while (fast->next) {\n            slow = slow->next;\n            fast = fast->next;\n        }\n        slow->next = slow->next->next;\n        return dummy->next;\n    }\n};",
    "20. Valid Parentheses": "class Solution {\npublic:\n    bool isValid(string s) {\n        string stk;\n        for (char c : s) {\n            if (c == '(' || c == '{' || c == '[')\n                stk.push_back(c);\n            else if (stk.empty() || !match(stk.back(), c))\n                return false;\n            else\n                stk.pop_back();\n        }\n        return stk.empty();\n    }\n\n    bool match(char l, char r) {\n        return (l == '(' && r == ')') || (l == '[' && r == ']') || (l == '{' && r == '}');\n    }\n};",
    "21. Merge Two Sorted Lists": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {\n        ListNode* dummy = new ListNode();\n        ListNode* curr = dummy;\n        while (list1 && list2) {\n            if (list1->val <= list2->val) {\n                curr->next = list1;\n                list1 = list1->next;\n            } else {\n                curr->next = list2;\n                list2 = list2->next;\n            }\n            curr = curr->next;\n        }\n        curr->next = list1 ? list1 : list2;\n        return dummy->next;\n    }\n};",
    "22. Generate Parentheses": "class Solution {\npublic:\n    vector<string> generateParenthesis(int n) {\n        vector<string> ans;\n        function<void(int, int, string)> dfs = [&](int l, int r, string t) {\n            if (l > n || r > n || l < r) return;\n            if (l == n && r == n) {\n                ans.push_back(t);\n                return;\n            }\n            dfs(l + 1, r, t + \"(\");\n            dfs(l, r + 1, t + \")\");\n        };\n        dfs(0, 0, \"\");\n        return ans;\n    }\n};",
    "23. Merge k Sorted Lists": "// OJ: https://leetcode.com/problems/merge-k-sorted-lists/\n// Time: O(NlogK)\n// Space: O(K)\nclass Solution {\npublic:\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\n        ListNode dummy, *tail = &dummy;\n        auto cmp = [](auto a, auto b) { return a->val > b->val; };\n        priority_queue<ListNode*, vector<ListNode*>, decltype(cmp)> q(cmp);\n        for (auto list : lists) {\n            if (list) q.push(list); // avoid pushing NULL list.\n        }\n        while (q.size()) {\n            auto node = q.top();\n            q.pop();\n            if (node->next) q.push(node->next);\n            tail->next = node;\n            tail = node;\n        }\n        return dummy.next;\n    }\n};",
    "24. Swap Nodes in Pairs": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        ListNode* dummy = new ListNode(0, head);\n        ListNode* pre = dummy;\n        ListNode* cur = head;\n        while (cur && cur->next) {\n            ListNode* t = cur->next;\n            cur->next = t->next;\n            t->next = cur;\n            pre->next = t;\n            pre = cur;\n            cur = cur->next;\n        }\n        return dummy->next;\n    }\n};",
    "25. Reverse Nodes in k-Group": "// OJ: https://leetcode.com/problems/reverse-nodes-in-k-group/\n// Time: O(N)\n// Space: O(1)\nclass Solution {\npublic:\n    ListNode* reverseKGroup(ListNode* head, int k) {\n        ListNode h, *tail = &h;\n        while (head) {\n            auto prev = tail;\n            int i = 0;\n            for (auto p = head; i < k && p; ++i, p = p->next);\n            if (i < k) {\n                tail->next = head;\n                break;\n            }\n            for (int i = 0; i < k && head; ++i) {\n                auto node = head;\n                head = head->next;\n                node->next = prev->next;\n                prev->next = node;\n            }\n            while (tail->next) tail = tail->next;\n        }\n        return h.next;\n    }\n};",
    "26. Remove Duplicates from Sorted Array": "class Solution {\npublic:\n    int removeDuplicates(vector<int>& nums) {\n        nums.erase(unique(nums.begin(), nums.end()), nums.end());\n        return nums.size();\n    }\n};",
    "27. Remove Element": "class Solution {\npublic:\n    int removeElement(vector<int>& nums, int val) {\n        int k = 0;\n        for (int x : nums) {\n            if (x != val) {\n                nums[k++] = x;\n            }\n        }\n        return k;\n    }\n};",
    "29. Divide Two Integers": "class Solution {\npublic:\n    int divide(int a, int b) {\n        if (b == 1) {\n            return a;\n        }\n        if (a == INT_MIN && b == -1) {\n            return INT_MAX;\n        }\n        bool sign = (a > 0 && b > 0) || (a < 0 && b < 0);\n        a = a > 0 ? -a : a;\n        b = b > 0 ? -b : b;\n        int ans = 0;\n        while (a <= b) {\n            int x = b;\n            int cnt = 1;\n            while (x >= (INT_MIN >> 1) && a <= (x << 1)) {\n                x <<= 1;\n                cnt <<= 1;\n            }\n            ans += cnt;\n            a -= x;\n        }\n        return sign ? ans : -ans;\n    }\n};",
    "30. Substring with Concatenation of All Words": "class Solution {\npublic:\n    vector<int> findSubstring(string s, vector<string>& words) {\n        unordered_map<string, int> cnt;\n        for (auto& w : words) {\n            ++cnt[w];\n        }\n        int m = s.size(), n = words.size(), k = words[0].size();\n        vector<int> ans;\n        for (int i = 0; i < k; ++i) {\n            unordered_map<string, int> cnt1;\n            int l = i, r = i;\n            int t = 0;\n            while (r + k <= m) {\n                string w = s.substr(r, k);\n                r += k;\n                if (!cnt.count(w)) {\n                    cnt1.clear();\n                    l = r;\n                    t = 0;\n                    continue;\n                }\n                ++cnt1[w];\n                ++t;\n                while (cnt1[w] > cnt[w]) {\n                    string remove = s.substr(l, k);\n                    l += k;\n                    --cnt1[remove];\n                    --t;\n                }\n                if (t == n) {\n                    ans.push_back(l);\n                }\n            }\n        }\n        return ans;\n    }\n};",
    "31. Next Permutation": "class Solution {\npublic:\n    void nextPermutation(vector<int>& nums) {\n        int n = nums.size();\n        int i = n - 2;\n        while (~i && nums[i] >= nums[i + 1]) {\n            --i;\n        }\n        if (~i) {\n            for (int j = n - 1; j > i; --j) {\n                if (nums[j] > nums[i]) {\n                    swap(nums[i], nums[j]);\n                    break;\n                }\n            }\n        }\n        reverse(nums.begin() + i + 1, nums.end());\n    }\n};",
    "32. Longest Valid Parentheses": "class Solution {\npublic:\n    int longestValidParentheses(string s) {\n        int n = s.size();\n        int f[n + 1];\n        memset(f, 0, sizeof(f));\n        for (int i = 2; i <= n; ++i) {\n            if (s[i - 1] == ')') {\n                if (s[i - 2] == '(') {\n                    f[i] = f[i - 2] + 2;\n                } else {\n                    int j = i - f[i - 1] - 1;\n                    if (j && s[j - 1] == '(') {\n                        f[i] = f[i - 1] + 2 + f[j - 1];\n                    }\n                }\n            }\n        }\n        return *max_element(f, f + n + 1);\n    }\n};",
    "33. Search in Rotated Sorted Array": "class Solution {\npublic:\n    int search(vector<int>& nums, int target) {\n        int n = nums.size();\n        int left = 0, right = n - 1;\n        while (left < right) {\n            int mid = (left + right) >> 1;\n            if (nums[0] <= nums[mid]) {\n                if (nums[0] <= target && target <= nums[mid])\n                    right = mid;\n                else\n                    left = mid + 1;\n            } else {\n                if (nums[mid] < target && target <= nums[n - 1])\n                    left = mid + 1;\n                else\n                    right = mid;\n            }\n        }\n        return nums[left] == target ? left : -1;\n    }\n};",
    "35. Search Insert Position": "class Solution {\npublic:\n    int searchInsert(vector<int>& nums, int target) {\n        int left = 0, right = nums.size();\n        while (left < right) {\n            int mid = left + right >> 1;\n            if (nums[mid] >= target)\n                right = mid;\n            else\n                left = mid + 1;\n        }\n        return left;\n    }\n};",
    "36. Valid Sudoku": "class Solution {\npublic:\n    bool isValidSudoku(vector<vector<char>>& board) {\n        vector<vector<bool>> row(9, vector<bool>(9, false));\n        vector<vector<bool>> col(9, vector<bool>(9, false));\n        vector<vector<bool>> sub(9, vector<bool>(9, false));\n        for (int i = 0; i < 9; ++i) {\n            for (int j = 0; j < 9; ++j) {\n                char c = board[i][j];\n                if (c == '.') continue;\n                int num = c - '0' - 1;\n                int k = i / 3 * 3 + j / 3;\n                if (row[i][num] || col[j][num] || sub[k][num]) {\n                    return false;\n                }\n                row[i][num] = true;\n                col[j][num] = true;\n                sub[k][num] = true;\n            }\n        }\n        return true;\n    }\n};",
    "37. Sudoku Solver": "using pii = pair<int, int>;\n\nclass Solution {\npublic:\n    void solveSudoku(vector<vector<char>>& board) {\n        bool row[9][9] = {false};\n        bool col[9][9] = {false};\n        bool block[3][3][9] = {false};\n        bool ok = false;\n        vector<pii> t;\n        for (int i = 0; i < 9; ++i) {\n            for (int j = 0; j < 9; ++j) {\n                if (board[i][j] == '.') {\n                    t.push_back({i, j});\n                } else {\n                    int v = board[i][j] - '1';\n                    row[i][v] = col[j][v] = block[i / 3][j / 3][v] = true;\n                }\n            }\n        }\n        function<void(int k)> dfs = [&](int k) {\n            if (k == t.size()) {\n                ok = true;\n                return;\n            }\n            int i = t[k].first, j = t[k].second;\n            for (int v = 0; v < 9; ++v) {\n                if (!row[i][v] && !col[j][v] && !block[i / 3][j / 3][v]) {\n                    row[i][v] = col[j][v] = block[i / 3][j / 3][v] = true;\n                    board[i][j] = v + '1';\n                    dfs(k + 1);\n                    row[i][v] = col[j][v] = block[i / 3][j / 3][v] = false;\n                }\n                if (ok) {\n                    return;\n                }\n            }\n        };\n        dfs(0);\n    }\n};",
    "38. Count and Say": "class Solution {\npublic:\n    string countAndSay(int n) {\n        string s = \"1\";\n        while (--n) {\n            string t = \"\";\n            for (int i = 0; i < s.size();) {\n                int j = i;\n                while (j < s.size() && s[j] == s[i]) ++j;\n                t += to_string(j - i);\n                t += s[i];\n                i = j;\n            }\n            s = t;\n        }\n        return s;\n    }\n};",
    "39. Combination Sum": "class Solution {\npublic:\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\n        sort(candidates.begin(), candidates.end());\n        vector<vector<int>> ans;\n        vector<int> t;\n        function<void(int, int)> dfs = [&](int i, int s) {\n            if (s == 0) {\n                ans.emplace_back(t);\n                return;\n            }\n            if (i >= candidates.size() || s < candidates[i]) {\n                return;\n            }\n            dfs(i + 1, s);\n            t.push_back(candidates[i]);\n            dfs(i, s - candidates[i]);\n            t.pop_back();\n        };\n        dfs(0, target);\n        return ans;\n    }\n};",
    "40. Combination Sum II": "class Solution {\npublic:\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\n        sort(candidates.begin(), candidates.end());\n        vector<vector<int>> ans;\n        vector<int> t;\n        function<void(int, int)> dfs = [&](int i, int s) {\n            if (s == 0) {\n                ans.emplace_back(t);\n                return;\n            }\n            if (i >= candidates.size() || s < candidates[i]) {\n                return;\n            }\n            for (int j = i; j < candidates.size(); ++j) {\n                if (j > i && candidates[j] == candidates[j - 1]) {\n                    continue;\n                }\n                t.emplace_back(candidates[j]);\n                dfs(j + 1, s - candidates[j]);\n                t.pop_back();\n            }\n        };\n        dfs(0, target);\n        return ans;\n    }\n};",
    "41. First Missing Positive": "class Solution {\npublic:\n    int firstMissingPositive(vector<int>& nums) {\n        int n = nums.size();\n        for (int i = 0; i < n; ++i) {\n            while (nums[i] >= 1 && nums[i] <= n && nums[i] != nums[nums[i] - 1]) {\n                swap(nums[i], nums[nums[i] - 1]);\n            }\n        }\n        for (int i = 0; i < n; ++i) {\n            if (i + 1 != nums[i]) {\n                return i + 1;\n            }\n        }\n        return n + 1;\n    }\n};",
    "42. Trapping Rain Water": "// OJ: https://leetcode.com/problems/trapping-rain-water/\n// Time: O(N)\n// Space: O(N)\nclass Solution {\npublic:\n    int trap(vector<int>& A) {\n        int N = A.size(), ans = 0;\n        vector<int> left(N, 0), right(N, 0);\n        for (int i = 1; i < N; ++i) left[i] = max(left[i - 1], A[i - 1]);\n        for (int i = N - 2; i >= 0; --i) right[i] = max(right[i + 1], A[i + 1]);\n        for (int i = 1; i < N - 1; ++i) ans += max(0, min(left[i], right[i]) - A[i]);\n        return ans;\n    }\n};",
    "43. Multiply Strings": "class Solution {\npublic:\n    string multiply(string num1, string num2) {\n        if (num1 == \"0\" || num2 == \"0\") {\n            return \"0\";\n        }\n        int m = num1.size(), n = num2.size();\n        vector<int> arr(m + n);\n        for (int i = m - 1; i >= 0; --i) {\n            int a = num1[i] - '0';\n            for (int j = n - 1; j >= 0; --j) {\n                int b = num2[j] - '0';\n                arr[i + j + 1] += a * b;\n            }\n        }\n        for (int i = arr.size() - 1; i; --i) {\n            arr[i - 1] += arr[i] / 10;\n            arr[i] %= 10;\n        }\n        int i = arr[0] ? 0 : 1;\n        string ans;\n        for (; i < arr.size(); ++i) {\n            ans += '0' + arr[i];\n        }\n        return ans;\n    }\n};",
    "44. Wildcard Matching": "class Solution {\npublic:\n    bool isMatch(string s, string p) {\n        int m = s.size(), n = p.size();\n        vector<vector<bool>> dp(m + 1, vector<bool>(n + 1));\n        dp[0][0] = true;\n        for (int j = 1; j <= n; ++j) {\n            if (p[j - 1] == '*') {\n                dp[0][j] = dp[0][j - 1];\n            }\n        }\n        for (int i = 1; i <= m; ++i) {\n            for (int j = 1; j <= n; ++j) {\n                if (s[i - 1] == p[j - 1] || p[j - 1] == '?') {\n                    dp[i][j] = dp[i - 1][j - 1];\n                } else if (p[j - 1] == '*') {\n                    dp[i][j] = dp[i - 1][j] || dp[i][j - 1];\n                }\n            }\n        }\n        return dp[m][n];\n    }\n};",
    "45. Jump Game II": "class Solution {\npublic:\n    int jump(vector<int>& nums) {\n        int ans = 0, mx = 0, last = 0;\n        for (int i = 0; i < nums.size() - 1; ++i) {\n            mx = max(mx, i + nums[i]);\n            if (last == i) {\n                ++ans;\n                last = mx;\n            }\n        }\n        return ans;\n    }\n};",
    "46. Permutations": "class Solution {\npublic:\n    vector<vector<int>> permute(vector<int>& nums) {\n        int n = nums.size();\n        vector<vector<int>> ans;\n        vector<int> t(n);\n        vector<bool> vis(n);\n        function<void(int)> dfs = [&](int i) {\n            if (i == n) {\n                ans.emplace_back(t);\n                return;\n            }\n            for (int j = 0; j < n; ++j) {\n                if (!vis[j]) {\n                    vis[j] = true;\n                    t[i] = nums[j];\n                    dfs(i + 1);\n                    vis[j] = false;\n                }\n            }\n        };\n        dfs(0);\n        return ans;\n    }\n};",
    "47. Permutations II": "class Solution {\npublic:\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\n        sort(nums.begin(), nums.end());\n        int n = nums.size();\n        vector<vector<int>> ans;\n        vector<int> t(n);\n        vector<bool> vis(n);\n        function<void(int)> dfs = [&](int i) {\n            if (i == n) {\n                ans.emplace_back(t);\n                return;\n            }\n            for (int j = 0; j < n; ++j) {\n                if (vis[j] || (j && nums[j] == nums[j - 1] && !vis[j - 1])) {\n                    continue;\n                }\n                t[i] = nums[j];\n                vis[j] = true;\n                dfs(i + 1);\n                vis[j] = false;\n            }\n        };\n        dfs(0);\n        return ans;\n    }\n};",
    "48. Rotate Image": "// OJ: https://leetcode.com/problems/rotate-image/\n// Time: O(N^2)\n// Space: O(1)\nclass Solution {\npublic:\n    void rotate(vector<vector<int>>& A) {\n        int N = A.size();\n        for (int i = 0; i < N / 2; ++i) {\n            for (int j = i; j < N - i - 1; ++j) {\n                int tmp = A[i][j];\n                A[i][j] = A[N - j - 1][i];\n                A[N - j - 1][i] = A[N - i - 1][N - j - 1];\n                A[N - i - 1][N - j - 1] = A[j][N - i - 1];\n                A[j][N - i - 1] = tmp;\n            }\n        }\n    }\n};",
    "49. Group Anagrams": "class Solution {\npublic:\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\n        unordered_map<string, vector<string>> d;\n        for (auto& s : strs) {\n            string k = s;\n            sort(k.begin(), k.end());\n            d[k].emplace_back(s);\n        }\n        vector<vector<string>> ans;\n        for (auto& [_, v] : d) ans.emplace_back(v);\n        return ans;\n    }\n};",
    "50. Pow(x, n)": "class Solution {\npublic:\n    double myPow(double x, int n) {\n        auto qpow = [](double a, long long n) {\n            double ans = 1;\n            for (; n; n >>= 1) {\n                if (n & 1) {\n                    ans *= a;\n                }\n                a *= a;\n            }\n            return ans;\n        };\n        return n >= 0 ? qpow(x, n) : 1 / qpow(x, -(long long) n);\n    }\n};",
    "51. N-Queens": "class Solution {\npublic:\n    vector<vector<string>> solveNQueens(int n) {\n        vector<int> col(n);\n        vector<int> dg(n << 1);\n        vector<int> udg(n << 1);\n        vector<vector<string>> ans;\n        vector<string> t(n, string(n, '.'));\n        function<void(int)> dfs = [&](int i) -> void {\n            if (i == n) {\n                ans.push_back(t);\n                return;\n            }\n            for (int j = 0; j < n; ++j) {\n                if (col[j] + dg[i + j] + udg[n - i + j] == 0) {\n                    t[i][j] = 'Q';\n                    col[j] = dg[i + j] = udg[n - i + j] = 1;\n                    dfs(i + 1);\n                    col[j] = dg[i + j] = udg[n - i + j] = 0;\n                    t[i][j] = '.';\n                }\n            }\n        };\n        dfs(0);\n        return ans;\n    }\n};",
    "52. N-Queens II": "class Solution {\npublic:\n    int totalNQueens(int n) {\n        bitset<10> cols;\n        bitset<20> dg;\n        bitset<20> udg;\n        int ans = 0;\n        function<void(int)> dfs = [&](int i) {\n            if (i == n) {\n                ++ans;\n                return;\n            }\n            for (int j = 0; j < n; ++j) {\n                int a = i + j, b = i - j + n;\n                if (cols[j] || dg[a] || udg[b]) continue;\n                cols[j] = dg[a] = udg[b] = 1;\n                dfs(i + 1);\n                cols[j] = dg[a] = udg[b] = 0;\n            }\n        };\n        dfs(0);\n        return ans;\n    }\n};",
    "53. Maximum Subarray": "class Solution {\npublic:\n    int maxSubArray(vector<int>& nums) {\n        int ans = nums[0], f = nums[0];\n        for (int i = 1; i < nums.size(); ++i) {\n            f = max(f, 0) + nums[i];\n            ans = max(ans, f);\n        }\n        return ans;\n    }\n};",
    "54. Spiral Matrix": "class Solution {\npublic:\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\n        int m = matrix.size(), n = matrix[0].size();\n        int dirs[5] = {0, 1, 0, -1, 0};\n        int i = 0, j = 0, k = 0;\n        vector<int> ans;\n        bool vis[m][n];\n        memset(vis, false, sizeof(vis));\n        for (int h = m * n; h; --h) {\n            ans.push_back(matrix[i][j]);\n            vis[i][j] = true;\n            int x = i + dirs[k], y = j + dirs[k + 1];\n            if (x < 0 || x >= m || y < 0 || y >= n || vis[x][y]) {\n                k = (k + 1) % 4;\n            }\n            i += dirs[k];\n            j += dirs[k + 1];\n        }\n        return ans;\n    }\n};",
    "55. Jump Game": "class Solution {\npublic:\n    bool canJump(vector<int>& nums) {\n        int mx = 0;\n        for (int i = 0; i < nums.size(); ++i) {\n            if (mx < i) {\n                return false;\n            }\n            mx = max(mx, i + nums[i]);\n        }\n        return true;\n    }\n};",
    "56. Merge Intervals": "class Solution {\npublic:\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\n        sort(intervals.begin(), intervals.end());\n        vector<vector<int>> ans;\n        ans.emplace_back(intervals[0]);\n        for (int i = 1; i < intervals.size(); ++i) {\n            if (ans.back()[1] < intervals[i][0]) {\n                ans.emplace_back(intervals[i]);\n            } else {\n                ans.back()[1] = max(ans.back()[1], intervals[i][1]);\n            }\n        }\n        return ans;\n    }\n};",
    "57. Insert Interval": "class Solution {\npublic:\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\n        intervals.emplace_back(newInterval);\n        return merge(intervals);\n    }\n\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\n        sort(intervals.begin(), intervals.end());\n        vector<vector<int>> ans;\n        ans.emplace_back(intervals[0]);\n        for (int i = 1; i < intervals.size(); ++i) {\n            if (ans.back()[1] < intervals[i][0]) {\n                ans.emplace_back(intervals[i]);\n            } else {\n                ans.back()[1] = max(ans.back()[1], intervals[i][1]);\n            }\n        }\n        return ans;\n    }\n};",
    "58. Length of Last Word": "class Solution {\npublic:\n    int lengthOfLastWord(string s) {\n        int i = s.size() - 1;\n        while (~i && s[i] == ' ') {\n            --i;\n        }\n        int j = i;\n        while (~j && s[j] != ' ') {\n            --j;\n        }\n        return i - j;\n    }\n};",
    "59. Spiral Matrix II": "class Solution {\npublic:\n    const int dirs[4][2] = { {0, 1}, {1, 0}, {0, -1}, {-1, 0} };\n\n    vector<vector<int>> generateMatrix(int n) {\n        vector<vector<int>> ans(n, vector<int>(n));\n        int i = 0, j = 0, k = 0;\n        for (int v = 1; v <= n * n; ++v) {\n            ans[i][j] = v;\n            int x = i + dirs[k][0], y = j + dirs[k][1];\n            if (x < 0 || y < 0 || x >= n || y >= n || ans[x][y]) {\n                k = (k + 1) % 4;\n                x = i + dirs[k][0], y = j + dirs[k][1];\n            }\n            i = x, j = y;\n        }\n        return ans;\n    }\n};",
    "60. Permutation Sequence": "class Solution {\npublic:\n    string getPermutation(int n, int k) {\n        string ans;\n        bitset<10> vis;\n        for (int i = 0; i < n; ++i) {\n            int fact = 1;\n            for (int j = 1; j < n - i; ++j) fact *= j;\n            for (int j = 1; j <= n; ++j) {\n                if (vis[j]) continue;\n                if (k > fact)\n                    k -= fact;\n                else {\n                    ans += to_string(j);\n                    vis[j] = 1;\n                    break;\n                }\n            }\n        }\n        return ans;\n    }\n};",
    "61. Rotate List": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* rotateRight(ListNode* head, int k) {\n        if (!head || !head->next) {\n            return head;\n        }\n        ListNode* cur = head;\n        int n = 0;\n        while (cur) {\n            ++n;\n            cur = cur->next;\n        }\n        k %= n;\n        if (k == 0) {\n            return head;\n        }\n        ListNode* fast = head;\n        ListNode* slow = head;\n        while (k--) {\n            fast = fast->next;\n        }\n        while (fast->next) {\n            fast = fast->next;\n            slow = slow->next;\n        }\n        ListNode* ans = slow->next;\n        slow->next = nullptr;\n        fast->next = head;\n        return ans;\n    }\n};",
    "62. Unique Paths": "class Solution {\npublic:\n    int uniquePaths(int m, int n) {\n        vector<int> f(n, 1);\n        for (int i = 1; i < m; ++i) {\n            for (int j = 1; j < n; ++j) {\n                f[j] += f[j - 1];\n            }\n        }\n        return f[n - 1];\n    }\n};",
    "63. Unique Paths II": "class Solution {\npublic:\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\n        int m = obstacleGrid.size(), n = obstacleGrid[0].size();\n        vector<vector<int>> dp(m, vector<int>(n));\n        for (int i = 0; i < m && obstacleGrid[i][0] == 0; ++i) {\n            dp[i][0] = 1;\n        }\n        for (int j = 0; j < n && obstacleGrid[0][j] == 0; ++j) {\n            dp[0][j] = 1;\n        }\n        for (int i = 1; i < m; ++i) {\n            for (int j = 1; j < n; ++j) {\n                if (obstacleGrid[i][j] == 0) {\n                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n                }\n            }\n        }\n        return dp[m - 1][n - 1];\n    }\n};",
    "64. Minimum Path Sum": "class Solution {\npublic:\n    int minPathSum(vector<vector<int>>& grid) {\n        int m = grid.size(), n = grid[0].size();\n        int f[m][n];\n        f[0][0] = grid[0][0];\n        for (int i = 1; i < m; ++i) {\n            f[i][0] = f[i - 1][0] + grid[i][0];\n        }\n        for (int j = 1; j < n; ++j) {\n            f[0][j] = f[0][j - 1] + grid[0][j];\n        }\n        for (int i = 1; i < m; ++i) {\n            for (int j = 1; j < n; ++j) {\n                f[i][j] = min(f[i - 1][j], f[i][j - 1]) + grid[i][j];\n            }\n        }\n        return f[m - 1][n - 1];\n    }\n};",
    "65. Valid Number": "class Solution {\npublic:\n    bool isNumber(string s) {\n        int n = s.size();\n        int i = 0;\n        if (s[i] == '+' || s[i] == '-') ++i;\n        if (i == n) return false;\n        if (s[i] == '.' && (i + 1 == n || s[i + 1] == 'e' || s[i + 1] == 'E')) return false;\n        int dot = 0, e = 0;\n        for (int j = i; j < n; ++j) {\n            if (s[j] == '.') {\n                if (e || dot) return false;\n                ++dot;\n            } else if (s[j] == 'e' || s[j] == 'E') {\n                if (e || j == i || j == n - 1) return false;\n                ++e;\n                if (s[j + 1] == '+' || s[j + 1] == '-') {\n                    if (++j == n - 1) return false;\n                }\n            } else if (s[j] < '0' || s[j] > '9')\n                return false;\n        }\n        return true;\n    }\n};",
    "66. Plus One": "class Solution {\npublic:\n    vector<int> plusOne(vector<int>& digits) {\n        for (int i = digits.size() - 1; i >= 0; --i) {\n            ++digits[i];\n            digits[i] %= 10;\n            if (digits[i] != 0) return digits;\n        }\n        digits.insert(digits.begin(), 1);\n        return digits;\n    }\n};",
    "67. Add Binary": "class Solution {\npublic:\n    string addBinary(string a, string b) {\n        string ans;\n        int i = a.size() - 1, j = b.size() - 1;\n        for (int carry = 0; i >= 0 || j >= 0 || carry; --i, --j) {\n            carry += (i >= 0 ? a[i] - '0' : 0) + (j >= 0 ? b[j] - '0' : 0);\n            ans.push_back((carry % 2) + '0');\n            carry /= 2;\n        }\n        reverse(ans.begin(), ans.end());\n        return ans;\n    }\n};",
    "68. Text Justification": "class Solution {\npublic:\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\n        vector<string> ans;\n        for (int i = 0, n = words.size(); i < n;) {\n            vector<string> t = {words[i]};\n            int cnt = words[i].size();\n            ++i;\n            while (i < n && cnt + 1 + words[i].size() <= maxWidth) {\n                cnt += 1 + words[i].size();\n                t.emplace_back(words[i++]);\n            }\n            if (i == n || t.size() == 1) {\n                string left = t[0];\n                for (int j = 1; j < t.size(); ++j) {\n                    left += \" \" + t[j];\n                }\n                string right = string(maxWidth - left.size(), ' ');\n                ans.emplace_back(left + right);\n                continue;\n            }\n            int spaceWidth = maxWidth - (cnt - t.size() + 1);\n            int w = spaceWidth / (t.size() - 1);\n            int m = spaceWidth % (t.size() - 1);\n            string row;\n            for (int j = 0; j < t.size() - 1; ++j) {\n                row += t[j] + string(w + (j < m ? 1 : 0), ' ');\n            }\n            row += t.back();\n            ans.emplace_back(row);\n        }\n        return ans;\n    }\n};",
    "70. Climbing Stairs": "class Solution {\npublic:\n    int climbStairs(int n) {\n        int a = 0, b = 1;\n        for (int i = 0; i < n; ++i) {\n            int c = a + b;\n            a = b;\n            b = c;\n        }\n        return b;\n    }\n};",
    "71. Simplify Path": "class Solution {\npublic:\n    string simplifyPath(string path) {\n        deque<string> stk;\n        stringstream ss(path);\n        string t;\n        while (getline(ss, t, '/')) {\n            if (t == \"\" || t == \".\") {\n                continue;\n            }\n            if (t == \"..\") {\n                if (!stk.empty()) {\n                    stk.pop_back();\n                }\n            } else {\n                stk.push_back(t);\n            }\n        }\n        if (stk.empty()) {\n            return \"/\";\n        }\n        string ans;\n        for (auto& s : stk) {\n            ans += \"/\" + s;\n        }\n        return ans;\n    }\n};",
    "72. Edit Distance": "class Solution {\npublic:\n    int minDistance(string word1, string word2) {\n        int m = word1.size(), n = word2.size();\n        int f[m + 1][n + 1];\n        for (int j = 0; j <= n; ++j) {\n            f[0][j] = j;\n        }\n        for (int i = 1; i <= m; ++i) {\n            f[i][0] = i;\n            for (int j = 1; j <= n; ++j) {\n                if (word1[i - 1] == word2[j - 1]) {\n                    f[i][j] = f[i - 1][j - 1];\n                } else {\n                    f[i][j] = min({f[i - 1][j], f[i][j - 1], f[i - 1][j - 1]}) + 1;\n                }\n            }\n        }\n        return f[m][n];\n    }\n};",
    "73. Set Matrix Zeroes": "class Solution {\npublic:\n    void setZeroes(vector<vector<int>>& matrix) {\n        int m = matrix.size(), n = matrix[0].size();\n        bool i0 = false, j0 = false;\n        for (int j = 0; j < n; ++j) {\n            if (matrix[0][j] == 0) {\n                i0 = true;\n                break;\n            }\n        }\n        for (int i = 0; i < m; ++i) {\n            if (matrix[i][0] == 0) {\n                j0 = true;\n                break;\n            }\n        }\n        for (int i = 1; i < m; ++i) {\n            for (int j = 1; j < n; ++j) {\n                if (matrix[i][j] == 0) {\n                    matrix[i][0] = 0;\n                    matrix[0][j] = 0;\n                }\n            }\n        }\n        for (int i = 1; i < m; ++i) {\n            for (int j = 1; j < n; ++j) {\n                if (matrix[i][0] == 0 || matrix[0][j] == 0) {\n                    matrix[i][j] = 0;\n                }\n            }\n        }\n        if (i0) {\n            for (int j = 0; j < n; ++j) {\n                matrix[0][j] = 0;\n            }\n        }\n        if (j0) {\n            for (int i = 0; i < m; ++i) {\n                matrix[i][0] = 0;\n            }\n        }\n    }\n};",
    "74. Search a 2D Matrix": "class Solution {\npublic:\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\n        int m = matrix.size(), n = matrix[0].size();\n        int left = 0, right = m * n - 1;\n        while (left < right) {\n            int mid = left + right >> 1;\n            int x = mid / n, y = mid % n;\n            if (matrix[x][y] >= target) {\n                right = mid;\n            } else {\n                left = mid + 1;\n            }\n        }\n        return matrix[left / n][left % n] == target;\n    }\n};",
    "75. Sort Colors": "class Solution {\npublic:\n    void sortColors(vector<int>& nums) {\n        int i = -1, j = nums.size(), k = 0;\n        while (k < j) {\n            if (nums[k] == 0) {\n                swap(nums[++i], nums[k++]);\n            } else if (nums[k] == 2) {\n                swap(nums[--j], nums[k]);\n            } else {\n                ++k;\n            }\n        }\n    }\n};",
    "76. Minimum Window Substring": "class Solution {\npublic:\n    string minWindow(string s, string t) {\n        int need[128]{};\n        int window[128]{};\n        int m = s.size(), n = t.size();\n        for (char& c : t) {\n            ++need[c];\n        }\n        int cnt = 0, j = 0, k = -1, mi = 1 << 30;\n        for (int i = 0; i < m; ++i) {\n            ++window[s[i]];\n            if (need[s[i]] >= window[s[i]]) {\n                ++cnt;\n            }\n            while (cnt == n) {\n                if (i - j + 1 < mi) {\n                    mi = i - j + 1;\n                    k = j;\n                }\n                if (need[s[j]] >= window[s[j]]) {\n                    --cnt;\n                }\n                --window[s[j++]];\n            }\n        }\n        return k < 0 ? \"\" : s.substr(k, mi);\n    }\n};",
    "77. Combinations": "class Solution {\npublic:\n    vector<vector<int>> combine(int n, int k) {\n        vector<vector<int>> ans;\n        vector<int> t;\n        function<void(int)> dfs = [&](int i) {\n            if (t.size() == k) {\n                ans.emplace_back(t);\n                return;\n            }\n            if (i > n) {\n                return;\n            }\n            t.emplace_back(i);\n            dfs(i + 1);\n            t.pop_back();\n            dfs(i + 1);\n        };\n        dfs(1);\n        return ans;\n    }\n};",
    "78. Subsets": "class Solution {\npublic:\n    vector<vector<int>> subsets(vector<int>& nums) {\n        vector<vector<int>> ans;\n        vector<int> t;\n        function<void(int)> dfs = [&](int i) -> void {\n            if (i == nums.size()) {\n                ans.push_back(t);\n                return;\n            }\n            dfs(i + 1);\n            t.push_back(nums[i]);\n            dfs(i + 1);\n            t.pop_back();\n        };\n        dfs(0);\n        return ans;\n    }\n};",
    "79. Word Search": "class Solution {\npublic:\n    bool exist(vector<vector<char>>& board, string word) {\n        int m = board.size(), n = board[0].size();\n        int dirs[5] = {-1, 0, 1, 0, -1};\n        function<bool(int, int, int)> dfs = [&](int i, int j, int k) -> bool {\n            if (k == word.size() - 1) {\n                return board[i][j] == word[k];\n            }\n            if (board[i][j] != word[k]) {\n                return false;\n            }\n            char c = board[i][j];\n            board[i][j] = '0';\n            for (int u = 0; u < 4; ++u) {\n                int x = i + dirs[u], y = j + dirs[u + 1];\n                if (x >= 0 && x < m && y >= 0 && y < n && board[x][y] != '0' && dfs(x, y, k + 1)) {\n                    return true;\n                }\n            }\n            board[i][j] = c;\n            return false;\n        };\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (dfs(i, j, 0)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n};",
    "80. Remove Duplicates from Sorted Array II": "class Solution {\npublic:\n    int removeDuplicates(vector<int>& nums) {\n        int k = 0;\n        for (int x : nums) {\n            if (k < 2 || x != nums[k - 2]) {\n                nums[k++] = x;\n            }\n        }\n        return k;\n    }\n};",
    "81. Search in Rotated Sorted Array II": "class Solution {\npublic:\n    bool search(vector<int>& nums, int target) {\n        int l = 0, r = nums.size() - 1;\n        while (l < r) {\n            int mid = (l + r) >> 1;\n            if (nums[mid] > nums[r]) {\n                if (nums[l] <= target && target <= nums[mid]) {\n                    r = mid;\n                } else {\n                    l = mid + 1;\n                }\n            } else if (nums[mid] < nums[r]) {\n                if (nums[mid] < target && target <= nums[r]) {\n                    l = mid + 1;\n                } else {\n                    r = mid;\n                }\n            } else {\n                --r;\n            }\n        }\n        return nums[l] == target;\n    }\n};",
    "82. Remove Duplicates from Sorted List II": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* deleteDuplicates(ListNode* head) {\n        ListNode* dummy = new ListNode(0, head);\n        ListNode* pre = dummy;\n        ListNode* cur = head;\n        while (cur) {\n            while (cur->next && cur->next->val == cur->val) {\n                cur = cur->next;\n            }\n            if (pre->next == cur) {\n                pre = cur;\n            } else {\n                pre->next = cur->next;\n            }\n            cur = cur->next;\n        }\n        return dummy->next;\n    }\n};",
    "83. Remove Duplicates from Sorted List": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* deleteDuplicates(ListNode* head) {\n        ListNode* cur = head;\n        while (cur != nullptr && cur->next != nullptr) {\n            if (cur->val == cur->next->val) {\n                cur->next = cur->next->next;\n            } else {\n                cur = cur->next;\n            }\n        }\n        return head;\n    }\n};",
    "84. Largest Rectangle in Histogram": "class Solution {\npublic:\n    int largestRectangleArea(vector<int>& heights) {\n        int res = 0, n = heights.size();\n        stack<int> stk;\n        vector<int> left(n, -1);\n        vector<int> right(n, n);\n        for (int i = 0; i < n; ++i) {\n            while (!stk.empty() && heights[stk.top()] >= heights[i]) {\n                right[stk.top()] = i;\n                stk.pop();\n            }\n            if (!stk.empty()) left[i] = stk.top();\n            stk.push(i);\n        }\n        for (int i = 0; i < n; ++i)\n            res = max(res, heights[i] * (right[i] - left[i] - 1));\n        return res;\n    }\n};",
    "85. Maximal Rectangle": "// OJ: https://leetcode.com/problems/maximal-rectangle/\n// Time: O(MN)\n// Space: O(N)\nclass Solution {\npublic:\n    int maximalRectangle(vector<vector<char>>& A) {\n        int M = A.size(), N = A[0].size(), ans = 0;\n        vector<int> h(N), nextSmaller(N);\n        for (int i = 0; i < M; ++i) {\n            for (int j = 0; j < N; ++j) {\n                h[j] = A[i][j] == '0' ? 0 : (h[j] + 1);\n            }\n            stack<int> s;\n            for (int j = N - 1; j >= 0; --j) {\n                while (s.size() && h[j] <= h[s.top()]) s.pop();\n                nextSmaller[j] = s.size() ? s.top() : N;\n                s.push(j);\n            }\n            s = {};\n            for (int j = 0; j < N; ++j) {\n                while (s.size() && h[j] <= h[s.top()]) s.pop();\n                int prevSmaller = s.size() ? s.top() : -1;\n                ans = max(ans, (nextSmaller[j] - prevSmaller - 1) * h[j]);\n                s.push(j);\n            }\n        }\n        return ans;\n    }\n};",
    "86. Partition List": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* partition(ListNode* head, int x) {\n        ListNode* d1 = new ListNode();\n        ListNode* d2 = new ListNode();\n        ListNode* t1 = d1;\n        ListNode* t2 = d2;\n        while (head) {\n            if (head->val < x) {\n                t1->next = head;\n                t1 = t1->next;\n            } else {\n                t2->next = head;\n                t2 = t2->next;\n            }\n            head = head->next;\n        }\n        t1->next = d2->next;\n        t2->next = nullptr;\n        return d1->next;\n    }\n};",
    "87. Scramble String": "class Solution {\npublic:\n    bool isScramble(string s1, string s2) {\n        int n = s1.size();\n        int f[n][n][n + 1];\n        memset(f, -1, sizeof(f));\n        function<bool(int, int, int)> dfs = [&](int i, int j, int k) -> int {\n            if (f[i][j][k] != -1) {\n                return f[i][j][k] == 1;\n            }\n            if (k == 1) {\n                return s1[i] == s2[j];\n            }\n            for (int h = 1; h < k; ++h) {\n                if (dfs(i, j, h) && dfs(i + h, j + h, k - h)) {\n                    return f[i][j][k] = true;\n                }\n                if (dfs(i + h, j, k - h) && dfs(i, j + k - h, h)) {\n                    return f[i][j][k] = true;\n                }\n            }\n            return f[i][j][k] = false;\n        };\n        return dfs(0, 0, n);\n    }\n};",
    "88. Merge Sorted Array": "class Solution {\npublic:\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\n        for (int i = m - 1, j = n - 1, k = m + n - 1; ~j; --k) {\n            nums1[k] = i >= 0 && nums1[i] > nums2[j] ? nums1[i--] : nums2[j--];\n        }\n    }\n};",
    "90. Subsets II": "class Solution {\npublic:\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\n        sort(nums.begin(), nums.end());\n        int n = nums.size();\n        vector<vector<int>> ans;\n        for (int mask = 0; mask < 1 << n; ++mask) {\n            vector<int> t;\n            bool ok = true;\n            for (int i = 0; i < n; ++i) {\n                if ((mask >> i & 1) == 1) {\n                    if (i > 0 && (mask >> (i - 1) & 1) == 0 && nums[i] == nums[i - 1]) {\n                        ok = false;\n                        break;\n                    }\n                    t.push_back(nums[i]);\n                }\n            }\n            if (ok) {\n                ans.push_back(t);\n            }\n        }\n        return ans;\n    }\n};",
    "91. Decode Ways": "class Solution {\npublic:\n    int numDecodings(string s) {\n        int n = s.size();\n        int f = 0, g = 1;\n        for (int i = 1; i <= n; ++i) {\n            int h = s[i - 1] != '0' ? g : 0;\n            if (i > 1 && (s[i - 2] == '1' || (s[i - 2] == '2' && s[i - 1] <= '6'))) {\n                h += f;\n            }\n            f = g;\n            g = h;\n        }\n        return g;\n    }\n};",
    "92. Reverse Linked List II": "// OJ: https://leetcode.com/problems/reverse-linked-list-ii/\n// Time: O(N)\n// Space: O(1)\nclass Solution {\npublic:\n    ListNode* reverseBetween(ListNode* head, int m, int n) {\n        ListNode dummy, *p = &dummy;\n        dummy.next = head;\n        for (int i = 1; i < m; ++i) p = p->next;\n        auto q = p->next, tail = q;\n        for (int i = m; i <= n; ++i) {\n            auto node = q;\n            q = q->next;\n            node->next = p->next;\n            p->next = node;\n        }\n        tail->next = q;\n        return dummy.next;\n    }\n};",
    "93. Restore IP Addresses": "class Solution {\npublic:\n    vector<string> restoreIpAddresses(string s) {\n        int n = s.size();\n        vector<string> ans;\n        vector<string> t;\n        function<void(int)> dfs = [&](int i) {\n            if (i >= n && t.size() == 4) {\n                ans.push_back(t[0] + \".\" + t[1] + \".\" + t[2] + \".\" + t[3]);\n                return;\n            }\n            if (i >= n || t.size() >= 4) {\n                return;\n            }\n            int x = 0;\n            for (int j = i; j < min(n, i + 3); ++j) {\n                x = x * 10 + s[j] - '0';\n                if (x > 255 || (j > i && s[i] == '0')) {\n                    break;\n                }\n                t.push_back(s.substr(i, j - i + 1));\n                dfs(j + 1);\n                t.pop_back();\n            }\n        };\n        dfs(0);\n        return ans;\n    }\n};",
    "94. Binary Tree Inorder Traversal": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    vector<int> inorderTraversal(TreeNode* root) {\n        vector<int> ans;\n        while (root) {\n            if (!root->left) {\n                ans.push_back(root->val);\n                root = root->right;\n            } else {\n                TreeNode* prev = root->left;\n                while (prev->right && prev->right != root) {\n                    prev = prev->right;\n                }\n                if (!prev->right) {\n                    prev->right = root;\n                    root = root->left;\n                } else {\n                    ans.push_back(root->val);\n                    prev->right = nullptr;\n                    root = root->right;\n                }\n            }\n        }\n        return ans;\n    }\n};",
    "95. Unique Binary Search Trees II": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    vector<TreeNode*> generateTrees(int n) {\n        function<vector<TreeNode*>(int, int)> dfs = [&](int i, int j) {\n            if (i > j) {\n                return vector<TreeNode*>{nullptr};\n            }\n            vector<TreeNode*> ans;\n            for (int v = i; v <= j; ++v) {\n                auto left = dfs(i, v - 1);\n                auto right = dfs(v + 1, j);\n                for (auto l : left) {\n                    for (auto r : right) {\n                        ans.push_back(new TreeNode(v, l, r));\n                    }\n                }\n            }\n            return ans;\n        };\n        return dfs(1, n);\n    }\n};",
    "96. Unique Binary Search Trees": "class Solution {\npublic:\n    int numTrees(int n) {\n        vector<int> f(n + 1);\n        f[0] = 1;\n        for (int i = 1; i <= n; ++i) {\n            for (int j = 0; j < i; ++j) {\n                f[i] += f[j] * f[i - j - 1];\n            }\n        }\n        return f[n];\n    }\n};",
    "97. Interleaving String": "class Solution {\npublic:\n    bool isInterleave(string s1, string s2, string s3) {\n        int m = s1.size(), n = s2.size();\n        if (m + n != s3.size()) {\n            return false;\n        }\n        bool f[n + 1];\n        memset(f, false, sizeof(f));\n        f[0] = true;\n        for (int i = 0; i <= m; ++i) {\n            for (int j = 0; j <= n; ++j) {\n                int k = i + j - 1;\n                if (i) {\n                    f[j] &= s1[i - 1] == s3[k];\n                }\n                if (j) {\n                    f[j] |= (s2[j - 1] == s3[k] && f[j - 1]);\n                }\n            }\n        }\n        return f[n];\n    }\n};",
    "98. Validate Binary Search Tree": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* prev;\n\n    bool isValidBST(TreeNode* root) {\n        prev = nullptr;\n        return dfs(root);\n    }\n\n    bool dfs(TreeNode* root) {\n        if (!root) return true;\n        if (!dfs(root->left)) return false;\n        if (prev && prev->val >= root->val) return false;\n        prev = root;\n        if (!dfs(root->right)) return false;\n        return true;\n    }\n};",
    "99. Recover Binary Search Tree": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    void recoverTree(TreeNode* root) {\n        TreeNode* prev = nullptr;\n        TreeNode* first = nullptr;\n        TreeNode* second = nullptr;\n        function<void(TreeNode * root)> dfs = [&](TreeNode* root) {\n            if (!root) return;\n            dfs(root->left);\n            if (prev && prev->val > root->val) {\n                if (!first) first = prev;\n                second = root;\n            }\n            prev = root;\n            dfs(root->right);\n        };\n        dfs(root);\n        swap(first->val, second->val);\n    }\n};",
    "100. Same Tree": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    bool isSameTree(TreeNode* p, TreeNode* q) {\n        if (p == q) return true;\n        if (!p || !q || p->val != q->val) return false;\n        return isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\n    }\n};",
    "101. Symmetric Tree": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    bool isSymmetric(TreeNode* root) {\n        function<bool(TreeNode*, TreeNode*)> dfs = [&](TreeNode* root1, TreeNode* root2) -> bool {\n            if (!root1 && !root2) return true;\n            if (!root1 || !root2 || root1->val != root2->val) return false;\n            return dfs(root1->left, root2->right) && dfs(root1->right, root2->left);\n        };\n        return dfs(root, root);\n    }\n};",
    "102. Binary Tree Level Order Traversal": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    vector<vector<int>> levelOrder(TreeNode* root) {\n        vector<vector<int>> ans;\n        if (!root) return ans;\n        queue<TreeNode*> q{ {root} };\n        while (!q.empty()) {\n            vector<int> t;\n            for (int n = q.size(); n; --n) {\n                auto node = q.front();\n                q.pop();\n                t.push_back(node->val);\n                if (node->left) q.push(node->left);\n                if (node->right) q.push(node->right);\n            }\n            ans.push_back(t);\n        }\n        return ans;\n    }\n};",
    "103. Binary Tree Zigzag Level Order Traversal": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\n        vector<vector<int>> ans;\n        if (!root) return ans;\n        queue<TreeNode*> q{ {root} };\n        int left = 1;\n        while (!q.empty()) {\n            vector<int> t;\n            for (int n = q.size(); n; --n) {\n                auto node = q.front();\n                q.pop();\n                t.emplace_back(node->val);\n                if (node->left) q.push(node->left);\n                if (node->right) q.push(node->right);\n            }\n            if (!left) reverse(t.begin(), t.end());\n            ans.emplace_back(t);\n            left ^= 1;\n        }\n        return ans;\n    }\n};",
    "104. Maximum Depth of Binary Tree": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int maxDepth(TreeNode* root) {\n        if (!root) return 0;\n        int l = maxDepth(root->left), r = maxDepth(root->right);\n        return 1 + max(l, r);\n    }\n};",
    "105. Construct Binary Tree from Preorder and Inorder Traversal": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\n        int n = preorder.size();\n        unordered_map<int, int> d;\n        for (int i = 0; i < n; ++i) {\n            d[inorder[i]] = i;\n        }\n        function<TreeNode*(int, int, int)> dfs = [&](int i, int j, int n) -> TreeNode* {\n            if (n <= 0) {\n                return nullptr;\n            }\n            int v = preorder[i];\n            int k = d[v];\n            TreeNode* l = dfs(i + 1, j, k - j);\n            TreeNode* r = dfs(i + 1 + k - j, k + 1, n - 1 - (k - j));\n            return new TreeNode(v, l, r);\n        };\n        return dfs(0, 0, n);\n    }\n};",
    "106. Construct Binary Tree from Inorder and Postorder Traversal": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    unordered_map<int, int> indexes;\n\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\n        for (int i = 0; i < inorder.size(); ++i) indexes[inorder[i]] = i;\n        return dfs(inorder, postorder, 0, 0, inorder.size());\n    }\n\n    TreeNode* dfs(vector<int>& inorder, vector<int>& postorder, int i, int j, int n) {\n        if (n <= 0) return nullptr;\n        int v = postorder[j + n - 1];\n        int k = indexes[v];\n        TreeNode* root = new TreeNode(v);\n        root->left = dfs(inorder, postorder, i, j, k - i);\n        root->right = dfs(inorder, postorder, k + 1, j + k - i, n - k + i - 1);\n        return root;\n    }\n};",
    "107. Binary Tree Level Order Traversal II": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    vector<vector<int>> levelOrderBottom(TreeNode* root) {\n        vector<vector<int>> ans;\n        if (!root) return ans;\n        queue<TreeNode*> q{ {root} };\n        while (!q.empty()) {\n            vector<int> t;\n            for (int i = q.size(); i; --i) {\n                auto node = q.front();\n                q.pop();\n                t.emplace_back(node->val);\n                if (node->left) q.push(node->left);\n                if (node->right) q.push(node->right);\n            }\n            ans.emplace_back(t);\n        }\n        reverse(ans.begin(), ans.end());\n        return ans;\n    }\n};",
    "108. Convert Sorted Array to Binary Search Tree": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* sortedArrayToBST(vector<int>& nums) {\n        function<TreeNode*(int, int)> dfs = [&](int l, int r) -> TreeNode* {\n            if (l > r) {\n                return nullptr;\n            }\n            int mid = (l + r) >> 1;\n            auto left = dfs(l, mid - 1);\n            auto right = dfs(mid + 1, r);\n            return new TreeNode(nums[mid], left, right);\n        };\n        return dfs(0, nums.size() - 1);\n    }\n};",
    "109. Convert Sorted List to Binary Search Tree": "// OJ: https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/\n// Time: O(NlogN)\n// Space: O(logN)\nclass Solution {\n    int getLength(ListNode *head) {\n        int ans = 0;\n        for (; head; head = head->next, ++ans);\n        return ans;\n    }\n    TreeNode *dfs(ListNode *head, int len) {\n        if (len == 0) return NULL;\n        if (len == 1) return new TreeNode(head->val);\n        auto p = head;\n        for (int i = 0; i < len / 2; ++i) p = p->next;\n        auto root = new TreeNode(p->val);\n        root->left = dfs(head, len / 2);\n        root->right = dfs(p->next, (len - 1) / 2);\n        return root;\n    }\npublic:\n    TreeNode* sortedListToBST(ListNode* head) {\n        int len = getLength(head);\n        return dfs(head, len);\n    }\n};",
    "110. Balanced Binary Tree": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    bool isBalanced(TreeNode* root) {\n        function<int(TreeNode*)> height = [&](TreeNode* root) {\n            if (!root) {\n                return 0;\n            }\n            int l = height(root->left);\n            int r = height(root->right);\n            if (l == -1 || r == -1 || abs(l - r) > 1) {\n                return -1;\n            }\n            return 1 + max(l, r);\n        };\n        return height(root) >= 0;\n    }\n};",
    "111. Minimum Depth of Binary Tree": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int minDepth(TreeNode* root) {\n        if (!root) {\n            return 0;\n        }\n        if (!root->left) {\n            return 1 + minDepth(root->right);\n        }\n        if (!root->right) {\n            return 1 + minDepth(root->left);\n        }\n        return 1 + min(minDepth(root->left), minDepth(root->right));\n    }\n};",
    "112. Path Sum": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    bool hasPathSum(TreeNode* root, int targetSum) {\n        function<bool(TreeNode*, int)> dfs = [&](TreeNode* root, int s) -> int {\n            if (!root) return false;\n            s += root->val;\n            if (!root->left && !root->right && s == targetSum) return true;\n            return dfs(root->left, s) || dfs(root->right, s);\n        };\n        return dfs(root, 0);\n    }\n};",
    "113. Path Sum II": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {\n        vector<vector<int>> ans;\n        vector<int> t;\n        function<void(TreeNode*, int)> dfs = [&](TreeNode* root, int s) {\n            if (!root) return;\n            s -= root->val;\n            t.emplace_back(root->val);\n            if (!root->left && !root->right && s == 0) ans.emplace_back(t);\n            dfs(root->left, s);\n            dfs(root->right, s);\n            t.pop_back();\n        };\n        dfs(root, targetSum);\n        return ans;\n    }\n};",
    "114. Flatten Binary Tree to Linked List": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    void flatten(TreeNode* root) {\n        while (root) {\n            if (root->left) {\n                TreeNode* pre = root->left;\n                while (pre->right) {\n                    pre = pre->right;\n                }\n                pre->right = root->right;\n                root->right = root->left;\n                root->left = nullptr;\n            }\n            root = root->right;\n        }\n    }\n};",
    "115. Distinct Subsequences": "class Solution {\npublic:\n    int numDistinct(string s, string t) {\n        int n = t.size();\n        unsigned long long f[n + 1];\n        memset(f, 0, sizeof(f));\n        f[0] = 1;\n        for (char& a : s) {\n            for (int j = n; j; --j) {\n                char b = t[j - 1];\n                if (a == b) {\n                    f[j] += f[j - 1];\n                }\n            }\n        }\n        return f[n];\n    }\n};",
    "116. Populating Next Right Pointers in Each Node": "/*\n// Definition for a Node.\nclass Node {\npublic:\n    int val;\n    Node* left;\n    Node* right;\n    Node* next;\n\n    Node() : val(0), left(NULL), right(NULL), next(NULL) {}\n\n    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {}\n\n    Node(int _val, Node* _left, Node* _right, Node* _next)\n        : val(_val), left(_left), right(_right), next(_next) {}\n};\n*/\n\nclass Solution {\npublic:\n    Node* connect(Node* root) {\n        if (!root) {\n            return root;\n        }\n        queue<Node*> q{ {root} };\n        while (!q.empty()) {\n            Node* p = nullptr;\n            for (int n = q.size(); n; --n) {\n                Node* node = q.front();\n                q.pop();\n                if (p) {\n                    p->next = node;\n                }\n                p = node;\n                if (node->left) {\n                    q.push(node->left);\n                }\n                if (node->right) {\n                    q.push(node->right);\n                }\n            }\n        }\n        return root;\n    }\n};",
    "117. Populating Next Right Pointers in Each Node II": "/*\n// Definition for a Node.\nclass Node {\npublic:\n    int val;\n    Node* left;\n    Node* right;\n    Node* next;\n\n    Node() : val(0), left(NULL), right(NULL), next(NULL) {}\n\n    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {}\n\n    Node(int _val, Node* _left, Node* _right, Node* _next)\n        : val(_val), left(_left), right(_right), next(_next) {}\n};\n*/\n\nclass Solution {\npublic:\n    Node* connect(Node* root) {\n        Node* node = root;\n        Node* prev = nullptr;\n        Node* next = nullptr;\n        auto modify = [&](Node* curr) {\n            if (!curr) {\n                return;\n            }\n            if (!next) {\n                next = curr;\n            }\n            if (prev) {\n                prev->next = curr;\n            }\n            prev = curr;\n        };\n        while (node) {\n            prev = next = nullptr;\n            while (node) {\n                modify(node->left);\n                modify(node->right);\n                node = node->next;\n            }\n            node = next;\n        }\n        return root;\n    }\n};",
    "118. Pascal's Triangle": "class Solution {\npublic:\n    vector<vector<int>> generate(int numRows) {\n        vector<vector<int>> f;\n        f.push_back(vector<int>(1, 1));\n        for (int i = 0; i < numRows - 1; ++i) {\n            vector<int> g;\n            g.push_back(1);\n            for (int j = 0; j < f[i].size() - 1; ++j) {\n                g.push_back(f[i][j] + f[i][j + 1]);\n            }\n            g.push_back(1);\n            f.push_back(g);\n        }\n        return f;\n    }\n};",
    "119. Pascal's Triangle II": "class Solution {\npublic:\n    vector<int> getRow(int rowIndex) {\n        vector<int> f(rowIndex + 1, 1);\n        for (int i = 2; i < rowIndex + 1; ++i) {\n            for (int j = i - 1; j; --j) {\n                f[j] += f[j - 1];\n            }\n        }\n        return f;\n    }\n};",
    "120. Triangle": "class Solution {\npublic:\n    int minimumTotal(vector<vector<int>>& triangle) {\n        for (int i = triangle.size() - 2; ~i; --i) {\n            for (int j = 0; j <= i; ++j) {\n                triangle[i][j] += min(triangle[i + 1][j], triangle[i + 1][j + 1]);\n            }\n        }\n        return triangle[0][0];\n    }\n};",
    "121. Best Time to Buy and Sell Stock": "class Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n        int ans = 0, mi = prices[0];\n        for (int& v : prices) {\n            ans = max(ans, v - mi);\n            mi = min(mi, v);\n        }\n        return ans;\n    }\n};",
    "122. Best Time to Buy and Sell Stock II": "class Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n        int ans = 0;\n        for (int i = 1; i < prices.size(); ++i) ans += max(0, prices[i] - prices[i - 1]);\n        return ans;\n    }\n};",
    "123. Best Time to Buy and Sell Stock III": "class Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n        int f1 = -prices[0], f2 = 0, f3 = -prices[0], f4 = 0;\n        for (int i = 1; i < prices.size(); ++i) {\n            f1 = max(f1, -prices[i]);\n            f2 = max(f2, f1 + prices[i]);\n            f3 = max(f3, f2 - prices[i]);\n            f4 = max(f4, f3 + prices[i]);\n        }\n        return f4;\n    }\n};",
    "124. Binary Tree Maximum Path Sum": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int maxPathSum(TreeNode* root) {\n        int ans = -1001;\n        function<int(TreeNode*)> dfs = [&](TreeNode* root) {\n            if (!root) {\n                return 0;\n            }\n            int left = max(0, dfs(root->left));\n            int right = max(0, dfs(root->right));\n            ans = max(ans, left + right + root->val);\n            return root->val + max(left, right);\n        };\n        dfs(root);\n        return ans;\n    }\n};",
    "125. Valid Palindrome": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.size() - 1;\n        while (i < j) {\n            if (!isalnum(s[i])) {\n                ++i;\n            } else if (!isalnum(s[j])) {\n                --j;\n            } else if (tolower(s[i]) != tolower(s[j])) {\n                return false;\n            } else {\n                ++i;\n                --j;\n            }\n        }\n        return true;\n    }\n};",
    "127. Word Ladder": "class Solution {\npublic:\n    int ladderLength(string beginWord, string endWord, vector<string>& wordList) {\n        unordered_set<string> words(wordList.begin(), wordList.end());\n        if (!words.count(endWord)) return 0;\n        queue<string> q1{ {beginWord} };\n        queue<string> q2{ {endWord} };\n        unordered_map<string, int> m1;\n        unordered_map<string, int> m2;\n        m1[beginWord] = 0;\n        m2[endWord] = 0;\n        while (!q1.empty() && !q2.empty()) {\n            int t = q1.size() <= q2.size() ? extend(m1, m2, q1, words) : extend(m2, m1, q2, words);\n            if (t != -1) return t + 1;\n        }\n        return 0;\n    }\n\n    int extend(unordered_map<string, int>& m1, unordered_map<string, int>& m2, queue<string>& q, unordered_set<string>& words) {\n        for (int i = q.size(); i > 0; --i) {\n            string s = q.front();\n            int step = m1[s];\n            q.pop();\n            for (int j = 0; j < s.size(); ++j) {\n                char ch = s[j];\n                for (char k = 'a'; k <= 'z'; ++k) {\n                    s[j] = k;\n                    if (!words.count(s) || m1.count(s)) continue;\n                    if (m2.count(s)) return step + 1 + m2[s];\n                    m1[s] = step + 1;\n                    q.push(s);\n                }\n                s[j] = ch;\n            }\n        }\n        return -1;\n    }\n};",
    "128. Longest Consecutive Sequence": "class Solution {\npublic:\n    int longestConsecutive(vector<int>& nums) {\n        unordered_set<int> s(nums.begin(), nums.end());\n        int ans = 0;\n        for (int x : nums) {\n            if (!s.count(x - 1)) {\n                int y = x + 1;\n                while (s.count(y)) {\n                    y++;\n                }\n                ans = max(ans, y - x);\n            }\n        }\n        return ans;\n    }\n};",
    "129. Sum Root to Leaf Numbers": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int sumNumbers(TreeNode* root) {\n        function<int(TreeNode*, int)> dfs = [&](TreeNode* root, int s) -> int {\n            if (!root) return 0;\n            s = s * 10 + root->val;\n            if (!root->left && !root->right) return s;\n            return dfs(root->left, s) + dfs(root->right, s);\n        };\n        return dfs(root, 0);\n    }\n};",
    "130. Surrounded Regions": "class Solution {\npublic:\n    void solve(vector<vector<char>>& board) {\n        int m = board.size(), n = board[0].size();\n        for (int i = 0; i < m; ++i)\n            for (int j = 0; j < n; ++j)\n                if ((i == 0 || i == m - 1 || j == 0 || j == n - 1) && board[i][j] == 'O')\n                    dfs(board, i, j);\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (board[i][j] == '.')\n                    board[i][j] = 'O';\n                else if (board[i][j] == 'O')\n                    board[i][j] = 'X';\n            }\n        }\n    }\n\n    void dfs(vector<vector<char>>& board, int i, int j) {\n        board[i][j] = '.';\n        vector<int> dirs = {-1, 0, 1, 0, -1};\n        for (int k = 0; k < 4; ++k) {\n            int x = i + dirs[k], y = j + dirs[k + 1];\n            if (x >= 0 && x < board.size() && y >= 0 && y < board[0].size() && board[x][y] == 'O')\n                dfs(board, x, y);\n        }\n    }\n};",
    "131. Palindrome Partitioning": "// OJ: https://leetcode.com/problems/palindrome-partitioning/\n// Time: O(N *  2^N)\n// Space: O(N) extra space\nclass Solution {\n    vector<vector<string>> ans;\n    vector<string> tmp;\n    bool isPalindrome(string &s, int i, int j) {\n        while (i < j && s[i] == s[j]) ++i, --j;\n        return i >= j;\n    }\n    void dfs(string &s, int start) {\n        if (start == s.size()) {\n            ans.push_back(tmp);\n            return;\n        }\n        for (int i = start; i < s.size(); ++i) {\n            if (!isPalindrome(s, start, i)) continue;\n            tmp.push_back(s.substr(start, i - start + 1));\n            dfs(s, i + 1);\n            tmp.pop_back();\n        }\n    }\npublic:\n    vector<vector<string>> partition(string s) {\n        dfs(s, 0);\n        return ans;\n    }\n};",
    "132. Palindrome Partitioning II": "class Solution {\npublic:\n    int minCut(string s) {\n        int n = s.size();\n        vector<vector<bool>> dp1(n, vector<bool>(n));\n        for (int i = n - 1; i >= 0; --i) {\n            for (int j = i; j < n; ++j) {\n                dp1[i][j] = s[i] == s[j] && (j - i < 3 || dp1[i + 1][j - 1]);\n            }\n        }\n        vector<int> dp2(n);\n        for (int i = 0; i < n; ++i) {\n            if (!dp1[0][i]) {\n                dp2[i] = i;\n                for (int j = 1; j <= i; ++j) {\n                    if (dp1[j][i]) {\n                        dp2[i] = min(dp2[i], dp2[j - 1] + 1);\n                    }\n                }\n            }\n        }\n        return dp2[n - 1];\n    }\n};",
    "133. Clone Graph": "/*\n// Definition for a Node.\nclass Node {\npublic:\n    int val;\n    vector<Node*> neighbors;\n    Node() {\n        val = 0;\n        neighbors = vector<Node*>();\n    }\n    Node(int _val) {\n        val = _val;\n        neighbors = vector<Node*>();\n    }\n    Node(int _val, vector<Node*> _neighbors) {\n        val = _val;\n        neighbors = _neighbors;\n    }\n};\n*/\n\nclass Solution {\npublic:\n    unordered_map<Node*, Node*> visited;\n\n    Node* cloneGraph(Node* node) {\n        if (!node) return nullptr;\n        if (visited.count(node)) return visited[node];\n        Node* clone = new Node(node->val);\n        visited[node] = clone;\n        for (auto& e : node->neighbors)\n            clone->neighbors.push_back(cloneGraph(e));\n        return clone;\n    }\n};",
    "134. Gas Station": "class Solution {\npublic:\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\n        int n = gas.size();\n        int i = n - 1, j = n - 1;\n        int cnt = 0, s = 0;\n        while (cnt < n) {\n            s += gas[j] - cost[j];\n            ++cnt;\n            j = (j + 1) % n;\n            while (s < 0 && cnt < n) {\n                --i;\n                s += gas[i] - cost[i];\n                ++cnt;\n            }\n        }\n        return s < 0 ? -1 : i;\n    }\n};",
    "135. Candy": "class Solution {\npublic:\n    int candy(vector<int>& ratings) {\n        int n = ratings.size();\n        vector<int> left(n, 1);\n        vector<int> right(n, 1);\n        for (int i = 1; i < n; ++i) {\n            if (ratings[i] > ratings[i - 1]) {\n                left[i] = left[i - 1] + 1;\n            }\n        }\n        for (int i = n - 2; ~i; --i) {\n            if (ratings[i] > ratings[i + 1]) {\n                right[i] = right[i + 1] + 1;\n            }\n        }\n        int ans = 0;\n        for (int i = 0; i < n; ++i) {\n            ans += max(left[i], right[i]);\n        }\n        return ans;\n    }\n};",
    "136. Single Number": "class Solution {\npublic:\n    int singleNumber(vector<int>& nums) {\n        int ans = 0;\n        for (int v : nums) {\n            ans ^= v;\n        }\n        return ans;\n    }\n};",
    "137. Single Number II": "class Solution {\npublic:\n    int singleNumber(vector<int>& nums) {\n        int a = 0, b = 0;\n        for (int c : nums) {\n            int aa = (~a & b & c) | (a & ~b & ~c);\n            int bb = ~a & (b ^ c);\n            a = aa;\n            b = bb;\n        }\n        return b;\n    }\n};",
    "138. Copy List with Random Pointer": "// OJ: https://leetcode.com/problems/copy-list-with-random-pointer/\n// Time: O(N)\n// Space: O(1)\nclass Solution {\npublic:\n    Node* copyRandomList(Node* head) {\n        auto p = head;\n        while (p) {\n            auto node = p;\n            p = p->next;\n            auto copy = new Node(node->val);\n            node->next = copy;\n            copy->next = p;\n        }\n        p = head;\n        while (p) {\n            if (p->random) p->next->random = p->random->next;\n            p = p->next->next;\n        }\n        p = head;\n        Node h(0), *tail = &h;\n        while (p) {\n            auto node = p->next;\n            p->next = node->next;\n            p = p->next;\n            tail->next = node;\n            tail = node;\n        }\n        return h.next;\n    }\n};",
    "139. Word Break": "// OJ: https://leetcode.com/problems/word-break/\n// Time: O(S^3)\n// Space: O(S + W)\nclass Solution {\npublic:\n    bool wordBreak(string s, vector<string>& dict) {\n        unordered_set<string> st(begin(dict), end(dict));\n        int N = s.size();\n        vector<bool> dp(N + 1);\n        dp[0] = true;\n        for (int i = 1; i <= N; ++i) {\n            for (int j = 0; j < i && !dp[i]; ++j) {\n                dp[i] = dp[j] && st.count(s.substr(j, i - j));\n            }\n        }\n        return dp[N];\n    }\n};",
    "141. Linked List Cycle": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    bool hasCycle(ListNode* head) {\n        ListNode* slow = head;\n        ListNode* fast = head;\n        while (fast && fast->next) {\n            slow = slow->next;\n            fast = fast->next->next;\n            if (slow == fast) {\n                return true;\n            }\n        }\n        return false;\n    }\n};",
    "142. Linked List Cycle II": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* detectCycle(ListNode* head) {\n        ListNode* fast = head;\n        ListNode* slow = head;\n        while (fast && fast->next) {\n            slow = slow->next;\n            fast = fast->next->next;\n            if (slow == fast) {\n                ListNode* ans = head;\n                while (ans != slow) {\n                    ans = ans->next;\n                    slow = slow->next;\n                }\n                return ans;\n            }\n        }\n        return nullptr;\n    }\n};",
    "143. Reorder List": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    void reorderList(ListNode* head) {\n        ListNode* fast = head;\n        ListNode* slow = head;\n        while (fast->next && fast->next->next) {\n            slow = slow->next;\n            fast = fast->next->next;\n        }\n\n        ListNode* cur = slow->next;\n        slow->next = nullptr;\n\n        ListNode* pre = nullptr;\n        while (cur) {\n            ListNode* t = cur->next;\n            cur->next = pre;\n            pre = cur;\n            cur = t;\n        }\n        cur = head;\n\n        while (pre) {\n            ListNode* t = pre->next;\n            pre->next = cur->next;\n            cur->next = pre;\n            cur = pre->next;\n            pre = t;\n        }\n    }\n};",
    "144. Binary Tree Preorder Traversal": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    vector<int> preorderTraversal(TreeNode* root) {\n        vector<int> ans;\n        while (root) {\n            if (!root->left) {\n                ans.push_back(root->val);\n                root = root->right;\n            } else {\n                TreeNode* prev = root->left;\n                while (prev->right && prev->right != root) {\n                    prev = prev->right;\n                }\n                if (!prev->right) {\n                    ans.push_back(root->val);\n                    prev->right = root;\n                    root = root->left;\n                } else {\n                    prev->right = nullptr;\n                    root = root->right;\n                }\n            }\n        }\n        return ans;\n    }\n};",
    "145. Binary Tree Postorder Traversal": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    vector<int> postorderTraversal(TreeNode* root) {\n        vector<int> ans;\n        while (root) {\n            if (!root->right) {\n                ans.push_back(root->val);\n                root = root->left;\n            } else {\n                TreeNode* next = root->right;\n                while (next->left && next->left != root) {\n                    next = next->left;\n                }\n                if (!next->left) {\n                    ans.push_back(root->val);\n                    next->left = root;\n                    root = root->right;\n                } else {\n                    next->left = nullptr;\n                    root = root->left;\n                }\n            }\n        }\n        reverse(ans.begin(), ans.end());\n        return ans;\n    }\n};",
    "146. LRU Cache": "struct Node {\n    int k;\n    int v;\n    Node* prev;\n    Node* next;\n\n    Node()\n        : k(0)\n        , v(0)\n        , prev(nullptr)\n        , next(nullptr) {}\n    Node(int key, int val)\n        : k(key)\n        , v(val)\n        , prev(nullptr)\n        , next(nullptr) {}\n};\n\nclass LRUCache {\npublic:\n    LRUCache(int capacity)\n        : cap(capacity)\n        , size(0) {\n        head = new Node();\n        tail = new Node();\n        head->next = tail;\n        tail->prev = head;\n    }\n\n    int get(int key) {\n        if (!cache.count(key)) return -1;\n        Node* node = cache[key];\n        moveToHead(node);\n        return node->v;\n    }\n\n    void put(int key, int value) {\n        if (cache.count(key)) {\n            Node* node = cache[key];\n            node->v = value;\n            moveToHead(node);\n        } else {\n            Node* node = new Node(key, value);\n            cache[key] = node;\n            addToHead(node);\n            ++size;\n            if (size > cap) {\n                node = removeTail();\n                cache.erase(node->k);\n                --size;\n            }\n        }\n    }\n\nprivate:\n    unordered_map<int, Node*> cache;\n    Node* head;\n    Node* tail;\n    int cap;\n    int size;\n\n    void moveToHead(Node* node) {\n        removeNode(node);\n        addToHead(node);\n    }\n\n    void removeNode(Node* node) {\n        node->prev->next = node->next;\n        node->next->prev = node->prev;\n    }\n\n    void addToHead(Node* node) {\n        node->next = head->next;\n        node->prev = head;\n        head->next = node;\n        node->next->prev = node;\n    }\n\n    Node* removeTail() {\n        Node* node = tail->prev;\n        removeNode(node);\n        return node;\n    }\n};\n\n/**\n * Your LRUCache object will be instantiated and called as such:\n * LRUCache* obj = new LRUCache(capacity);\n * int param_1 = obj->get(key);\n * obj->put(key,value);\n */",
    "148. Sort List": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* sortList(ListNode* head) {\n        if (!head || !head->next) return head;\n        auto* slow = head;\n        auto* fast = head->next;\n        while (fast && fast->next) {\n            slow = slow->next;\n            fast = fast->next->next;\n        }\n        auto* t = slow->next;\n        slow->next = nullptr;\n        auto* l1 = sortList(head);\n        auto* l2 = sortList(t);\n        auto* dummy = new ListNode();\n        auto* cur = dummy;\n        while (l1 && l2) {\n            if (l1->val <= l2->val) {\n                cur->next = l1;\n                l1 = l1->next;\n            } else {\n                cur->next = l2;\n                l2 = l2->next;\n            }\n            cur = cur->next;\n        }\n        cur->next = l1 ? l1 : l2;\n        return dummy->next;\n    }\n};",
    "149. Max Points on a Line": "class Solution {\npublic:\n    int gcd(int a, int b) {\n        return b == 0 ? a : gcd(b, a % b);\n    }\n    int maxPoints(vector<vector<int>>& points) {\n        int n = points.size();\n        int ans = 1;\n        for (int i = 0; i < n; ++i) {\n            int x1 = points[i][0], y1 = points[i][1];\n            unordered_map<string, int> cnt;\n            for (int j = i + 1; j < n; ++j) {\n                int x2 = points[j][0], y2 = points[j][1];\n                int dx = x2 - x1, dy = y2 - y1;\n                int g = gcd(dx, dy);\n                string k = to_string(dx / g) + \".\" + to_string(dy / g);\n                cnt[k]++;\n                ans = max(ans, cnt[k] + 1);\n            }\n        }\n        return ans;\n    }\n};",
    "150. Evaluate Reverse Polish Notation": "class Solution {\npublic:\n    int evalRPN(vector<string>& tokens) {\n        stack<int> stk;\n        for (auto& t : tokens) {\n            if (t.size() > 1 || isdigit(t[0])) {\n                stk.push(stoi(t));\n            } else {\n                int y = stk.top();\n                stk.pop();\n                int x = stk.top();\n                stk.pop();\n                if (t[0] == '+')\n                    stk.push(x + y);\n                else if (t[0] == '-')\n                    stk.push(x - y);\n                else if (t[0] == '*')\n                    stk.push(x * y);\n                else\n                    stk.push(x / y);\n            }\n        }\n        return stk.top();\n    }\n};",
    "151. Reverse Words in a String": "class Solution {\npublic:\n    string reverseWords(string s) {\n        int i = 0;\n        int j = 0;\n        int n = s.size();\n        while (i < n) {\n            while (i < n && s[i] == ' ') {\n                ++i;\n            }\n            if (i < n) {\n                if (j != 0) {\n                    s[j++] = ' ';\n                }\n                int k = i;\n                while (k < n && s[k] != ' ') {\n                    s[j++] = s[k++];\n                }\n                reverse(s.begin() + j - (k - i), s.begin() + j);\n                i = k;\n            }\n        }\n        s.erase(s.begin() + j, s.end());\n        reverse(s.begin(), s.end());\n        return s;\n    }\n};",
    "152. Maximum Product Subarray": "class Solution {\npublic:\n    int maxProduct(vector<int>& nums) {\n        int f = nums[0], g = nums[0], ans = nums[0];\n        for (int i = 1; i < nums.size(); ++i) {\n            int ff = f, gg = g;\n            f = max({nums[i], ff * nums[i], gg * nums[i]});\n            g = min({nums[i], ff * nums[i], gg * nums[i]});\n            ans = max(ans, f);\n        }\n        return ans;\n    }\n};",
    "153. Find Minimum in Rotated Sorted Array": "class Solution {\npublic:\n    int findMin(vector<int>& nums) {\n        int n = nums.size();\n        if (nums[0] <= nums[n - 1]) return nums[0];\n        int left = 0, right = n - 1;\n        while (left < right) {\n            int mid = (left + right) >> 1;\n            if (nums[0] <= nums[mid])\n                left = mid + 1;\n            else\n                right = mid;\n        }\n        return nums[left];\n    }\n};",
    "154. Find Minimum in Rotated Sorted Array II": "class Solution {\npublic:\n    int findMin(vector<int>& nums) {\n        int left = 0, right = nums.size() - 1;\n        while (left < right) {\n            int mid = (left + right) >> 1;\n            if (nums[mid] > nums[right])\n                left = mid + 1;\n            else if (nums[mid] < nums[right])\n                right = mid;\n            else\n                --right;\n        }\n        return nums[left];\n    }\n};",
    "155. Min Stack": "class MinStack {\npublic:\n    MinStack() {\n        stk2.push(INT_MAX);\n    }\n\n    void push(int val) {\n        stk1.push(val);\n        stk2.push(min(val, stk2.top()));\n    }\n\n    void pop() {\n        stk1.pop();\n        stk2.pop();\n    }\n\n    int top() {\n        return stk1.top();\n    }\n\n    int getMin() {\n        return stk2.top();\n    }\n\nprivate:\n    stack<int> stk1;\n    stack<int> stk2;\n};\n\n/**\n * Your MinStack object will be instantiated and called as such:\n * MinStack* obj = new MinStack();\n * obj->push(val);\n * obj->pop();\n * int param_3 = obj->top();\n * int param_4 = obj->getMin();\n */",
    "160. Intersection of Two Linked Lists": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* getIntersectionNode(ListNode* headA, ListNode* headB) {\n        ListNode *a = headA, *b = headB;\n        while (a != b) {\n            a = a ? a->next : headB;\n            b = b ? b->next : headA;\n        }\n        return a;\n    }\n};",
    "162. Find Peak Element": "class Solution {\npublic:\n    int findPeakElement(vector<int>& nums) {\n        int left = 0, right = nums.size() - 1;\n        while (left < right) {\n            int mid = left + right >> 1;\n            if (nums[mid] > nums[mid + 1]) {\n                right = mid;\n            } else {\n                left = mid + 1;\n            }\n        }\n        return left;\n    }\n};",
    "164. Maximum Gap": "// OJ: https://leetcode.com/problems/maximum-gap/\n// Time: O(N)\n// Space: O(N)\n// Ref: https://discuss.leetcode.com/topic/5999/bucket-sort-java-solution-with-explanation-o-n-time-and-space\nclass Solution {\npublic:\n    int maximumGap(vector<int>& A) {\n        if (A.size() == 1) return 0;\n        int minVal = *min_element(begin(A), end(A));\n        int maxVal = *max_element(begin(A), end(A));\n        int N = A.size(), gap = (maxVal - minVal + N - 2) / (N - 1);\n        vector<int> mn(N - 1, INT_MAX), mx(N - 1, INT_MIN);\n        for (int n : A) {\n            if (n == minVal || n == maxVal) continue;\n            int i = (n - minVal) / gap;\n            mn[i] = min(mn[i], n);\n            mx[i] = max(mx[i], n);\n        }\n        int ans = gap, prev = minVal;\n        for (int i = 0; i < N - 1; ++i) {\n            if (mn[i] == INT_MAX) continue;\n            ans = max(ans, mn[i] - prev);\n            prev = mx[i];\n        }\n        return max(ans, maxVal - prev);\n    }\n};",
    "165. Compare Version Numbers": "class Solution {\npublic:\n    int compareVersion(string version1, string version2) {\n        int m = version1.size(), n = version2.size();\n        for (int i = 0, j = 0; i < m || j < n; ++i, ++j) {\n            int a = 0, b = 0;\n            while (i < m && version1[i] != '.') {\n                a = a * 10 + (version1[i++] - '0');\n            }\n            while (j < n && version2[j] != '.') {\n                b = b * 10 + (version2[j++] - '0');\n            }\n            if (a != b) {\n                return a < b ? -1 : 1;\n            }\n        }\n        return 0;\n    }\n};",
    "166. Fraction to Recurring Decimal": "using LL = long long;\n\nclass Solution {\npublic:\n    string fractionToDecimal(int numerator, int denominator) {\n        if (numerator == 0) return \"0\";\n        string res = \"\";\n        bool neg = (numerator > 0) ^ (denominator > 0);\n        if (neg) res += \"-\";\n        LL num = abs(numerator);\n        LL d = abs(denominator);\n        res += to_string(num / d);\n        num %= d;\n        if (num == 0) return res;\n        res += \".\";\n        unordered_map<LL, int> mp;\n        while (num) {\n            mp[num] = res.size();\n            num *= 10;\n            res += to_string(num / d);\n            num %= d;\n            if (mp.count(num)) {\n                int idx = mp[num];\n                res.insert(idx, \"(\");\n                res += \")\";\n                break;\n            }\n        }\n        return res;\n    }\n};",
    "167. Two Sum II - Input array is sorted": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& numbers, int target) {\n        int left = 1, right = numbers.size();\n        while (left < right) {\n            int x = numbers[left - 1] + numbers[right - 1];\n            if (x == target) return {left, right};\n            if (x < target)\n                ++left;\n            else\n                --right;\n        }\n        return {-1, -1};\n    }\n};",
    "169. Majority Element": "class Solution {\npublic:\n    int majorityElement(vector<int>& nums) {\n        int cnt = 0, m = 0;\n        for (int& x : nums) {\n            if (cnt == 0) {\n                m = x;\n                cnt = 1;\n            } else {\n                cnt += m == x ? 1 : -1;\n            }\n        }\n        return m;\n    }\n};",
    "171. Excel Sheet Column Number": "class Solution {\npublic:\n    int titleToNumber(string columnTitle) {\n        int res = 0;\n        for (char c : columnTitle) {\n            res = res * 26 + (c - 'A' + 1);\n        }\n        return res;\n    }\n};",
    "172. Factorial Trailing Zeroes": "class Solution {\npublic:\n    int trailingZeroes(int n) {\n        int ans = 0;\n        while (n) {\n            n /= 5;\n            ans += n;\n        }\n        return ans;\n    }\n};",
    "173. Binary Search Tree Iterator": "// OJ: https://leetcode.com/problems/binary-search-tree-iterator/\n// Time: O(1) amortized\n// Space: O(H)\nclass BSTIterator {\nprivate:\n    stack<TreeNode*> s;\n    void pushNodes(TreeNode *node) {\n        while (node) {\n            s.push(node);\n            node = node->left;\n        }\n    }\npublic:\n    BSTIterator(TreeNode* root) {\n        pushNodes(root);\n    }\n    int next() {\n        auto node = s.top();\n        s.pop();\n        pushNodes(node->right);\n        return node->val;\n    }\n    bool hasNext() {\n        return s.size();\n    }\n};",
    "174. Dungeon Game": "class Solution {\npublic:\n    int calculateMinimumHP(vector<vector<int>>& dungeon) {\n        int m = dungeon.size(), n = dungeon[0].size();\n        int dp[m + 1][n + 1];\n        memset(dp, 0x3f, sizeof dp);\n        dp[m][n - 1] = dp[m - 1][n] = 1;\n        for (int i = m - 1; ~i; --i) {\n            for (int j = n - 1; ~j; --j) {\n                dp[i][j] = max(1, min(dp[i + 1][j], dp[i][j + 1]) - dungeon[i][j]);\n            }\n        }\n        return dp[0][0];\n    }\n};",
    "179. Largest Number": "class Solution {\npublic:\n    string largestNumber(vector<int>& nums) {\n        vector<string> vs;\n        for (int v : nums) vs.push_back(to_string(v));\n        sort(vs.begin(), vs.end(), [](string& a, string& b) {\n            return a + b > b + a;\n        });\n        if (vs[0] == \"0\") return \"0\";\n        string ans;\n        for (string v : vs) ans += v;\n        return ans;\n    }\n};",
    "187. Repeated DNA Sequences": "class Solution {\npublic:\n    vector<string> findRepeatedDnaSequences(string s) {\n        unordered_map<string, int> cnt;\n        vector<string> ans;\n        for (int i = 0, n = s.size() - 10 + 1; i < n; ++i) {\n            auto t = s.substr(i, 10);\n            if (++cnt[t] == 2) {\n                ans.emplace_back(t);\n            }\n        }\n        return ans;\n    }\n};",
    "188. Best Time to Buy and Sell Stock IV": "class Solution {\npublic:\n    int maxProfit(int k, vector<int>& prices) {\n        int n = prices.size();\n        int f[k + 1][2];\n        memset(f, 0, sizeof(f));\n        for (int j = 1; j <= k; ++j) {\n            f[j][1] = -prices[0];\n        }\n        for (int i = 1; i < n; ++i) {\n            for (int j = k; j; --j) {\n                f[j][0] = max(f[j][1] + prices[i], f[j][0]);\n                f[j][1] = max(f[j - 1][0] - prices[i], f[j][1]);\n            }\n        }\n        return f[k][0];\n    }\n};",
    "189. Rotate Array": "class Solution {\npublic:\n    void rotate(vector<int>& nums, int k) {\n        int n = nums.size();\n        k %= n;\n        reverse(nums.begin(), nums.end());\n        reverse(nums.begin(), nums.begin() + k);\n        reverse(nums.begin() + k, nums.end());\n    }\n};",
    "190. Reverse Bits": "class Solution {\npublic:\n    uint32_t reverseBits(uint32_t n) {\n        uint32_t res = 0;\n        for (int i = 0; i < 32; ++i) {\n            res |= ((n & 1) << (31 - i));\n            n >>= 1;\n        }\n        return res;\n    }\n};",
    "191. Number of 1 Bits": "class Solution {\npublic:\n    int hammingWeight(uint32_t n) {\n        int ans = 0;\n        while (n) {\n            n &= n - 1;\n            ++ans;\n        }\n        return ans;\n    }\n};",
    "198. House Robber": "// rob[i + 1] = nums[i] + skip[i] // If we rob at house[i], we must skip house[i-1]\n// skip[i + 1] = max(rob[i - 1], skip[i - 1]) // If we skip house[i], we can pick the maximum from robbing or skipping house[i-1]\n\nclass Solution {\npublic:\n    int rob(vector<int>& nums) {\n        int n = nums.size();\n        int a = 0, b = nums[0];\n        for (int i = 1; i < n; ++i) {\n            int c = max(nums[i] + a, b);\n            a = b;\n            b = c;\n        }\n        return b;\n    }\n};",
    "199. Binary Tree Right Side View": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    vector<int> rightSideView(TreeNode* root) {\n        vector<int> ans;\n        if (!root) {\n            return ans;\n        }\n        queue<TreeNode*> q{ {root} };\n        while (!q.empty()) {\n            ans.emplace_back(q.back()->val);\n            for (int n = q.size(); n; --n) {\n                TreeNode* node = q.front();\n                q.pop();\n                if (node->left) {\n                    q.push(node->left);\n                }\n                if (node->right) {\n                    q.push(node->right);\n                }\n            }\n        }\n        return ans;\n    }\n};",
    "200. Number of Islands": "class Solution {\npublic:\n    int numIslands(vector<vector<char>>& grid) {\n        int m = grid.size();\n        int n = grid[0].size();\n        int ans = 0;\n        int dirs[5] = {-1, 0, 1, 0, -1};\n        function<void(int, int)> dfs = [&](int i, int j) {\n            grid[i][j] = '0';\n            for (int k = 0; k < 4; ++k) {\n                int x = i + dirs[k], y = j + dirs[k + 1];\n                if (x >= 0 && x < grid.size() && y >= 0 && y < grid[0].size() && grid[x][y] == '1') {\n                    dfs(x, y);\n                }\n            }\n        };\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (grid[i][j] == '1') {\n                    dfs(i, j);\n                    ++ans;\n                }\n            }\n        }\n        return ans;\n    }\n};\n\n//////\n\nclass Solution {\npublic:\n    int numIslands(vector<vector<char>>& grid) {\n        int m = grid.size();\n        int n = grid[0].size();\n        int ans = 0;\n        int dirs[5] = {-1, 0, 1, 0, -1};\n        function<void(int, int)> bfs = [&](int i, int j) {\n            grid[i][j] = '0';\n            queue<pair<int, int>> q;\n            q.push({i, j});\n            vector<int> dirs = {-1, 0, 1, 0, -1};\n            while (!q.empty()) {\n                auto [a, b] = q.front();\n                q.pop();\n                for (int k = 0; k < 4; ++k) {\n                    int x = a + dirs[k];\n                    int y = b + dirs[k + 1];\n                    if (x >= 0 && x < grid.size() && y >= 0 && y < grid[0].size() && grid[x][y] == '1') {\n                        q.push({x, y});\n                        grid[x][y] = '0';\n                    }\n                }\n            }\n        };\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (grid[i][j] == '1') {\n                    bfs(i, j);\n                    ++ans;\n                }\n            }\n        }\n        return ans;\n    }\n};",
    "201. Bitwise AND of Numbers Range": "class Solution {\npublic:\n    int rangeBitwiseAnd(int left, int right) {\n        while (left < right) {\n            right &= (right - 1);\n        }\n        return right;\n    }\n};",
    "202. Happy Number": "class Solution {\npublic:\n    bool isHappy(int n) {\n        auto next = [](int x) {\n            int y = 0;\n            for (; x; x /= 10) {\n                y += pow(x % 10, 2);\n            }\n            return y;\n        };\n        int slow = n, fast = next(n);\n        while (slow != fast) {\n            slow = next(slow);\n            fast = next(next(fast));\n        }\n        return slow == 1;\n    }\n};",
    "203. Remove Linked List Elements": "class Solution {\npublic:\n    ListNode* removeElements(ListNode* head, int val) {\n        ListNode* dummy = new ListNode();\n        dummy->next = head;\n        ListNode* p = dummy;\n        while (p->next) {\n            if (p->next->val == val) {\n                p->next = p->next->next;\n            } else {\n                p = p->next;\n            }\n        }\n        return dummy->next;\n    }\n};",
    "204. Count Primes": "class Solution {\npublic:\n    int countPrimes(int n) {\n        vector<bool> primes(n, true);\n        int ans = 0;\n        for (int i = 2; i < n; ++i) {\n            if (primes[i]) {\n                ++ans;\n                for (int j = i; j < n; j += i) primes[j] = false;\n            }\n        }\n        return ans;\n    }\n};",
    "205. Isomorphic Strings": "class Solution {\npublic:\n    bool isIsomorphic(string s, string t) {\n        int d1[256]{};\n        int d2[256]{};\n        int n = s.size();\n        for (int i = 0; i < n; ++i) {\n            char a = s[i], b = t[i];\n            if (d1[a] != d2[b]) {\n                return false;\n            }\n            d1[a] = d2[b] = i + 1;\n        }\n        return true;\n    }\n};",
    "206. Reverse Linked List": "// OJ: https://leetcode.com/problems/reverse-linked-list/\n// Time: O(N)\n// Space: O(1)\nclass Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode h;\n        while (head) {\n            auto p = head;\n            head = head->next;\n            p->next = h.next;\n            h.next = p;\n        }\n        return h.next;\n    }\n};",
    "207. Course Schedule": "class Solution {\npublic:\n    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {\n        vector<vector<int>> g(numCourses);\n        vector<int> indeg(numCourses);\n        for (auto& p : prerequisites) {\n            int a = p[0], b = p[1];\n            g[b].push_back(a);\n            ++indeg[a];\n        }\n        queue<int> q;\n        for (int i = 0; i < numCourses; ++i) {\n            if (indeg[i] == 0) {\n                q.push(i);\n            }\n        }\n        int cnt = 0;\n        while (!q.empty()) {\n            int i = q.front();\n            q.pop();\n            ++cnt;\n            for (int j : g[i]) {\n                if (--indeg[j] == 0) {\n                    q.push(j);\n                }\n            }\n        }\n        return cnt == numCourses;\n    }\n};",
    "208. Implement Trie (Prefix Tree)": "// OJ: https://leetcode.com/problems/implement-trie-prefix-tree/\n// Time: O(W) for insert/search/startsWith\n// Space: O(1) extra space for all\nstruct TrieNode {\n    TrieNode *next[26] = {};\n    bool word = false;\n};\nclass Trie {\n    TrieNode root;\n    TrieNode *find(string &word) {\n        auto node = &root;\n        for (char c : word) {\n            if (!node->next[c - 'a']) return NULL;\n            node = node->next[c - 'a'];\n        }\n        return node;\n    }\npublic:\n    void insert(string word) {\n        auto node = &root;\n        for (char c : word) {\n            if (!node->next[c - 'a']) node->next[c - 'a'] = new TrieNode();\n            node = node->next[c - 'a'];\n        }\n        node->word = true;\n    }\n    bool search(string word) {\n        auto node = find(word);\n        return node && node->word;\n    }\n    bool startsWith(string prefix) {\n        return find(prefix);\n    }\n};",
    "209. Minimum Size Subarray Sum": "class Solution {\npublic:\n    int minSubArrayLen(int target, vector<int>& nums) {\n        int n = nums.size();\n        long long s = 0;\n        int ans = n + 1;\n        for (int i = 0, j = 0; i < n; ++i) {\n            s += nums[i];\n            while (j < n && s >= target) {\n                ans = min(ans, i - j + 1);\n                s -= nums[j++];\n            }\n        }\n        return ans == n + 1 ? 0 : ans;\n    }\n};",
    "210. Course Schedule II": "class Solution {\npublic:\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\n        vector<vector<int>> g(numCourses);\n        vector<int> indeg(numCourses);\n        for (auto& p : prerequisites) {\n            int a = p[0], b = p[1];\n            g[b].push_back(a);\n            ++indeg[a];\n        }\n        queue<int> q;\n        for (int i = 0; i < numCourses; ++i) {\n            if (indeg[i] == 0) {\n                q.push(i);\n            }\n        }\n        vector<int> ans;\n        while (!q.empty()) {\n            int i = q.front();\n            q.pop();\n            ans.push_back(i);\n            for (int j : g[i]) {\n                if (--indeg[j] == 0) {\n                    q.push(j);\n                }\n            }\n        }\n        return ans.size() == numCourses ? ans : vector<int>();\n    }\n};",
    "211. Add and Search Word - Data structure design": "class trie {\npublic:\n    vector<trie*> children;\n    bool is_end;\n\n    trie() {\n        children = vector<trie*>(26, nullptr);\n        is_end = false;\n    }\n\n    void insert(const string& word) {\n        trie* cur = this;\n        for (char c : word) {\n            c -= 'a';\n            if (cur->children[c] == nullptr) {\n                cur->children[c] = new trie;\n            }\n            cur = cur->children[c];\n        }\n        cur->is_end = true;\n    }\n};\n\nclass WordDictionary {\nprivate:\n    trie* root;\n\npublic:\n    WordDictionary()\n        : root(new trie) {}\n\n    void addWord(string word) {\n        root->insert(word);\n    }\n\n    bool search(string word) {\n        return dfs(word, 0, root);\n    }\n\nprivate:\n    bool dfs(const string& word, int i, trie* cur) {\n        if (i == word.size()) {\n            return cur->is_end;\n        }\n        char c = word[i];\n        if (c != '.') {\n            trie* child = cur->children[c - 'a'];\n            if (child != nullptr && dfs(word, i + 1, child)) {\n                return true;\n            }\n        } else {\n            for (trie* child : cur->children) {\n                if (child != nullptr && dfs(word, i + 1, child)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n};\n\n/**\n * Your WordDictionary object will be instantiated and called as such:\n * WordDictionary* obj = new WordDictionary();\n * obj->addWord(word);\n * bool param_2 = obj->search(word);\n */",
    "212. Word Search II": "class Trie {\npublic:\n    vector<Trie*> children;\n    int ref;\n\n    Trie()\n        : children(26, nullptr)\n        , ref(-1) {}\n\n    void insert(const string& w, int ref) {\n        Trie* node = this;\n        for (char c : w) {\n            c -= 'a';\n            if (!node->children[c]) {\n                node->children[c] = new Trie();\n            }\n            node = node->children[c];\n        }\n        node->ref = ref;\n    }\n};\n\nclass Solution {\npublic:\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\n        Trie* tree = new Trie();\n        for (int i = 0; i < words.size(); ++i) {\n            tree->insert(words[i], i);\n        }\n        vector<string> ans;\n        int m = board.size(), n = board[0].size();\n\n        function<void(Trie*, int, int)> dfs = [&](Trie* node, int i, int j) {\n            int idx = board[i][j] - 'a';\n            if (!node->children[idx]) {\n                return;\n            }\n            node = node->children[idx];\n            if (node->ref != -1) {\n                ans.emplace_back(words[node->ref]);\n                node->ref = -1;\n            }\n            int dirs[5] = {-1, 0, 1, 0, -1};\n            char c = board[i][j];\n            board[i][j] = '#';\n            for (int k = 0; k < 4; ++k) {\n                int x = i + dirs[k], y = j + dirs[k + 1];\n                if (x >= 0 && x < m && y >= 0 && y < n && board[x][y] != '#') {\n                    dfs(node, x, y);\n                }\n            }\n            board[i][j] = c;\n        };\n\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                dfs(tree, i, j);\n            }\n        }\n        return ans;\n    }\n};",
    "213. House Robber II": "class Solution {\npublic:\n    int rob(vector<int>& nums) {\n        int n = nums.size();\n        if (n == 1) {\n            return nums[0];\n        }\n        return max(robRange(nums, 0, n - 2), robRange(nums, 1, n - 1));\n    }\n\n    int robRange(vector<int>& nums, int l, int r) {\n        int f = 0, g = 0;\n        for (; l <= r; ++l) {\n            int ff = max(f, g);\n            g = f + nums[l];\n            f = ff;\n        }\n        return max(f, g);\n    }\n};",
    "214. Shortest Palindrome": "// OJ: https://leetcode.com/problems/shortest-palindrome/\n// Time: O(N)\n// Space: O(1) ignoring the space taken by the answer\nclass Solution {\npublic:\n    string shortestPalindrome(string s) {\n        unsigned d = 16777619, h = 0, rh = 0, p = 1, maxLen = 0;\n        for (int i = 0; i < s.size(); ++i) {\n            h = h * d + s[i] - 'a';\n            rh += (s[i] - 'a') * p;\n            p *= d;\n            if (h == rh) maxLen = i + 1;\n        }\n        return string(rbegin(s), rbegin(s) + s.size() - maxLen) + s;\n    }\n};",
    "215. Kth Largest Element in an Array": "class Solution {\npublic:\n    int findKthLargest(vector<int>& nums, int k) {\n        int n = nums.size();\n        return quickSort(nums, 0, n - 1, n - k);\n    }\n\n    int quickSort(vector<int>& nums, int left, int right, int k) {\n        if (left == right) return nums[left];\n        int i = left - 1, j = right + 1;\n        int x = nums[left + right >> 1];\n        while (i < j) {\n            while (nums[++i] < x)\n                ;\n            while (nums[--j] > x)\n                ;\n            if (i < j) swap(nums[i], nums[j]);\n        }\n        return j < k ? quickSort(nums, j + 1, right, k) : quickSort(nums, left, j, k);\n    }\n};",
    "216. Combination Sum III": "class Solution {\npublic:\n    vector<vector<int>> combinationSum3(int k, int n) {\n        vector<vector<int>> ans;\n        vector<int> t;\n        function<void(int, int)> dfs = [&](int i, int s) {\n            if (s == 0) {\n                if (t.size() == k) {\n                    ans.emplace_back(t);\n                }\n                return;\n            }\n            if (i > 9 || i > s || t.size() >= k) {\n                return;\n            }\n            t.emplace_back(i);\n            dfs(i + 1, s - i);\n            t.pop_back();\n            dfs(i + 1, s);\n        };\n        dfs(1, n);\n        return ans;\n    }\n};",
    "217. Contains Duplicate": "class Solution {\npublic:\n    bool containsDuplicate(vector<int>& nums) {\n        unordered_set<int> s(nums.begin(), nums.end());\n        return s.size() < nums.size();\n    }\n};",
    "218. The Skyline Problem": "// OJ: https://leetcode.com/problems/the-skyline-problem/\n// Time: O(NlogN)\n// Space: O(N)\n// Ref: https://discuss.leetcode.com/topic/14939/my-c-code-using-one-priority-queue-812-ms\nbool cmp(vector<int> &a, vector<int> &b) {\n    return a[0] < b[0];\n}\nclass Solution {\npublic:\n    vector<pair<int, int>> getSkyline(vector<vector<int>>& buildings) {\n         vector<pair<int, int>> ans;\n         sort(buildings.begin(), buildings.end(), cmp);\n         int i = 0, x = 0, y = 0, N = buildings.size();\n         priority_queue<pair<int, int>> live;// first: height, second: right\n         while (i < N || !live.empty()) {\n             if (i < N && (live.empty() || live.top().second >= buildings[i][0])) {\n                 x = buildings[i][0];\n                 while (i < N && buildings[i][0] == x) {\n                     live.push(make_pair(buildings[i][2], buildings[i][1]));\n                     ++i;\n                 }\n             } else {\n                 x = live.top().second;\n                 while (!live.empty() && live.top().second <= x) live.pop();\n             }\n             y = live.empty() ? 0 : live.top().first;\n             if (ans.empty() || ans.back().second != y) ans.push_back(make_pair(x, y));\n         }\n         return ans;\n    }\n};",
    "219. Contains Duplicate II": "class Solution {\npublic:\n    bool containsNearbyDuplicate(vector<int>& nums, int k) {\n        unordered_map<int, int> d;\n        for (int i = 0; i < nums.size(); ++i) {\n            if (d.count(nums[i]) && i - d[nums[i]] <= k) {\n                return true;\n            }\n            d[nums[i]] = i;\n        }\n        return false;\n    }\n};",
    "220. Contains Duplicate III": "class Solution {\npublic:\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int indexDiff, int valueDiff) {\n        set<long> s;\n        for (int i = 0; i < nums.size(); ++i) {\n            auto it = s.lower_bound((long) nums[i] - valueDiff);\n            if (it != s.end() && *it <= (long) nums[i] + valueDiff) return true;\n            s.insert((long) nums[i]);\n            if (i >= indexDiff) s.erase((long) nums[i - indexDiff]);\n        }\n        return false;\n    }\n};",
    "221. Maximal Square": "class Solution {\npublic:\n    int maximalSquare(vector<vector<char>>& matrix) {\n        int m = matrix.size(), n = matrix[0].size();\n        vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));\n        int mx = 0;\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (matrix[i][j] == '1') {\n                    dp[i + 1][j + 1] = min(min(dp[i][j + 1], dp[i + 1][j]), dp[i][j]) + 1;\n                    mx = max(mx, dp[i + 1][j + 1]);\n                }\n            }\n        }\n        return mx * mx;\n    }\n};",
    "222. Count Complete Tree Nodes": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int countNodes(TreeNode* root) {\n        if (!root) {\n            return 0;\n        }\n        int left = depth(root->left);\n        int right = depth(root->right);\n        if (left == right) {\n            return (1 << left) + countNodes(root->right);\n        }\n        return (1 << right) + countNodes(root->left);\n    }\n\n    int depth(TreeNode* root) {\n        int d = 0;\n        for (; root; root = root->left) {\n            ++d;\n        }\n        return d;\n    }\n};",
    "223. Rectangle Area": "class Solution {\npublic:\n    int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {\n        int a = (ax2 - ax1) * (ay2 - ay1);\n        int b = (bx2 - bx1) * (by2 - by1);\n        int width = min(ax2, bx2) - max(ax1, bx1);\n        int height = min(ay2, by2) - max(ay1, by1);\n        return a + b - max(height, 0) * max(width, 0);\n    }\n};",
    "224. Basic Calculator": "class Solution {\npublic:\n    int calculate(string s) {\n        stack<int> stk;\n        int ans = 0, sign = 1;\n        int n = s.size();\n        for (int i = 0; i < n; ++i) {\n            if (isdigit(s[i])) {\n                int x = 0;\n                int j = i;\n                while (j < n && isdigit(s[j])) {\n                    x = x * 10 + (s[j] - '0');\n                    ++j;\n                }\n                ans += sign * x;\n                i = j - 1;\n            } else if (s[i] == '+') {\n                sign = 1;\n            } else if (s[i] == '-') {\n                sign = -1;\n            } else if (s[i] == '(') {\n                stk.push(ans);\n                stk.push(sign);\n                ans = 0;\n                sign = 1;\n            } else if (s[i] == ')') {\n                ans *= stk.top();\n                stk.pop();\n                ans += stk.top();\n                stk.pop();\n            }\n        }\n        return ans;\n    }\n};",
    "225. Implement Stack using Queues": "class MyStack {\npublic:\n    MyStack() {\n    }\n\n    void push(int x) {\n        q2.push(x);\n        while (!q1.empty()) {\n            q2.push(q1.front());\n            q1.pop();\n        }\n        swap(q1, q2);\n    }\n\n    int pop() {\n        int x = q1.front();\n        q1.pop();\n        return x;\n    }\n\n    int top() {\n        return q1.front();\n    }\n\n    bool empty() {\n        return q1.empty();\n    }\n\nprivate:\n    queue<int> q1;\n    queue<int> q2;\n};\n\n/**\n * Your MyStack object will be instantiated and called as such:\n * MyStack* obj = new MyStack();\n * obj->push(x);\n * int param_2 = obj->pop();\n * int param_3 = obj->top();\n * bool param_4 = obj->empty();\n */",
    "226. Invert Binary Tree": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* invertTree(TreeNode* root) {\n        function<void(TreeNode*)> dfs = [&](TreeNode* root) {\n            if (!root) {\n                return;\n            }\n            swap(root->left, root->right);\n            dfs(root->left);\n            dfs(root->right);\n        };\n        dfs(root);\n        return root;\n    }\n};",
    "227. Basic Calculator II": "class Solution {\npublic:\n    int calculate(string s) {\n        int v = 0, n = s.size();\n        char sign = '+';\n        stack<int> stk;\n        for (int i = 0; i < n; ++i) {\n            char c = s[i];\n            if (isdigit(c)) v = v * 10 + (c - '0');\n            if (i == n - 1 || c == '+' || c == '-' || c == '*' || c == '/') {\n                if (sign == '+')\n                    stk.push(v);\n                else if (sign == '-')\n                    stk.push(-v);\n                else if (sign == '*') {\n                    int t = stk.top();\n                    stk.pop();\n                    stk.push(t * v);\n                } else {\n                    int t = stk.top();\n                    stk.pop();\n                    stk.push(t / v);\n                }\n                sign = c;\n                v = 0;\n            }\n        }\n        int ans = 0;\n        while (!stk.empty()) {\n            ans += stk.top();\n            stk.pop();\n        }\n        return ans;\n    }\n};",
    "228. Summary Ranges": "class Solution {\npublic:\n    vector<string> summaryRanges(vector<int>& nums) {\n        vector<string> ans;\n        auto f = [&](int i, int j) {\n            return i == j ? to_string(nums[i]) : to_string(nums[i]) + \"->\" + to_string(nums[j]);\n        };\n        for (int i = 0, j, n = nums.size(); i < n; i = j + 1) {\n            j = i;\n            while (j + 1 < n && nums[j + 1] == nums[j] + 1) {\n                ++j;\n            }\n            ans.emplace_back(f(i, j));\n        }\n        return ans;\n    }\n};",
    "229. Majority Element II": "class Solution {\npublic:\n    vector<int> majorityElement(vector<int>& nums) {\n        int n1 = 0, n2 = 0;\n        int m1 = 0, m2 = 1;\n        for (int m : nums) {\n            if (m == m1)\n                ++n1;\n            else if (m == m2)\n                ++n2;\n            else if (n1 == 0) {\n                m1 = m;\n                ++n1;\n            } else if (n2 == 0) {\n                m2 = m;\n                ++n2;\n            } else {\n                --n1;\n                --n2;\n            }\n        }\n        vector<int> ans;\n        if (count(nums.begin(), nums.end(), m1) > nums.size() / 3) ans.push_back(m1);\n        if (count(nums.begin(), nums.end(), m2) > nums.size() / 3) ans.push_back(m2);\n        return ans;\n    }\n};",
    "230. Kth Smallest Element in a BST": "// OJ: https://leetcode.com/problems/kth-smallest-element-in-a-bst/\n// Time: O(N)\n// Space: O(H)\nclass Solution {\npublic:\n    int kthSmallest(TreeNode* root, int k) {\n        function<int(TreeNode*)> inorder = [&](TreeNode *root) {\n            if (!root) return -1;\n            int val = inorder(root->left);\n            if (val != -1) return val;\n            if (--k == 0) return root->val;\n            return inorder(root->right);\n        };\n        return inorder(root);\n    }\n};",
    "231. Power of Two": "class Solution {\npublic:\n    bool isPowerOfTwo(int n) {\n        return n > 0 && (n & (n - 1)) == 0;\n    }\n};",
    "232. Implement Queue using Stacks": "// OJ: https://leetcode.com/problems/implement-queue-using-stacks\n// Time: O(1) amortized.\n// Space: O(1)\nclass MyQueue {\n    stack<int> in, out;\npublic:\n    MyQueue() {}\n    \n    void push(int x) {\n        in.push(x);\n    }\n    \n    int pop() {\n        int val = peek();\n        out.pop();\n        return val;\n    }\n    \n    int peek() {\n        if (out.empty()) {\n            while (in.size()) {\n                out.push(in.top());\n                in.pop();\n            }\n        }\n        return out.top();\n    }\n    \n    bool empty() {\n        return in.empty() && out.empty();\n    }\n};",
    "233. Number of Digit One": "class Solution {\npublic:\n    int a[12];\n    int dp[12][12];\n\n    int countDigitOne(int n) {\n        int len = 0;\n        while (n) {\n            a[++len] = n % 10;\n            n /= 10;\n        }\n        memset(dp, -1, sizeof dp);\n        return dfs(len, 0, true);\n    }\n\n    int dfs(int pos, int cnt, bool limit) {\n        if (pos <= 0) {\n            return cnt;\n        }\n        if (!limit && dp[pos][cnt] != -1) {\n            return dp[pos][cnt];\n        }\n        int ans = 0;\n        int up = limit ? a[pos] : 9;\n        for (int i = 0; i <= up; ++i) {\n            ans += dfs(pos - 1, cnt + (i == 1), limit && i == up);\n        }\n        if (!limit) {\n            dp[pos][cnt] = ans;\n        }\n        return ans;\n    }\n};",
    "234. Palindrome Linked List": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    bool isPalindrome(ListNode* head) {\n        ListNode* slow = head;\n        ListNode* fast = head->next;\n        while (fast && fast->next) {\n            slow = slow->next;\n            fast = fast->next->next;\n        }\n        ListNode* pre = nullptr;\n        ListNode* cur = slow->next;\n        while (cur) {\n            ListNode* t = cur->next;\n            cur->next = pre;\n            pre = cur;\n            cur = t;\n        }\n        while (pre) {\n            if (pre->val != head->val) return false;\n            pre = pre->next;\n            head = head->next;\n        }\n        return true;\n    }\n};",
    "235. Lowest Common Ancestor of a Binary Search Tree": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\n\nclass Solution {\npublic:\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\n        while (1) {\n            if (root->val < min(p->val, q->val)) {\n                root = root->right;\n            } else if (root->val > max(p->val, q->val)) {\n                root = root->left;\n            } else {\n                return root;\n            }\n        }\n    }\n};",
    "236. Lowest Common Ancestor of a Binary Tree": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\n        if (!root || root == p || root == q) return root;\n        TreeNode* left = lowestCommonAncestor(root->left, p, q);\n        TreeNode* right = lowestCommonAncestor(root->right, p, q);\n        if (left && right) return root;\n        return left ? left : right;\n    }\n};",
    "237. Delete Node in a Linked List": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    void deleteNode(ListNode* node) {\n        node->val = node->next->val;\n        node->next = node->next->next;\n    }\n};",
    "238. Product of Array Except Self": "class Solution {\npublic:\n    vector<int> productExceptSelf(vector<int>& nums) {\n        int n = nums.size();\n        vector<int> ans(n);\n        for (int i = 0, left = 1; i < n; ++i) {\n            ans[i] = left;\n            left *= nums[i];\n        }\n        for (int i = n - 1, right = 1; ~i; --i) {\n            ans[i] *= right;\n            right *= nums[i];\n        }\n        return ans;\n    }\n};",
    "239. Sliding Window Maximum": "// OJ: https://leetcode.com/problems/sliding-window-maximum/\n// Time: O(N)\n// Space: O(N)\nclass Solution {\npublic:\n    vector<int> maxSlidingWindow(vector<int>& A, int k) {\n        vector<int> ans;\n        deque<int> q;\n        for (int i = 0; i < A.size(); ++i) {\n            if (q.size() && q.front() == i - k) q.pop_front();\n            while (q.size() && A[q.back()] <= A[i]) q.pop_back();\n            q.push_back(i);\n            if (i >= k - 1) ans.push_back(A[q.front()]);\n        }\n        return ans;\n    }\n};"
}