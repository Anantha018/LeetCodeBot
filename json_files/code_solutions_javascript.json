{
    "1. Two Sum": "/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number[]}\n */\nvar twoSum = function (nums, target) {\n    const m = new Map();\n    for (let i = 0; ; ++i) {\n        const x = nums[i];\n        const y = target - x;\n        if (m.has(y)) {\n            return [m.get(y), i];\n        }\n        m.set(x, i);\n    }\n};",
    "2. Add Two Numbers": "/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} l1\n * @param {ListNode} l2\n * @return {ListNode}\n */\nvar addTwoNumbers = function (l1, l2) {\n    const dummy = new ListNode();\n    let carry = 0;\n    let cur = dummy;\n    while (l1 || l2 || carry) {\n        const s = (l1?.val || 0) + (l2?.val || 0) + carry;\n        carry = Math.floor(s / 10);\n        cur.next = new ListNode(s % 10);\n        cur = cur.next;\n        l1 = l1?.next;\n        l2 = l2?.next;\n    }\n    return dummy.next;\n};",
    "3. Longest Substring Without Repeating Characters": "/**\n * @param {string} s\n * @return {number}\n */\nvar lengthOfLongestSubstring = function (s) {\n    const ss = new Set();\n    let i = 0;\n    let ans = 0;\n    for (let j = 0; j < s.length; ++j) {\n        while (ss.has(s[j])) {\n            ss.delete(s[i++]);\n        }\n        ss.add(s[j]);\n        ans = Math.max(ans, j - i + 1);\n    }\n    return ans;\n};",
    "4. Median of Two Sorted Arrays": "/**\n * @param {number[]} nums1\n * @param {number[]} nums2\n * @return {number}\n */\nvar findMedianSortedArrays = function (nums1, nums2) {\n    const m = nums1.length;\n    const n = nums2.length;\n    const f = (i, j, k) => {\n        if (i >= m) {\n            return nums2[j + k - 1];\n        }\n        if (j >= n) {\n            return nums1[i + k - 1];\n        }\n        if (k == 1) {\n            return Math.min(nums1[i], nums2[j]);\n        }\n        const p = Math.floor(k / 2);\n        const x = i + p - 1 < m ? nums1[i + p - 1] : 1 << 30;\n        const y = j + p - 1 < n ? nums2[j + p - 1] : 1 << 30;\n        return x < y ? f(i + p, j, k - p) : f(i, j + p, k - p);\n    };\n    const a = f(0, 0, Math.floor((m + n + 1) / 2));\n    const b = f(0, 0, Math.floor((m + n + 2) / 2));\n    return (a + b) / 2;\n};",
    "5. Longest Palindromic Substring": "/**\n * @param {string} s\n * @return {string}\n */\nvar longestPalindrome = function (s) {\n    const n = s.length;\n    const f = Array(n)\n        .fill(0)\n        .map(() => Array(n).fill(true));\n    let k = 0;\n    let mx = 1;\n    for (let i = n - 2; i >= 0; --i) {\n        for (let j = i + 1; j < n; ++j) {\n            f[i][j] = false;\n            if (s[i] === s[j]) {\n                f[i][j] = f[i + 1][j - 1];\n                if (f[i][j] && mx < j - i + 1) {\n                    mx = j - i + 1;\n                    k = i;\n                }\n            }\n        }\n    }\n    return s.slice(k, k + mx);\n};",
    "6. ZigZag Conversion": "/**\n * @param {string} s\n * @param {number} numRows\n * @return {string}\n */\nvar convert = function (s, numRows) {\n    if (numRows == 1) return s;\n    let arr = new Array(numRows);\n    for (let i = 0; i < numRows; i++) arr[i] = [];\n    let mi = 0,\n        isDown = true;\n    for (const c of s) {\n        arr[mi].push(c);\n\n        if (mi >= numRows - 1) isDown = false;\n        else if (mi <= 0) isDown = true;\n\n        if (isDown) mi++;\n        else mi--;\n    }\n    let ans = [];\n    for (let item of arr) {\n        ans = ans.concat(item);\n    }\n    return ans.join('');\n};",
    "7. Reverse Integer": "/**\n * @param {number} x\n * @return {number}\n */\nvar reverse = function (x) {\n    const mi = -(2 ** 31);\n    const mx = 2 ** 31 - 1;\n    let ans = 0;\n    for (; x != 0; x = ~~(x / 10)) {\n        if (ans < ~~(mi / 10) || ans > ~~(mx / 10)) {\n            return 0;\n        }\n        ans = ans * 10 + (x % 10);\n    }\n    return ans;\n};",
    "9. Palindrome Number": "/**\n * @param {number} x\n * @return {boolean}\n */\nvar isPalindrome = function (x) {\n    if (x < 0 || (x > 0 && x % 10 === 0)) {\n        return false;\n    }\n    let y = 0;\n    for (; y < x; x = ~~(x / 10)) {\n        y = y * 10 + (x % 10);\n    }\n    return x === y || x === ~~(y / 10);\n};",
    "10. Regular Expression Matching": "/**\n * @param {string} s\n * @param {string} p\n * @return {boolean}\n */\nvar isMatch = function (s, p) {\n    const m = s.length;\n    const n = p.length;\n    const f = Array.from({ length: m + 1 }, () => Array(n + 1).fill(false));\n    f[0][0] = true;\n    for (let i = 0; i <= m; ++i) {\n        for (let j = 1; j <= n; ++j) {\n            if (p[j - 1] === '*') {\n                f[i][j] = f[i][j - 2];\n                if (i && (p[j - 2] === '.' || p[j - 2] === s[i - 1])) {\n                    f[i][j] |= f[i - 1][j];\n                }\n            } else if (i && (p[j - 1] === '.' || p[j - 1] === s[i - 1])) {\n                f[i][j] = f[i - 1][j - 1];\n            }\n        }\n    }\n    return f[m][n];\n};",
    "11. Container With Most Water": "/**\n * @param {number[]} height\n * @return {number}\n */\nvar maxArea = function (height) {\n    let i = 0;\n    let j = height.length - 1;\n    let ans = 0;\n    while (i < j) {\n        const t = Math.min(height[i], height[j]) * (j - i);\n        ans = Math.max(ans, t);\n        if (height[i] < height[j]) {\n            ++i;\n        } else {\n            --j;\n        }\n    }\n    return ans;\n};",
    "13. Roman to Integer": "const romanToInt = function (s) {\n    const d = {\n        I: 1,\n        V: 5,\n        X: 10,\n        L: 50,\n        C: 100,\n        D: 500,\n        M: 1000,\n    };\n    let ans = d[s[s.length - 1]];\n    for (let i = 0; i < s.length - 1; ++i) {\n        const sign = d[s[i]] < d[s[i + 1]] ? -1 : 1;\n        ans += sign * d[s[i]];\n    }\n    return ans;\n};",
    "14. Longest Common Prefix": "/**\n * @param {string[]} strs\n * @return {string}\n */\nvar longestCommonPrefix = function (strs) {\n    for (let j = 0; j < strs[0].length; j++) {\n        for (let i = 0; i < strs.length; i++) {\n            if (strs[0][j] !== strs[i][j]) {\n                return strs[0].substring(0, j);\n            }\n        }\n    }\n    return strs[0];\n};",
    "15. 3Sum": "/**\n * @param {number[]} nums\n * @return {number[][]}\n */\nvar threeSum = function (nums) {\n    const n = nums.length;\n    nums.sort((a, b) => a - b);\n    const ans = [];\n    for (let i = 0; i < n - 2 && nums[i] <= 0; ++i) {\n        if (i > 0 && nums[i] === nums[i - 1]) {\n            continue;\n        }\n        let j = i + 1;\n        let k = n - 1;\n        while (j < k) {\n            const x = nums[i] + nums[j] + nums[k];\n            if (x < 0) {\n                ++j;\n            } else if (x > 0) {\n                --k;\n            } else {\n                ans.push([nums[i], nums[j++], nums[k--]]);\n                while (j < k && nums[j] === nums[j - 1]) {\n                    ++j;\n                }\n                while (j < k && nums[k] === nums[k + 1]) {\n                    --k;\n                }\n            }\n        }\n    }\n    return ans;\n};",
    "16. 3Sum Closest": "/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number}\n */\nvar threeSumClosest = function (nums, target) {\n    nums.sort((a, b) => a - b);\n    let ans = 1 << 30;\n    const n = nums.length;\n    for (let i = 0; i < n; ++i) {\n        let j = i + 1;\n        let k = n - 1;\n        while (j < k) {\n            const t = nums[i] + nums[j] + nums[k];\n            if (t === target) {\n                return t;\n            }\n            if (Math.abs(t - target) < Math.abs(ans - target)) {\n                ans = t;\n            }\n            if (t > target) {\n                --k;\n            } else {\n                ++j;\n            }\n        }\n    }\n    return ans;\n};",
    "17. Letter Combinations of a Phone Number": "/**\n * @param {string} digits\n * @return {string[]}\n */\nvar letterCombinations = function (digits) {\n    if (digits.length == 0) {\n        return [];\n    }\n    const ans = [''];\n    const d = ['abc', 'def', 'ghi', 'jkl', 'mno', 'pqrs', 'tuv', 'wxyz'];\n    for (const i of digits) {\n        const s = d[parseInt(i) - 2];\n        const t = [];\n        for (const a of ans) {\n            for (const b of s) {\n                t.push(a + b);\n            }\n        }\n        ans.splice(0, ans.length, ...t);\n    }\n    return ans;\n};",
    "18. 4Sum": "/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number[][]}\n */\nvar fourSum = function (nums, target) {\n    const n = nums.length;\n    const ans = [];\n    if (n < 4) {\n        return ans;\n    }\n    nums.sort((a, b) => a - b);\n    for (let i = 0; i < n - 3; ++i) {\n        if (i > 0 && nums[i] === nums[i - 1]) {\n            continue;\n        }\n        for (let j = i + 1; j < n - 2; ++j) {\n            if (j > i + 1 && nums[j] === nums[j - 1]) {\n                continue;\n            }\n            let [k, l] = [j + 1, n - 1];\n            while (k < l) {\n                const x = nums[i] + nums[j] + nums[k] + nums[l];\n                if (x < target) {\n                    ++k;\n                } else if (x > target) {\n                    --l;\n                } else {\n                    ans.push([nums[i], nums[j], nums[k++], nums[l--]]);\n                    while (k < l && nums[k] === nums[k - 1]) {\n                        ++k;\n                    }\n                    while (k < l && nums[l] === nums[l + 1]) {\n                        --l;\n                    }\n                }\n            }\n        }\n    }\n    return ans;\n};",
    "19. Remove Nth Node From End of List": "/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} n\n * @return {ListNode}\n */\nvar removeNthFromEnd = function (head, n) {\n    const dummy = new ListNode(0, head);\n    let fast = dummy,\n        slow = dummy;\n    while (n--) {\n        fast = fast.next;\n    }\n    while (fast.next) {\n        slow = slow.next;\n        fast = fast.next;\n    }\n    slow.next = slow.next.next;\n    return dummy.next;\n};",
    "20. Valid Parentheses": "/**\n * @param {string} s\n * @return {boolean}\n */\nvar isValid = function (s) {\n    let stk = [];\n    for (const c of s) {\n        if (c == '(' || c == '{' || c == '[') {\n            stk.push(c);\n        } else if (stk.length == 0 || !match(stk[stk.length - 1], c)) {\n            return false;\n        } else {\n            stk.pop();\n        }\n    }\n    return stk.length == 0;\n};\n\nfunction match(l, r) {\n    return (l == '(' && r == ')') || (l == '[' && r == ']') || (l == '{' && r == '}');\n}",
    "21. Merge Two Sorted Lists": "/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} list1\n * @param {ListNode} list2\n * @return {ListNode}\n */\nvar mergeTwoLists = function (list1, list2) {\n    const dummy = new ListNode();\n    let curr = dummy;\n    while (list1 && list2) {\n        if (list1.val <= list2.val) {\n            curr.next = list1;\n            list1 = list1.next;\n        } else {\n            curr.next = list2;\n            list2 = list2.next;\n        }\n        curr = curr.next;\n    }\n    curr.next = list1 || list2;\n    return dummy.next;\n};",
    "22. Generate Parentheses": "/**\n * @param {number} n\n * @return {string[]}\n */\nvar generateParenthesis = function (n) {\n    function dfs(l, r, t) {\n        if (l > n || r > n || l < r) {\n            return;\n        }\n        if (l == n && r == n) {\n            ans.push(t);\n            return;\n        }\n        dfs(l + 1, r, t + '(');\n        dfs(l, r + 1, t + ')');\n    }\n    let ans = [];\n    dfs(0, 0, '');\n    return ans;\n};",
    "23. Merge k Sorted Lists": "/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode[]} lists\n * @return {ListNode}\n */\nvar mergeKLists = function (lists) {\n    const n = lists.length;\n    if (n == 0) {\n        return null;\n    }\n    for (let i = 1; i < n; ++i) {\n        lists[i] = mergeTwoLists(lists[i - 1], lists[i]);\n    }\n    return lists[n - 1];\n};\n\nfunction mergeTwoLists(l1, l2) {\n    const dummy = new ListNode();\n    let cur = dummy;\n    while (l1 && l2) {\n        if (l1.val <= l2.val) {\n            cur.next = l1;\n            l1 = l1.next;\n        } else {\n            cur.next = l2;\n            l2 = l2.next;\n        }\n        cur = cur.next;\n    }\n    cur.next = l1 || l2;\n    return dummy.next;\n}",
    "24. Swap Nodes in Pairs": "/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar swapPairs = function (head) {\n    const dummy = new ListNode(0, head);\n    let [pre, cur] = [dummy, head];\n    while (cur && cur.next) {\n        const t = cur.next;\n        cur.next = t.next;\n        t.next = cur;\n        pre.next = t;\n        [pre, cur] = [cur, cur.next];\n    }\n    return dummy.next;\n};",
    "26. Remove Duplicates from Sorted Array": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar removeDuplicates = function (nums) {\n    let k = 0;\n    for (const x of nums) {\n        if (k === 0 || x !== nums[k - 1]) {\n            nums[k++] = x;\n        }\n    }\n    return k;\n};",
    "27. Remove Element": "/**\n * @param {number[]} nums\n * @param {number} val\n * @return {number}\n */\nvar removeElement = function (nums, val) {\n    let k = 0;\n    for (const x of nums) {\n        if (x !== val) {\n            nums[k++] = x;\n        }\n    }\n    return k;\n};",
    "31. Next Permutation": "/**\n * @param {number[]} nums\n * @return {void} Do not return anything, modify nums in-place instead.\n */\nvar nextPermutation = function (nums) {\n    const n = nums.length;\n    let i = n - 2;\n    while (i >= 0 && nums[i] >= nums[i + 1]) {\n        --i;\n    }\n    if (i >= 0) {\n        let j = n - 1;\n        while (j > i && nums[j] <= nums[i]) {\n            --j;\n        }\n        [nums[i], nums[j]] = [nums[j], nums[i]];\n    }\n    for (i = i + 1, j = n - 1; i < j; ++i, --j) {\n        [nums[i], nums[j]] = [nums[j], nums[i]];\n    }\n};",
    "32. Longest Valid Parentheses": "/**\n * @param {string} s\n * @return {number}\n */\nvar longestValidParentheses = function (s) {\n    const n = s.length;\n    const f = new Array(n + 1).fill(0);\n    for (let i = 2; i <= n; ++i) {\n        if (s[i - 1] === ')') {\n            if (s[i - 2] === '(') {\n                f[i] = f[i - 2] + 2;\n            } else {\n                const j = i - f[i - 1] - 1;\n                if (j && s[j - 1] === '(') {\n                    f[i] = f[i - 1] + 2 + f[j - 1];\n                }\n            }\n        }\n    }\n    return Math.max(...f);\n};",
    "33. Search in Rotated Sorted Array": "/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number}\n */\nvar search = function (nums, target) {\n    const n = nums.length;\n    let left = 0,\n        right = n - 1;\n    while (left < right) {\n        const mid = (left + right) >> 1;\n        if (nums[0] <= nums[mid]) {\n            if (nums[0] <= target && target <= nums[mid]) {\n                right = mid;\n            } else {\n                left = mid + 1;\n            }\n        } else {\n            if (nums[mid] < target && target <= nums[n - 1]) {\n                left = mid + 1;\n            } else {\n                right = mid;\n            }\n        }\n    }\n    return nums[left] == target ? left : -1;\n};",
    "34. Find First and Last Position of Element in Sorted Array": "/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number[]}\n */\nvar searchRange = function (nums, target) {\n    function search(x) {\n        let left = 0,\n            right = nums.length;\n        while (left < right) {\n            const mid = (left + right) >> 1;\n            if (nums[mid] >= x) {\n                right = mid;\n            } else {\n                left = mid + 1;\n            }\n        }\n        return left;\n    }\n    const l = search(target);\n    const r = search(target + 1);\n    return l == r ? [-1, -1] : [l, r - 1];\n};",
    "35. Search Insert Position": "/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number}\n */\nvar searchInsert = function (nums, target) {\n    let left = 0;\n    let right = nums.length;\n    while (left < right) {\n        const mid = (left + right) >> 1;\n        if (nums[mid] >= target) {\n            right = mid;\n        } else {\n            left = mid + 1;\n        }\n    }\n    return left;\n};",
    "36. Valid Sudoku": "/**\n * @param {character[][]} board\n * @return {boolean}\n */\nvar isValidSudoku = function (board) {\n    const row = [...Array(9)].map(() => Array(9).fill(false));\n    const col = [...Array(9)].map(() => Array(9).fill(false));\n    const sub = [...Array(9)].map(() => Array(9).fill(false));\n    for (let i = 0; i < 9; ++i) {\n        for (let j = 0; j < 9; ++j) {\n            const num = board[i][j].charCodeAt() - '1'.charCodeAt();\n            if (num < 0 || num > 8) {\n                continue;\n            }\n            const k = Math.floor(i / 3) * 3 + Math.floor(j / 3);\n            if (row[i][num] || col[j][num] || sub[k][num]) {\n                return false;\n            }\n            row[i][num] = true;\n            col[j][num] = true;\n            sub[k][num] = true;\n        }\n    }\n    return true;\n};",
    "38. Count and Say": "const countAndSay = function (n) {\n    let s = '1';\n\n    for (let i = 2; i <= n; i++) {\n        let count = 1,\n            str = '',\n            len = s.length;\n\n        for (let j = 0; j < len; j++) {\n            if (j < len - 1 && s[j] === s[j + 1]) {\n                count++;\n            } else {\n                str += `${count}${s[j]}`;\n                count = 1;\n            }\n        }\n        s = str;\n    }\n    return s;\n};",
    "40. Combination Sum II": "/**\n * @param {number[]} candidates\n * @param {number} target\n * @return {number[][]}\n */\nvar combinationSum2 = function (candidates, target) {\n    candidates.sort((a, b) => a - b);\n    const ans = [];\n    const t = [];\n    const dfs = (i, s) => {\n        if (s === 0) {\n            ans.push(t.slice());\n            return;\n        }\n        if (i >= candidates.length || s < candidates[i]) {\n            return;\n        }\n        for (let j = i; j < candidates.length; ++j) {\n            if (j > i && candidates[j] === candidates[j - 1]) {\n                continue;\n            }\n            t.push(candidates[j]);\n            dfs(j + 1, s - candidates[j]);\n            t.pop();\n        }\n    };\n    dfs(0, target);\n    return ans;\n};",
    "46. Permutations": "/**\n * @param {number[]} nums\n * @return {number[][]}\n */\nvar permute = function (nums) {\n    const n = nums.length;\n    const ans = [];\n    const t = [];\n    const vis = new Array(n).fill(false);\n    function dfs(i) {\n        if (i >= n) {\n            ans.push([...t]);\n            return;\n        }\n        for (let j = 0; j < n; ++j) {\n            if (!vis[j]) {\n                vis[j] = true;\n                t.push(nums[j]);\n                dfs(i + 1);\n                vis[j] = false;\n                t.pop();\n            }\n        }\n    }\n    dfs(0);\n    return ans;\n};",
    "48. Rotate Image": "/**\n * @param {number[][]} matrix\n * @return {void} Do not return anything, modify matrix in-place instead.\n */\nvar rotate = function (matrix) {\n    matrix.reverse();\n    for (let i = 0; i < matrix.length; i++) {\n        for (let j = 0; j < i; j++) {\n            [matrix[i][j], matrix[j][i]] = [matrix[j][i], matrix[i][j]];\n        }\n    }\n};",
    "50. Pow(x, n)": "/**\n * @param {number} x\n * @param {number} n\n * @return {number}\n */\nvar myPow = function (x, n) {\n    const qpow = (a, n) => {\n        let ans = 1;\n        for (; n; n >>>= 1) {\n            if (n & 1) {\n                ans *= a;\n            }\n            a *= a;\n        }\n        return ans;\n    };\n    return n >= 0 ? qpow(x, n) : 1 / qpow(x, -n);\n};",
    "53. Maximum Subarray": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar maxSubArray = function (nums) {\n    let [ans, f] = [nums[0], nums[0]];\n    for (let i = 1; i < nums.length; ++i) {\n        f = Math.max(f, 0) + nums[i];\n        ans = Math.max(ans, f);\n    }\n    return ans;\n};",
    "54. Spiral Matrix": "/**\n * @param {number[][]} matrix\n * @return {number[]}\n */\nvar spiralOrder = function (matrix) {\n    const m = matrix.length;\n    const n = matrix[0].length;\n    const ans = [];\n    const vis = new Array(m).fill(0).map(() => new Array(n).fill(false));\n    const dirs = [0, 1, 0, -1, 0];\n    for (let h = m * n, i = 0, j = 0, k = 0; h > 0; --h) {\n        ans.push(matrix[i][j]);\n        vis[i][j] = true;\n        const x = i + dirs[k];\n        const y = j + dirs[k + 1];\n        if (x < 0 || x >= m || y < 0 || y >= n || vis[x][y]) {\n            k = (k + 1) % 4;\n        }\n        i += dirs[k];\n        j += dirs[k + 1];\n    }\n    return ans;\n};",
    "55. Jump Game": "/**\n * @param {number[]} nums\n * @return {boolean}\n */\nvar canJump = function (nums) {\n    let mx = 0;\n    for (let i = 0; i < nums.length; ++i) {\n        if (mx < i) {\n            return false;\n        }\n        mx = Math.max(mx, i + nums[i]);\n    }\n    return true;\n};",
    "58. Length of Last Word": "/**\n * @param {string} s\n * @return {number}\n */\nvar lengthOfLastWord = function (s) {\n    let i = s.length - 1;\n    while (i >= 0 && s[i] === ' ') {\n        --i;\n    }\n    let j = i;\n    while (j >= 0 && s[j] !== ' ') {\n        --j;\n    }\n    return i - j;\n};",
    "59. Spiral Matrix II": "/**\n * @param {number} n\n * @return {number[][]}\n */\nvar generateMatrix = function (n) {\n    const ans = new Array(n).fill(0).map(() => new Array(n).fill(0));\n    let [i, j, k] = [0, 0, 0];\n    const dirs = [\n        [0, 1],\n        [1, 0],\n        [0, -1],\n        [-1, 0],\n    ];\n    for (let v = 1; v <= n * n; ++v) {\n        ans[i][j] = v;\n        let [x, y] = [i + dirs[k][0], j + dirs[k][1]];\n        if (x < 0 || y < 0 || x >= n || y >= n || ans[x][y] > 0) {\n            k = (k + 1) % 4;\n            [x, y] = [i + dirs[k][0], j + dirs[k][1]];\n        }\n        [i, j] = [x, y];\n    }\n    return ans;\n};",
    "62. Unique Paths": "/**\n * @param {number} m\n * @param {number} n\n * @return {number}\n */\nvar uniquePaths = function (m, n) {\n    const f = Array(n).fill(1);\n    for (let i = 1; i < m; ++i) {\n        for (let j = 1; j < n; ++j) {\n            f[j] += f[j - 1];\n        }\n    }\n    return f[n - 1];\n};",
    "64. Minimum Path Sum": "/**\n * @param {number[][]} grid\n * @return {number}\n */\nvar minPathSum = function (grid) {\n    const m = grid.length;\n    const n = grid[0].length;\n    const f = Array(m)\n        .fill(0)\n        .map(() => Array(n).fill(0));\n    f[0][0] = grid[0][0];\n    for (let i = 1; i < m; ++i) {\n        f[i][0] = f[i - 1][0] + grid[i][0];\n    }\n    for (let j = 1; j < n; ++j) {\n        f[0][j] = f[0][j - 1] + grid[0][j];\n    }\n    for (let i = 1; i < m; ++i) {\n        for (let j = 1; j < n; ++j) {\n            f[i][j] = Math.min(f[i - 1][j], f[i][j - 1]) + grid[i][j];\n        }\n    }\n    return f[m - 1][n - 1];\n};",
    "66. Plus One": "/**\n * @param {number[]} digits\n * @return {number[]}\n */\nvar plusOne = function (digits) {\n    for (let i = digits.length - 1; i >= 0; --i) {\n        ++digits[i];\n        digits[i] %= 10;\n        if (digits[i] != 0) {\n            return digits;\n        }\n    }\n    return [1, ...digits];\n};",
    "70. Climbing Stairs": "/**\n * @param {number} n\n * @return {number}\n */\nvar climbStairs = function (n) {\n    let a = 0,\n        b = 1;\n    for (let i = 0; i < n; ++i) {\n        const c = a + b;\n        a = b;\n        b = c;\n    }\n    return b;\n};",
    "72. Edit Distance": "/**\n * @param {string} word1\n * @param {string} word2\n * @return {number}\n */\nvar minDistance = function (word1, word2) {\n    const m = word1.length;\n    const n = word2.length;\n    const f = Array(m + 1)\n        .fill(0)\n        .map(() => Array(n + 1).fill(0));\n    for (let j = 1; j <= n; ++j) {\n        f[0][j] = j;\n    }\n    for (let i = 1; i <= m; ++i) {\n        f[i][0] = i;\n        for (let j = 1; j <= n; ++j) {\n            if (word1[i - 1] === word2[j - 1]) {\n                f[i][j] = f[i - 1][j - 1];\n            } else {\n                f[i][j] = Math.min(f[i - 1][j], f[i][j - 1], f[i - 1][j - 1]) + 1;\n            }\n        }\n    }\n    return f[m][n];\n};",
    "73. Set Matrix Zeroes": "/**\n * @param {number[][]} matrix\n * @return {void} Do not return anything, modify matrix in-place instead.\n */\nvar setZeroes = function (matrix) {\n    const m = matrix.length;\n    const n = matrix[0].length;\n    let i0 = matrix[0].some(v => v == 0);\n    let j0 = false;\n    for (let i = 0; i < m; ++i) {\n        if (matrix[i][0] == 0) {\n            j0 = true;\n            break;\n        }\n    }\n    for (let i = 1; i < m; ++i) {\n        for (let j = 1; j < n; ++j) {\n            if (matrix[i][j] == 0) {\n                matrix[i][0] = 0;\n                matrix[0][j] = 0;\n            }\n        }\n    }\n    for (let i = 1; i < m; ++i) {\n        for (let j = 1; j < n; ++j) {\n            if (matrix[i][0] == 0 || matrix[0][j] == 0) {\n                matrix[i][j] = 0;\n            }\n        }\n    }\n    if (i0) {\n        for (let j = 0; j < n; ++j) {\n            matrix[0][j] = 0;\n        }\n    }\n    if (j0) {\n        for (let i = 0; i < m; ++i) {\n            matrix[i][0] = 0;\n        }\n    }\n};",
    "74. Search a 2D Matrix": "/**\n * @param {number[][]} matrix\n * @param {number} target\n * @return {boolean}\n */\nvar searchMatrix = function (matrix, target) {\n    const m = matrix.length,\n        n = matrix[0].length;\n    let left = 0,\n        right = m * n - 1;\n    while (left < right) {\n        const mid = (left + right + 1) >> 1;\n        const x = Math.floor(mid / n);\n        const y = mid % n;\n        if (matrix[x][y] <= target) {\n            left = mid;\n        } else {\n            right = mid - 1;\n        }\n    }\n    return matrix[Math.floor(left / n)][left % n] == target;\n};",
    "80. Remove Duplicates from Sorted Array II": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar removeDuplicates = function (nums) {\n    let k = 0;\n    for (const x of nums) {\n        if (k < 2 || x !== nums[k - 2]) {\n            nums[k++] = x;\n        }\n    }\n    return k;\n};",
    "82. Remove Duplicates from Sorted List II": "/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar deleteDuplicates = function (head) {\n    const dummy = new ListNode(0, head);\n    let pre = dummy;\n    let cur = head;\n    while (cur) {\n        while (cur.next && cur.val === cur.next.val) {\n            cur = cur.next;\n        }\n        if (pre.next === cur) {\n            pre = cur;\n        } else {\n            pre.next = cur.next;\n        }\n        cur = cur.next;\n    }\n    return dummy.next;\n};",
    "83. Remove Duplicates from Sorted List": "/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar deleteDuplicates = function (head) {\n    let cur = head;\n    while (cur && cur.next) {\n        if (cur.next.val === cur.val) {\n            cur.next = cur.next.next;\n        } else {\n            cur = cur.next;\n        }\n    }\n    return head;\n};",
    "86. Partition List": "/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} x\n * @return {ListNode}\n */\nvar partition = function (head, x) {\n    const d1 = new ListNode();\n    const d2 = new ListNode();\n    let t1 = d1,\n        t2 = d2;\n    while (head) {\n        if (head.val < x) {\n            t1.next = head;\n            t1 = t1.next;\n        } else {\n            t2.next = head;\n            t2 = t2.next;\n        }\n        head = head.next;\n    }\n    t1.next = d2.next;\n    t2.next = null;\n    return d1.next;\n};",
    "88. Merge Sorted Array": "/**\n * @param {number[]} nums1\n * @param {number} m\n * @param {number[]} nums2\n * @param {number} n\n * @return {void} Do not return anything, modify nums1 in-place instead.\n */\nvar merge = function (nums1, m, nums2, n) {\n    for (let i = m - 1, j = n - 1, k = m + n - 1; j >= 0; --k) {\n        nums1[k] = i >= 0 && nums1[i] > nums2[j] ? nums1[i--] : nums2[j--];\n    }\n};",
    "89. Gray Code": "/**\n * @param {number} n\n * @return {number[]}\n */\nvar grayCode = function (n) {\n    const ans = [];\n    for (let i = 0; i < 1 << n; ++i) {\n        ans.push(i ^ (i >> 1));\n    }\n    return ans;\n};",
    "92. Reverse Linked List II": "/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} left\n * @param {number} right\n * @return {ListNode}\n */\nvar reverseBetween = function (head, left, right) {\n    if (!head.next || left == right) {\n        return head;\n    }\n    const dummy = new ListNode(0, head);\n    let pre = dummy;\n    for (let i = 0; i < left - 1; ++i) {\n        pre = pre.next;\n    }\n    const p = pre;\n    const q = pre.next;\n    let cur = q;\n    for (let i = 0; i < right - left + 1; ++i) {\n        const t = cur.next;\n        cur.next = pre;\n        pre = cur;\n        cur = t;\n    }\n    p.next = pre;\n    q.next = cur;\n    return dummy.next;\n};",
    "94. Binary Tree Inorder Traversal": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number[]}\n */\nvar inorderTraversal = function (root) {\n    let ans = [];\n    while (root) {\n        if (!root.left) {\n            ans.push(root.val);\n            root = root.right;\n        } else {\n            let prev = root.left;\n            while (prev.right && prev.right != root) {\n                prev = prev.right;\n            }\n            if (!prev.right) {\n                prev.right = root;\n                root = root.left;\n            } else {\n                ans.push(root.val);\n                prev.right = null;\n                root = root.right;\n            }\n        }\n    }\n    return ans;\n};",
    "98. Validate Binary Search Tree": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {boolean}\n */\nvar isValidBST = function (root) {\n    let prev = null;\n\n    let dfs = function (root) {\n        if (!root) {\n            return true;\n        }\n        if (!dfs(root.left)) {\n            return false;\n        }\n        if (prev && prev.val >= root.val) {\n            return false;\n        }\n        prev = root;\n        if (!dfs(root.right)) {\n            return false;\n        }\n        return true;\n    };\n\n    return dfs(root);\n};",
    "99. Recover Binary Search Tree": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {void} Do not return anything, modify root in-place instead.\n */\nvar recoverTree = function (root) {\n    let prev = null;\n    let first = null;\n    let second = null;\n    function dfs(root) {\n        if (!root) {\n            return;\n        }\n        dfs(root.left);\n        if (prev && prev.val > root.val) {\n            if (!first) {\n                first = prev;\n            }\n            second = root;\n        }\n        prev = root;\n        dfs(root.right);\n    }\n    dfs(root);\n    const t = first.val;\n    first.val = second.val;\n    second.val = t;\n};",
    "100. Same Tree": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} p\n * @param {TreeNode} q\n * @return {boolean}\n */\nvar isSameTree = function (p, q) {\n    if (!p && !q) return true;\n    if (p && q) {\n        return p.val === q.val && isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n    }\n    return false;\n};",
    "101. Symmetric Tree": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {boolean}\n */\nvar isSymmetric = function (root) {\n    function dfs(root1, root2) {\n        if (!root1 && !root2) return true;\n        if (!root1 || !root2 || root1.val != root2.val) return false;\n        return dfs(root1.left, root2.right) && dfs(root1.right, root2.left);\n    }\n    return dfs(root, root);\n};",
    "102. Binary Tree Level Order Traversal": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number[][]}\n */\nvar levelOrder = function (root) {\n    let ans = [];\n    if (!root) {\n        return ans;\n    }\n    let q = [root];\n    while (q.length) {\n        let t = [];\n        for (let n = q.length; n; --n) {\n            const { val, left, right } = q.shift();\n            t.push(val);\n            left && q.push(left);\n            right && q.push(right);\n        }\n        ans.push(t);\n    }\n    return ans;\n};",
    "103. Binary Tree Zigzag Level Order Traversal": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number[][]}\n */\nvar zigzagLevelOrder = function (root) {\n    const ans = [];\n    if (!root) {\n        return ans;\n    }\n    const q = [root];\n    let left = 1;\n    while (q.length) {\n        const t = [];\n        for (let n = q.length; n; --n) {\n            const node = q.shift();\n            t.push(node.val);\n            if (node.left) {\n                q.push(node.left);\n            }\n            if (node.right) {\n                q.push(node.right);\n            }\n        }\n        if (!left) {\n            t.reverse();\n        }\n        ans.push(t);\n        left ^= 1;\n    }\n    return ans;\n};",
    "104. Maximum Depth of Binary Tree": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar maxDepth = function (root) {\n    if (!root) return 0;\n    const l = maxDepth(root.left);\n    const r = maxDepth(root.right);\n    return 1 + Math.max(l, r);\n};",
    "105. Construct Binary Tree from Preorder and Inorder Traversal": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {number[]} preorder\n * @param {number[]} inorder\n * @return {TreeNode}\n */\nvar buildTree = function (preorder, inorder) {\n    const d = new Map();\n    const n = inorder.length;\n    for (let i = 0; i < n; ++i) {\n        d.set(inorder[i], i);\n    }\n    const dfs = (i, j, n) => {\n        if (n <= 0) {\n            return null;\n        }\n        const v = preorder[i];\n        const k = d.get(v);\n        const l = dfs(i + 1, j, k - j);\n        const r = dfs(i + 1 + k - j, k + 1, n - 1 - (k - j));\n        return new TreeNode(v, l, r);\n    };\n    return dfs(0, 0, n);\n};",
    "107. Binary Tree Level Order Traversal II": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number[][]}\n */\nvar levelOrderBottom = function (root) {\n    const ans = [];\n    if (!root) return ans;\n    const q = [root];\n    while (q.length) {\n        const t = [];\n        for (let i = q.length; i > 0; --i) {\n            const node = q.shift();\n            t.push(node.val);\n            if (node.left) q.push(node.left);\n            if (node.right) q.push(node.right);\n        }\n        ans.unshift(t);\n    }\n    return ans;\n};",
    "108. Convert Sorted Array to Binary Search Tree": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {number[]} nums\n * @return {TreeNode}\n */\nvar sortedArrayToBST = function (nums) {\n    const dfs = (l, r) => {\n        if (l > r) {\n            return null;\n        }\n        const mid = (l + r) >> 1;\n        const left = dfs(l, mid - 1);\n        const right = dfs(mid + 1, r);\n        return new TreeNode(nums[mid], left, right);\n    };\n    return dfs(0, nums.length - 1);\n};",
    "109. Convert Sorted List to Binary Search Tree": "/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {TreeNode}\n */\nvar sortedListToBST = function (head) {\n    const buildBST = (nums, start, end) => {\n        if (start > end) {\n            return null;\n        }\n        const mid = (start + end) >> 1;\n        const root = new TreeNode(nums[mid]);\n        root.left = buildBST(nums, start, mid - 1);\n        root.right = buildBST(nums, mid + 1, end);\n        return root;\n    };\n\n    const nums = new Array();\n    for (; head != null; head = head.next) {\n        nums.push(head.val);\n    }\n    return buildBST(nums, 0, nums.length - 1);\n};",
    "110. Balanced Binary Tree": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {boolean}\n */\nvar isBalanced = function (root) {\n    const height = root => {\n        if (!root) {\n            return 0;\n        }\n        const l = height(root.left);\n        const r = height(root.right);\n        if (l == -1 || r == -1 || Math.abs(l - r) > 1) {\n            return -1;\n        }\n        return 1 + Math.max(l, r);\n    };\n    return height(root) >= 0;\n};",
    "111. Minimum Depth of Binary Tree": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar minDepth = function (root) {\n    if (!root) {\n        return 0;\n    }\n    if (!root.left) {\n        return 1 + minDepth(root.right);\n    }\n    if (!root.right) {\n        return 1 + minDepth(root.left);\n    }\n    return 1 + Math.min(minDepth(root.left), minDepth(root.right));\n};",
    "112. Path Sum": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @param {number} targetSum\n * @return {boolean}\n */\nvar hasPathSum = function (root, targetSum) {\n    function dfs(root, s) {\n        if (!root) return false;\n        s += root.val;\n        if (!root.left && !root.right && s == targetSum) return true;\n        return dfs(root.left, s) || dfs(root.right, s);\n    }\n    return dfs(root, 0);\n};",
    "113. Path Sum II": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @param {number} targetSum\n * @return {number[][]}\n */\nvar pathSum = function (root, targetSum) {\n    const ans = [];\n    const t = [];\n    function dfs(root, s) {\n        if (!root) return;\n        s -= root.val;\n        t.push(root.val);\n        if (!root.left && !root.right && s == 0) ans.push([...t]);\n        dfs(root.left, s);\n        dfs(root.right, s);\n        t.pop();\n    }\n    dfs(root, targetSum);\n    return ans;\n};",
    "114. Flatten Binary Tree to Linked List": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {void} Do not return anything, modify root in-place instead.\n */\nvar flatten = function (root) {\n    while (root) {\n        if (root.left) {\n            let pre = root.left;\n            while (pre.right) {\n                pre = pre.right;\n            }\n            pre.right = root.right;\n            root.right = root.left;\n            root.left = null;\n        }\n        root = root.right;\n    }\n};",
    "118. Pascal's Triangle": "/**\n * @param {number} numRows\n * @return {number[][]}\n */\nvar generate = function (numRows) {\n    const f = [[1]];\n    for (let i = 0; i < numRows - 1; ++i) {\n        const g = [1];\n        for (let j = 0; j < f[i].length - 1; ++j) {\n            g.push(f[i][j] + f[i][j + 1]);\n        }\n        g.push(1);\n        f.push(g);\n    }\n    return f;\n};",
    "121. Best Time to Buy and Sell Stock": "/**\n * @param {number[]} prices\n * @return {number}\n */\nvar maxProfit = function (prices) {\n    let ans = 0;\n    let mi = prices[0];\n    for (const v of prices) {\n        ans = Math.max(ans, v - mi);\n        mi = Math.min(mi, v);\n    }\n    return ans;\n};",
    "122. Best Time to Buy and Sell Stock II": "/**\n * @param {number[]} prices\n * @return {number}\n */\nvar maxProfit = function (prices) {\n    let ans = 0;\n    for (let i = 1; i < prices.length; i++) {\n        ans += Math.max(0, prices[i] - prices[i - 1]);\n    }\n    return ans;\n};",
    "124. Binary Tree Maximum Path Sum": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar maxPathSum = function (root) {\n    let ans = -1001;\n    const dfs = root => {\n        if (!root) {\n            return 0;\n        }\n        const left = Math.max(0, dfs(root.left));\n        const right = Math.max(0, dfs(root.right));\n        ans = Math.max(ans, left + right + root.val);\n        return Math.max(left, right) + root.val;\n    };\n    dfs(root);\n    return ans;\n};",
    "125. Valid Palindrome": "/**\n * @param {string} s\n * @return {boolean}\n */\nvar isPalindrome = function (s) {\n    let i = 0;\n    let j = s.length - 1;\n    while (i < j) {\n        if (!/[a-zA-Z0-9]/.test(s[i])) {\n            ++i;\n        } else if (!/[a-zA-Z0-9]/.test(s[j])) {\n            --j;\n        } else if (s[i].toLowerCase() !== s[j].toLowerCase()) {\n            return false;\n        } else {\n            ++i;\n            --j;\n        }\n    }\n    return true;\n};",
    "128. Longest Consecutive Sequence": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar longestConsecutive = function (nums) {\n    const s = new Set(nums);\n    let ans = 0;\n    for (const x of nums) {\n        if (!s.has(x - 1)) {\n            let y = x + 1;\n            while (s.has(y)) {\n                y++;\n            }\n            ans = Math.max(ans, y - x);\n        }\n    }\n    return ans;\n};",
    "129. Sum Root to Leaf Numbers": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar sumNumbers = function (root) {\n    function dfs(root, s) {\n        if (!root) return 0;\n        s = s * 10 + root.val;\n        if (!root.left && !root.right) return s;\n        return dfs(root.left, s) + dfs(root.right, s);\n    }\n    return dfs(root, 0);\n};",
    "136. Single Number": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar singleNumber = function (nums) {\n    return nums.reduce((a, b) => a ^ b);\n};",
    "138. Copy List with Random Pointer": "/**\n * // Definition for a Node.\n * function Node(val, next, random) {\n *    this.val = val;\n *    this.next = next;\n *    this.random = random;\n * };\n */\n\n/**\n * @param {Node} head\n * @return {Node}\n */\nvar copyRandomList = function (head) {\n    if (!head) {\n        return null;\n    }\n    for (let cur = head; cur; ) {\n        const node = new Node(cur.val, cur.next, null);\n        cur.next = node;\n        cur = node.next;\n    }\n    for (let cur = head; cur; cur = cur.next.next) {\n        if (cur.random) {\n            cur.next.random = cur.random.next;\n        }\n    }\n    const ans = head.next;\n    for (let cur = head; cur; ) {\n        const nxt = cur.next;\n        if (nxt) {\n            cur.next = nxt.next;\n        }\n        cur = nxt;\n    }\n    return ans;\n};",
    "141. Linked List Cycle": "/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n\n/**\n * @param {ListNode} head\n * @return {boolean}\n */\nvar hasCycle = function (head) {\n    let slow = head;\n    let fast = head;\n    while (fast && fast.next) {\n        slow = slow.next;\n        fast = fast.next.next;\n        if (slow === fast) {\n            return true;\n        }\n    }\n    return false;\n};",
    "142. Linked List Cycle II": "/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar detectCycle = function (head) {\n    let [slow, fast] = [head, head];\n    while (fast && fast.next) {\n        slow = slow.next;\n        fast = fast.next.next;\n        if (slow === fast) {\n            let ans = head;\n            while (ans !== slow) {\n                ans = ans.next;\n                slow = slow.next;\n            }\n            return ans;\n        }\n    }\n    return null;\n};",
    "143. Reorder List": "/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {void} Do not return anything, modify head in-place instead.\n */\nvar reorderList = function (head) {\n    let slow = head;\n    let fast = head;\n    while (fast.next && fast.next.next) {\n        slow = slow.next;\n        fast = fast.next.next;\n    }\n\n    let cur = slow.next;\n    slow.next = null;\n\n    let pre = null;\n    while (cur) {\n        const t = cur.next;\n        cur.next = pre;\n        pre = cur;\n        cur = t;\n    }\n    cur = head;\n\n    while (pre) {\n        const t = pre.next;\n        pre.next = cur.next;\n        cur.next = pre;\n        cur = pre.next;\n        pre = t;\n    }\n};",
    "147. Insertion Sort List": "/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar insertionSortList = function (head) {\n    if (head == null || head.next == null) return head;\n    let dummy = new ListNode(head.val, head);\n    let prev = dummy,\n        cur = head;\n    while (cur != null) {\n        if (prev.val <= cur.val) {\n            prev = cur;\n            cur = cur.next;\n            continue;\n        }\n        let p = dummy;\n        while (p.next.val <= cur.val) {\n            p = p.next;\n        }\n        let t = cur.next;\n        cur.next = p.next;\n        p.next = cur;\n        prev.next = t;\n        cur = t;\n    }\n    return dummy.next;\n};",
    "148. Sort List": "/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar sortList = function (head) {\n    if (!head || !head.next) {\n        return head;\n    }\n    let slow = head;\n    let fast = head.next;\n    while (fast && fast.next) {\n        slow = slow.next;\n        fast = fast.next.next;\n    }\n    let t = slow.next;\n    slow.next = null;\n    let l1 = sortList(head);\n    let l2 = sortList(t);\n    const dummy = new ListNode();\n    let cur = dummy;\n    while (l1 && l2) {\n        if (l1.val <= l2.val) {\n            cur.next = l1;\n            l1 = l1.next;\n        } else {\n            cur.next = l2;\n            l2 = l2.next;\n        }\n        cur = cur.next;\n    }\n    cur.next = l1 || l2;\n    return dummy.next;\n};",
    "152. Maximum Product Subarray": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar maxProduct = function (nums) {\n    let [f, g, ans] = [nums[0], nums[0], nums[0]];\n    for (let i = 1; i < nums.length; ++i) {\n        const [ff, gg] = [f, g];\n        f = Math.max(nums[i], ff * nums[i], gg * nums[i]);\n        g = Math.min(nums[i], ff * nums[i], gg * nums[i]);\n        ans = Math.max(ans, f);\n    }\n    return ans;\n};",
    "153. Find Minimum in Rotated Sorted Array": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findMin = function (nums) {\n    const n = nums.length;\n    if (nums[0] <= nums[n - 1]) {\n        return nums[0];\n    }\n    let left = 0,\n        right = n - 1;\n    while (left < right) {\n        const mid = (left + right) >> 1;\n        if (nums[0] <= nums[mid]) {\n            left = mid + 1;\n        } else {\n            right = mid;\n        }\n    }\n    return nums[left];\n};",
    "154. Find Minimum in Rotated Sorted Array II": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findMin = function (nums) {\n    let left = 0,\n        right = nums.length - 1;\n    while (left < right) {\n        const mid = (left + right) >> 1;\n        if (nums[mid] > nums[right]) {\n            left = mid + 1;\n        } else if (nums[mid] < nums[right]) {\n            right = mid;\n        } else {\n            --right;\n        }\n    }\n    return nums[left];\n};",
    "155. Min Stack": "var MinStack = function () {\n    this.stk1 = [];\n    this.stk2 = [Infinity];\n};\n\n/**\n * @param {number} val\n * @return {void}\n */\nMinStack.prototype.push = function (val) {\n    this.stk1.push(val);\n    this.stk2.push(Math.min(this.stk2[this.stk2.length - 1], val));\n};\n\n/**\n * @return {void}\n */\nMinStack.prototype.pop = function () {\n    this.stk1.pop();\n    this.stk2.pop();\n};\n\n/**\n * @return {number}\n */\nMinStack.prototype.top = function () {\n    return this.stk1[this.stk1.length - 1];\n};\n\n/**\n * @return {number}\n */\nMinStack.prototype.getMin = function () {\n    return this.stk2[this.stk2.length - 1];\n};\n\n/**\n * Your MinStack object will be instantiated and called as such:\n * var obj = new MinStack()\n * obj.push(val)\n * obj.pop()\n * var param_3 = obj.top()\n * var param_4 = obj.getMin()\n */",
    "160. Intersection of Two Linked Lists": "/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n\n/**\n * @param {ListNode} headA\n * @param {ListNode} headB\n * @return {ListNode}\n */\nvar getIntersectionNode = function (headA, headB) {\n    let a = headA;\n    let b = headB;\n    while (a != b) {\n        a = a ? a.next : headB;\n        b = b ? b.next : headA;\n    }\n    return a;\n};",
    "167. Two Sum II - Input array is sorted": "/**\n * @param {number[]} numbers\n * @param {number} target\n * @return {number[]}\n */\nvar twoSum = function (numbers, target) {\n    let i = 1,\n        j = numbers.length;\n    while (i < j) {\n        const x = numbers[i - 1] + numbers[j - 1];\n        if (x == target) {\n            return [i, j];\n        }\n        if (x < target) {\n            ++i;\n        } else {\n            --j;\n        }\n    }\n    return [-1, -1];\n};",
    "169. Majority Element": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar majorityElement = function (nums) {\n    let cnt = 0;\n    let m = 0;\n    for (const x of nums) {\n        if (cnt === 0) {\n            m = x;\n            cnt = 1;\n        } else {\n            cnt += m === x ? 1 : -1;\n        }\n    }\n    return m;\n};",
    "173. Binary Search Tree Iterator": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n */\nvar BSTIterator = function (root) {\n    this.stack = [];\n    for (; root != null; root = root.left) {\n        this.stack.push(root);\n    }\n};\n\n/**\n * @return {number}\n */\nBSTIterator.prototype.next = function () {\n    let cur = this.stack.pop();\n    let node = cur.right;\n    for (; node != null; node = node.left) {\n        this.stack.push(node);\n    }\n    return cur.val;\n};\n\n/**\n * @return {boolean}\n */\nBSTIterator.prototype.hasNext = function () {\n    return this.stack.length > 0;\n};\n\n/**\n * Your BSTIterator object will be instantiated and called as such:\n * var obj = new BSTIterator(root)\n * var param_1 = obj.next()\n * var param_2 = obj.hasNext()\n */",
    "187. Repeated DNA Sequences": "/**\n * @param {string} s\n * @return {string[]}\n */\nvar findRepeatedDnaSequences = function (s) {\n    const cnt = new Map();\n    const ans = [];\n    for (let i = 0; i < s.length - 10 + 1; ++i) {\n        const t = s.slice(i, i + 10);\n        cnt.set(t, (cnt.get(t) || 0) + 1);\n        if (cnt.get(t) === 2) {\n            ans.push(t);\n        }\n    }\n    return ans;\n};",
    "189. Rotate Array": "/**\n * @param {number[]} nums\n * @param {number} k\n * @return {void} Do not return anything, modify nums in-place instead.\n */\nvar rotate = function (nums, k) {\n    const n = nums.length;\n    k %= n;\n    const reverse = (i, j) => {\n        for (; i < j; ++i, --j) {\n            [nums[i], nums[j]] = [nums[j], nums[i]];\n        }\n    };\n    reverse(0, n - 1);\n    reverse(0, k - 1);\n    reverse(k, n - 1);\n};",
    "190. Reverse Bits": "/**\n * @param {number} n - a positive integer\n * @return {number} - a positive integer\n */\nvar reverseBits = function (n) {\n    let res = 0;\n    for (let i = 0; i < 32 && n > 0; ++i) {\n        res |= (n & 1) << (31 - i);\n        n >>>= 1;\n    }\n    return res >>> 0;\n};",
    "191. Number of 1 Bits": "/**\n * @param {number} n - a positive integer\n * @return {number}\n */\nvar hammingWeight = function (n) {\n    let ans = 0;\n    while (n) {\n        n &= n - 1;\n        ++ans;\n    }\n    return ans;\n};",
    "201. Bitwise AND of Numbers Range": "/**\n * @param {number} left\n * @param {number} right\n * @return {number}\n */\nvar rangeBitwiseAnd = function (left, right) {\n    while (left < right) {\n        right &= right - 1;\n    }\n    return right;\n};",
    "204. Count Primes": "/**\n * @param {number} n\n * @return {number}\n */\nvar countPrimes = function (n) {\n    let primes = new Array(n).fill(true);\n    let ans = 0;\n    for (let i = 2; i < n; ++i) {\n        if (primes[i]) {\n            ++ans;\n            for (let j = i + i; j < n; j += i) {\n                primes[j] = false;\n            }\n        }\n    }\n    return ans;\n};",
    "206. Reverse Linked List": "/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar reverseList = function (head) {\n    let dummy = new ListNode();\n    let curr = head;\n    while (curr) {\n        let next = curr.next;\n        curr.next = dummy.next;\n        dummy.next = curr;\n        curr = next;\n    }\n    return dummy.next;\n};",
    "208. Implement Trie (Prefix Tree)": "/**\n * Initialize your data structure here.\n */\nvar Trie = function () {\n    this.children = {};\n};\n\n/**\n * Inserts a word into the trie.\n * @param {string} word\n * @return {void}\n */\nTrie.prototype.insert = function (word) {\n    let node = this.children;\n    for (let char of word) {\n        if (!node[char]) {\n            node[char] = {};\n        }\n        node = node[char];\n    }\n    node.isEnd = true;\n};\n\n/**\n * Returns if the word is in the trie.\n * @param {string} word\n * @return {boolean}\n */\nTrie.prototype.search = function (word) {\n    let node = this.searchPrefix(word);\n    return node != undefined && node.isEnd != undefined;\n};\n\nTrie.prototype.searchPrefix = function (prefix) {\n    let node = this.children;\n    for (let char of prefix) {\n        if (!node[char]) return false;\n        node = node[char];\n    }\n    return node;\n};\n\n/**\n * Returns if there is any word in the trie that starts with the given prefix.\n * @param {string} prefix\n * @return {boolean}\n */\nTrie.prototype.startsWith = function (prefix) {\n    return this.searchPrefix(prefix);\n};\n\n/**\n * Your Trie object will be instantiated and called as such:\n * var obj = new Trie()\n * obj.insert(word)\n * var param_2 = obj.search(word)\n * var param_3 = obj.startsWith(prefix)\n */",
    "217. Contains Duplicate": "/**\n * @param {number[]} nums\n * @return {boolean}\n */\nvar containsDuplicate = function (nums) {\n    return new Set(nums).size !== nums.length;\n};",
    "222. Count Complete Tree Nodes": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar countNodes = function (root) {\n    const depth = root => {\n        let d = 0;\n        for (; root; root = root.left) {\n            ++d;\n        }\n        return d;\n    };\n    if (!root) {\n        return 0;\n    }\n    const left = depth(root.left);\n    const right = depth(root.right);\n    if (left == right) {\n        return (1 << left) + countNodes(root.right);\n    }\n    return (1 << right) + countNodes(root.left);\n};",
    "226. Invert Binary Tree": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {TreeNode}\n */\nvar invertTree = function (root) {\n    const dfs = root => {\n        if (!root) {\n            return;\n        }\n        [root.left, root.right] = [root.right, root.left];\n        dfs(root.left);\n        dfs(root.right);\n    };\n    dfs(root);\n    return root;\n};",
    "231. Power of Two": "/**\n * @param {number} n\n * @return {boolean}\n */\nvar isPowerOfTwo = function (n) {\n    return n > 0 && (n & (n - 1)) == 0;\n};",
    "234. Palindrome Linked List": "/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {boolean}\n */\nvar isPalindrome = function (head) {\n    let slow = head;\n    let fast = head.next;\n    while (fast && fast.next) {\n        slow = slow.next;\n        fast = fast.next.next;\n    }\n    let cur = slow.next;\n    slow.next = null;\n    let pre = null;\n    while (cur) {\n        let t = cur.next;\n        cur.next = pre;\n        pre = cur;\n        cur = t;\n    }\n    while (pre) {\n        if (pre.val !== head.val) {\n            return false;\n        }\n        pre = pre.next;\n        head = head.next;\n    }\n    return true;\n};",
    "236. Lowest Common Ancestor of a Binary Tree": "/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @param {TreeNode} p\n * @param {TreeNode} q\n * @return {TreeNode}\n */\nvar lowestCommonAncestor = function (root, p, q) {\n    if (!root || root == p || root == q) return root;\n    const left = lowestCommonAncestor(root.left, p, q);\n    const right = lowestCommonAncestor(root.right, p, q);\n    if (!left) return right;\n    if (!right) return left;\n    return root;\n};",
    "237. Delete Node in a Linked List": "/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n/**\n * @param {ListNode} node\n * @return {void} Do not return anything, modify node in-place instead.\n */\nvar deleteNode = function (node) {\n    node.val = node.next.val;\n    node.next = node.next.next;\n};",
    "238. Product of Array Except Self": "/**\n * @param {number[]} nums\n * @return {number[]}\n */\nvar productExceptSelf = function (nums) {\n    const n = nums.length;\n    const ans = new Array(n);\n    for (let i = 0, left = 1; i < n; ++i) {\n        ans[i] = left;\n        left *= nums[i];\n    }\n    for (let i = n - 1, right = 1; i >= 0; --i) {\n        ans[i] *= right;\n        right *= nums[i];\n    }\n    return ans;\n};",
    "239. Sliding Window Maximum": "/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number[]}\n */\nvar maxSlidingWindow = function (nums, k) {\n    let ans = [];\n    let q = [];\n    for (let i = 0; i < nums.length; ++i) {\n        if (q && i - k + 1 > q[0]) {\n            q.shift();\n        }\n        while (q && nums[q[q.length - 1]] <= nums[i]) {\n            q.pop();\n        }\n        q.push(i);\n        if (i >= k - 1) {\n            ans.push(nums[q[0]]);\n        }\n    }\n    return ans;\n};",
    "240. Search a 2D Matrix II": "/**\n * @param {number[][]} matrix\n * @param {number} target\n * @return {boolean}\n */\nvar searchMatrix = function (matrix, target) {\n    const n = matrix[0].length;\n    for (const row of matrix) {\n        let left = 0,\n            right = n;\n        while (left < right) {\n            const mid = (left + right) >> 1;\n            if (row[mid] >= target) {\n                right = mid;\n            } else {\n                left = mid + 1;\n            }\n        }\n        if (left != n && row[left] == target) {\n            return true;\n        }\n    }\n    return false;\n};",
    "242. Valid Anagram": "/**\n * @param {string} s\n * @param {string} t\n * @return {boolean}\n */\nvar isAnagram = function (s, t) {\n    if (s.length !== t.length) {\n        return false;\n    }\n    const cnt = new Array(26).fill(0);\n    for (let i = 0; i < s.length; ++i) {\n        ++cnt[s.charCodeAt(i) - 'a'.charCodeAt(0)];\n        --cnt[t.charCodeAt(i) - 'a'.charCodeAt(0)];\n    }\n    return cnt.every(x => x === 0);\n};",
    "260. Single Number III": "/**\n * @param {number[]} nums\n * @return {number[]}\n */\nvar singleNumber = function (nums) {\n    const xs = nums.reduce((a, b) => a ^ b);\n    const lb = xs & -xs;\n    let a = 0;\n    for (const x of nums) {\n        if (x & lb) {\n            a ^= x;\n        }\n    }\n    const b = xs ^ a;\n    return [a, b];\n};",
    "263. Ugly Number": "/**\n * @param {number} n\n * @return {boolean}\n */\nvar isUgly = function (n) {\n    if (n < 1) return false;\n    while (n % 2 === 0) {\n        n /= 2;\n    }\n    while (n % 3 === 0) {\n        n /= 3;\n    }\n    while (n % 5 === 0) {\n        n /= 5;\n    }\n    return n === 1;\n};",
    "264. Ugly Number II": "/**\n * @param {number} n\n * @return {number}\n */\nvar nthUglyNumber = function (n) {\n    let dp = [1];\n    let p2 = 0,\n        p3 = 0,\n        p5 = 0;\n    for (let i = 1; i < n; ++i) {\n        const next2 = dp[p2] * 2,\n            next3 = dp[p3] * 3,\n            next5 = dp[p5] * 5;\n        dp[i] = Math.min(next2, Math.min(next3, next5));\n        if (dp[i] == next2) ++p2;\n        if (dp[i] == next3) ++p3;\n        if (dp[i] == next5) ++p5;\n        dp.push(dp[i]);\n    }\n    return dp[n - 1];\n};",
    "268. Missing Number": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar missingNumber = function (nums) {\n    const n = nums.length;\n    let ans = n;\n    for (let i = 0; i < n; ++i) {\n        ans ^= i ^ nums[i];\n    }\n    return ans;\n};",
    "278. First Bad Version": "/**\n * Definition for isBadVersion()\n *\n * @param {integer} version number\n * @return {boolean} whether the version is bad\n * isBadVersion = function(version) {\n *     ...\n * };\n */\n\n/**\n * @param {function} isBadVersion()\n * @return {function}\n */\nvar solution = function (isBadVersion) {\n    /**\n     * @param {integer} n Total versions\n     * @return {integer} The first bad version\n     */\n    return function (n) {\n        let left = 1;\n        let right = n;\n        while (left < right) {\n            const mid = (left + right) >>> 1;\n            if (isBadVersion(mid)) {\n                right = mid;\n            } else {\n                left = mid + 1;\n            }\n        }\n        return left;\n    };\n};",
    "283. Move Zeroes": "/**\n * @param {number[]} nums\n * @return {void} Do not return anything, modify nums in-place instead.\n */\nvar moveZeroes = function (nums) {\n    let i = -1;\n    for (let j = 0; j < nums.length; ++j) {\n        if (nums[j]) {\n            const t = nums[++i];\n            nums[i] = nums[j];\n            nums[j] = t;\n        }\n    }\n};",
    "287. Find the Duplicate Number": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findDuplicate = function (nums) {\n    let l = 0;\n    let r = nums.length - 1;\n    while (l < r) {\n        const mid = (l + r) >> 1;\n        let cnt = 0;\n        for (const v of nums) {\n            if (v <= mid) {\n                ++cnt;\n            }\n        }\n        if (cnt > mid) {\n            r = mid;\n        } else {\n            l = mid + 1;\n        }\n    }\n    return l;\n};",
    "295. Find Median from Data Stream": "/**\n * initialize your data structure here.\n */\nvar MedianFinder = function () {\n    this.val = [];\n};\n\n/**\n * @param {number} num\n * @return {void}\n */\nMedianFinder.prototype.addNum = function (num) {\n    let left = 0;\n    let right = this.val.length;\n    while (left < right) {\n        let mid = left + ~~((right - left) / 2);\n        if (num > this.val[mid]) {\n            left = mid + 1;\n        } else {\n            right = mid;\n        }\n    }\n    this.val.splice(left, 0, num);\n};\n\n/**\n * @return {number}\n */\nMedianFinder.prototype.findMedian = function () {\n    let mid = ~~(this.val.length / 2);\n    return this.val.length % 2 ? this.val[mid] : (this.val[mid - 1] + this.val[mid]) / 2;\n};",
    "297. Serialize and Deserialize Binary Tree": "/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n\n/**\n * Encodes a tree to a single string.\n *\n * @param {TreeNode} root\n * @return {string}\n */\nvar serialize = function (root) {\n    return rserialize(root, '');\n};\n\n/**\n * Decodes your encoded data to tree.\n *\n * @param {string} data\n * @return {TreeNode}\n */\nvar deserialize = function (data) {\n    const dataArray = data.split(',');\n    return rdeserialize(dataArray);\n};\n\nconst rserialize = (root, str) => {\n    if (root === null) {\n        str += '#,';\n    } else {\n        str += root.val + '' + ',';\n        str = rserialize(root.left, str);\n        str = rserialize(root.right, str);\n    }\n    return str;\n};\n\nconst rdeserialize = dataList => {\n    if (dataList[0] === '#') {\n        dataList.shift();\n        return null;\n    }\n\n    const root = new TreeNode(parseInt(dataList[0]));\n    dataList.shift();\n    root.left = rdeserialize(dataList);\n    root.right = rdeserialize(dataList);\n\n    return root;\n};\n\n/**\n * Your functions will be called as such:\n * deserialize(serialize(root));\n */"
}