{
    "1. Two Sum": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> m = new HashMap<>();\n        for (int i = 0;; ++i) {\n            int x = nums[i];\n            int y = target - x;\n            if (m.containsKey(y)) {\n                return new int[] {m.get(y), i};\n            }\n            m.put(x, i);\n        }\n    }\n}",
    "2. Add Two Numbers": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n        ListNode dummy = new ListNode(0);\n        int carry = 0;\n        ListNode cur = dummy;\n        while (l1 != null || l2 != null || carry != 0) {\n            int s = (l1 == null ? 0 : l1.val) + (l2 == null ? 0 : l2.val) + carry;\n            carry = s / 10;\n            cur.next = new ListNode(s % 10);\n            cur = cur.next;\n            l1 = l1 == null ? null : l1.next;\n            l2 = l2 == null ? null : l2.next;\n        }\n        return dummy.next;\n    }\n}",
    "4. Median of Two Sorted Arrays": "class Solution {\n    private int m;\n    private int n;\n    private int[] nums1;\n    private int[] nums2;\n\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\n        m = nums1.length;\n        n = nums2.length;\n        this.nums1 = nums1;\n        this.nums2 = nums2;\n        int a = f(0, 0, (m + n + 1) / 2);\n        int b = f(0, 0, (m + n + 2) / 2);\n        return (a + b) / 2.0;\n    }\n\n    private int f(int i, int j, int k) {\n        if (i >= m) {\n            return nums2[j + k - 1];\n        }\n        if (j >= n) {\n            return nums1[i + k - 1];\n        }\n        if (k == 1) {\n            return Math.min(nums1[i], nums2[j]);\n        }\n        int p = k / 2;\n        int x = i + p - 1 < m ? nums1[i + p - 1] : 1 << 30;\n        int y = j + p - 1 < n ? nums2[j + p - 1] : 1 << 30;\n        return x < y ? f(i + p, j, k - p) : f(i, j + p, k - p);\n    }\n}",
    "5. Longest Palindromic Substring": "class Solution {\n    public String longestPalindrome(String s) {\n        int n = s.length();\n        boolean[][] f = new boolean[n][n];\n        for (var g : f) {\n            Arrays.fill(g, true);\n        }\n        int k = 0, mx = 1;\n        for (int i = n - 2; i >= 0; --i) {\n            for (int j = i + 1; j < n; ++j) {\n                f[i][j] = false;\n                if (s.charAt(i) == s.charAt(j)) {\n                    f[i][j] = f[i + 1][j - 1];\n                    if (f[i][j] && mx < j - i + 1) {\n                        mx = j - i + 1;\n                        k = i;\n                    }\n                }\n            }\n        }\n        return s.substring(k, k + mx);\n    }\n}",
    "6. ZigZag Conversion": "public class ZigZag_Conversion {\n\n    public class Solution {\n        public String convert(String s, int nRows) {\n            if (s == null || s.length() <= nRows || nRows == 1) {\n                return s;\n            }\n            StringBuilder sb = new StringBuilder();\n            for (int i = 0; i < nRows; i++) {\n                if (i == 0 || i == nRows - 1) {\n                    int index = i;\n                    while (index < s.length()) {\n                        sb.append(s.charAt(index));\n                        index += 2 * (nRows - 1);\n                    }\n                } else {\n                    int index = i;\n                    while (index < s.length()) {\n                        sb.append(s.charAt(index));\n                        if (index + 2 * nRows - 2 * i - 2 < s.length()) {\n                            sb.append(s.charAt(index + 2 * nRows - 2 * i - 2));\n                        }\n                        index += 2 * (nRows - 1);\n                    }\n                }\n            }\n            return sb.toString();\n        }\n    }\n}\n\n############\n\nclass Solution {\n    public String convert(String s, int numRows) {\n        if (numRows == 1) {\n            return s;\n        }\n        StringBuilder ans = new StringBuilder();\n        int group = 2 * numRows - 2;\n        for (int i = 1; i <= numRows; i++) {\n            int interval = i == numRows ? group : 2 * numRows - 2 * i;\n            int idx = i - 1;\n            while (idx < s.length()) {\n                ans.append(s.charAt(idx));\n                idx += interval;\n                interval = group - interval;\n                if (interval == 0) {\n                    interval = group;\n                }\n            }\n        }\n        return ans.toString();\n    }\n}",
    "7. Reverse Integer": "class Solution {\n    public int reverse(int x) {\n        int ans = 0;\n        for (; x != 0; x /= 10) {\n            if (ans < Integer.MIN_VALUE / 10 || ans > Integer.MAX_VALUE / 10) {\n                return 0;\n            }\n            ans = ans * 10 + x % 10;\n        }\n        return ans;\n    }\n}",
    "9. Palindrome Number": "class Solution {\n    public boolean isPalindrome(int x) {\n        if (x < 0 || (x > 0 && x % 10 == 0)) {\n            return false;\n        }\n        int y = 0;\n        for (; y < x; x /= 10) {\n            y = y * 10 + x % 10;\n        }\n        return x == y || x == y / 10;\n    }\n}",
    "10. Regular Expression Matching": "class Solution {\n    public boolean isMatch(String s, String p) {\n        int m = s.length(), n = p.length();\n        boolean[][] f = new boolean[m + 1][n + 1];\n        f[0][0] = true;\n        for (int i = 0; i <= m; ++i) {\n            for (int j = 1; j <= n; ++j) {\n                if (p.charAt(j - 1) == '*') {\n                    f[i][j] = f[i][j - 2];\n                    if (i > 0 && (p.charAt(j - 2) == '.' || p.charAt(j - 2) == s.charAt(i - 1))) {\n                        f[i][j] |= f[i - 1][j];\n                    }\n                } else if (i > 0\n                    && (p.charAt(j - 1) == '.' || p.charAt(j - 1) == s.charAt(i - 1))) {\n                    f[i][j] = f[i - 1][j - 1];\n                }\n            }\n        }\n        return f[m][n];\n    }\n}",
    "11. Container With Most Water": "class Solution {\n    public int maxArea(int[] height) {\n        int i = 0, j = height.length - 1;\n        int ans = 0;\n        while (i < j) {\n            int t = Math.min(height[i], height[j]) * (j - i);\n            ans = Math.max(ans, t);\n            if (height[i] < height[j]) {\n                ++i;\n            } else {\n                --j;\n            }\n        }\n        return ans;\n    }\n}",
    "12. Integer to Roman": "class Solution {\n    public String intToRoman(int num) {\n        List<String> cs\n            = List.of(\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\");\n        List<Integer> vs = List.of(1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1);\n        StringBuilder ans = new StringBuilder();\n        for (int i = 0, n = cs.size(); i < n; ++i) {\n            while (num >= vs.get(i)) {\n                num -= vs.get(i);\n                ans.append(cs.get(i));\n            }\n        }\n        return ans.toString();\n    }\n}",
    "13. Roman to Integer": "class Solution {\n    public int romanToInt(String s) {\n        String cs = \"IVXLCDM\";\n        int[] vs = {1, 5, 10, 50, 100, 500, 1000};\n        Map<Character, Integer> d = new HashMap<>();\n        for (int i = 0; i < vs.length; ++i) {\n            d.put(cs.charAt(i), vs[i]);\n        }\n        int n = s.length();\n        int ans = d.get(s.charAt(n - 1));\n        for (int i = 0; i < n - 1; ++i) {\n            int sign = d.get(s.charAt(i)) < d.get(s.charAt(i + 1)) ? -1 : 1;\n            ans += sign * d.get(s.charAt(i));\n        }\n        return ans;\n    }\n}",
    "14. Longest Common Prefix": "class Solution {\n    public String longestCommonPrefix(String[] strs) {\n        int n = strs.length;\n        for (int i = 0; i < strs[0].length(); ++i) {\n            for (int j = 1; j < n; ++j) {\n                if (strs[j].length() <= i || strs[j].charAt(i) != strs[0].charAt(i)) {\n                    return strs[0].substring(0, i);\n                }\n            }\n        }\n        return strs[0];\n    }\n}",
    "15. 3Sum": "class Solution {\n    public List<List<Integer>> threeSum(int[] nums) {\n        Arrays.sort(nums);\n        List<List<Integer>> ans = new ArrayList<>();\n        int n = nums.length;\n        for (int i = 0; i < n - 2 && nums[i] <= 0; ++i) {\n            if (i > 0 && nums[i] == nums[i - 1]) {\n                continue;\n            }\n            int j = i + 1, k = n - 1;\n            while (j < k) {\n                int x = nums[i] + nums[j] + nums[k];\n                if (x < 0) {\n                    ++j;\n                } else if (x > 0) {\n                    --k;\n                } else {\n                    ans.add(List.of(nums[i], nums[j++], nums[k--]));\n                    while (j < k && nums[j] == nums[j - 1]) {\n                        ++j;\n                    }\n                    while (j < k && nums[k] == nums[k + 1]) {\n                        --k;\n                    }\n                }\n            }\n        }\n        return ans;\n    }\n}",
    "16. 3Sum Closest": "class Solution {\n    public int threeSumClosest(int[] nums, int target) {\n        Arrays.sort(nums);\n        int ans = 1 << 30;\n        int n = nums.length;\n        for (int i = 0; i < n; ++i) {\n            int j = i + 1, k = n - 1;\n            while (j < k) {\n                int t = nums[i] + nums[j] + nums[k];\n                if (t == target) {\n                    return t;\n                }\n                if (Math.abs(t - target) < Math.abs(ans - target)) {\n                    ans = t;\n                }\n                if (t > target) {\n                    --k;\n                } else {\n                    ++j;\n                }\n            }\n        }\n        return ans;\n    }\n}",
    "17. Letter Combinations of a Phone Number": "class Solution {\n    public List<String> letterCombinations(String digits) {\n        List<String> ans = new ArrayList<>();\n        if (digits.length() == 0) {\n            return ans;\n        }\n        ans.add(\"\");\n        String[] d = new String[] {\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\n        for (char i : digits.toCharArray()) {\n            String s = d[i - '2'];\n            List<String> t = new ArrayList<>();\n            for (String a : ans) {\n                for (String b : s.split(\"\")) {\n                    t.add(a + b);\n                }\n            }\n            ans = t;\n        }\n        return ans;\n    }\n}",
    "18. 4Sum": "class Solution {\n    public List<List<Integer>> fourSum(int[] nums, int target) {\n        int n = nums.length;\n        List<List<Integer>> ans = new ArrayList<>();\n        if (n < 4) {\n            return ans;\n        }\n        Arrays.sort(nums);\n        for (int i = 0; i < n - 3; ++i) {\n            if (i > 0 && nums[i] == nums[i - 1]) {\n                continue;\n            }\n            for (int j = i + 1; j < n - 2; ++j) {\n                if (j > i + 1 && nums[j] == nums[j - 1]) {\n                    continue;\n                }\n                int k = j + 1, l = n - 1;\n                while (k < l) {\n                    long x = (long) nums[i] + nums[j] + nums[k] + nums[l];\n                    if (x < target) {\n                        ++k;\n                    } else if (x > target) {\n                        --l;\n                    } else {\n                        ans.add(List.of(nums[i], nums[j], nums[k++], nums[l--]));\n                        while (k < l && nums[k] == nums[k - 1]) {\n                            ++k;\n                        }\n                        while (k < l && nums[l] == nums[l + 1]) {\n                            --l;\n                        }\n                    }\n                }\n            }\n        }\n        return ans;\n    }\n}\n\n\n//\n\n// general solution, k-sum\n// https://leetcode.com/problems/4sum/solution/\n// below kSum() divide-and-conquer idea is good, but not passing Online-Judge\nclass Solution {\n\n public List<List<Integer>> fourSum(int[] nums, int target) {\n  Arrays.sort(nums);\n  return kSum(nums, target, 0, 4);\n }\n\n public List<List<Integer>> kSum(int[] nums, int target, int start, int k) {\n  List<List<Integer>> res = new ArrayList<>();\n  if (start == nums.length || nums[start] * k > target || target > nums[nums.length - 1] * k)\n   return res;\n  if (k == 2)\n   return twoSum(nums, target, start);\n  for (int i = start; i < nums.length; ++i)\n   if (i == start || nums[i - 1] != nums[i]) // 'i == start' is key, since it could be in a following recurion of [1,1,1] where start is 3rd '1'\n    for (List<Integer> set : kSum(nums, target - nums[i], i + 1, k - 1)) {\n     res.add(new ArrayList<>(Arrays.asList(nums[i])));\n     res.get(res.size() - 1).addAll(set);\n    }\n  return res;\n }\n\n public List<List<Integer>> twoSum(int[] nums, int target, int start) {\n  List<List<Integer>> res = new ArrayList<>();\n  int lo = start, hi = nums.length - 1;\n  while (lo < hi) {\n   int sum = nums[lo] + nums[hi];\n   if (sum < target || (lo > start && nums[lo] == nums[lo - 1]))\n    ++lo;\n   else if (sum > target || (hi < nums.length - 1 && nums[hi] == nums[hi + 1]))\n    --hi;\n   else\n    res.add(Arrays.asList(nums[lo++], nums[hi--]));\n  }\n  return res;\n }\n}\n\n\npublic class Four_Sum {\n\n    public static void main(String[] args) {\n        Four_Sum out = new Four_Sum();\n        Solution s = out.new Solution();\n//  SolutionForLoop s= out.new SolutionForLoop();\n\n        List<List<Integer>> result = s.fourSum(new int[]{1, 0, -1, 0, -2, 2}, 0);\n\n        for (List<Integer> each : result) {\n            String one = \"\";\n\n            for (int e : each) {\n                one = one + \" \" + e;\n            }\n\n            System.out.println(one);\n        }\n    }\n\n    // time: O(NlogN)\n    // space: O(1)\n    public class Solution {\n        public List<List<Integer>> fourSum(int[] nums, int target) {\n\n            List<List<Integer>> list = new ArrayList<>();\n\n            if (nums.length < 4) {\n                return list;\n            }\n\n            Arrays.sort(nums);\n\n            // improved based on 3-sum\n            int layer4 = 0;\n            while (layer4 < nums.length) {\n\n                // @note: below is causing me trouble when convert for to while\n                //    in while, here \"layer4\" is never updated for case like {0,0,0,0}\n                // if(layer4 > 0 && nums[layer4] == nums[layer4 - 1]) continue;\n                if (layer4 > 0 && nums[layer4] == nums[layer4 - 1]) {\n                    layer4++;\n                }\n\n                // hold one pointer, other two pointer moving\n                int ancher = layer4 + 1;\n                while (ancher < nums.length) {\n\n                    int i = ancher + 1;\n                    int j = nums.length - 1;\n\n                    while (i < j) {\n\n                        int sum = nums[layer4] + nums[ancher] + nums[i] + nums[j];\n\n                        if (sum == target) {\n\n                            // @note: Arrays.asList()\n                            list.add(Arrays.asList(nums[layer4], nums[ancher], nums[i], nums[j]));\n\n                            // @note: dont forget move pointers\n                            i++;\n                            j--;\n\n                            // @note: optimization. above i,j is updated already, compare with previous position\n                            while (i < j && nums[i] == nums[i - 1]) {\n                                i++;\n                            }\n                            while (j > i && nums[j] == nums[j + 1]) {\n                                j--;\n                            }\n\n                        } else if (sum < target) {\n                            i++;\n\n                            // @note: same here, possibly updated already, note i-1 or i+1\n                            while (i < j && nums[i] == nums[i - 1]) {\n                                i++;\n                            }\n\n                        } else {\n                            j--;\n\n                            // @note: same here, possibly updated already, note i-1 or i+1\n                            while (j > i && j + 1 < nums.length && nums[j] == nums[j + 1]) {\n                                j--;\n                            }\n\n                        }\n                    }\n\n                    ancher++;\n\n                    // optimize for 2nd pointer\n                    while (ancher > layer4 && ancher < nums.length && nums[ancher] == nums[ancher - 1]) {\n                        ancher++;\n                    }\n\n                }\n\n                layer4++;\n\n                // optimize for 2nd pointer\n                while (layer4 < nums.length && nums[layer4] == nums[layer4 - 1]) {\n                    layer4++;\n                }\n            }\n\n            return list;\n        }\n    }\n}",
    "19. Remove Nth Node From End of List": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode removeNthFromEnd(ListNode head, int n) {\n        ListNode dummy = new ListNode(0, head);\n        ListNode fast = dummy, slow = dummy;\n        while (n-- > 0) {\n            fast = fast.next;\n        }\n        while (fast.next != null) {\n            slow = slow.next;\n            fast = fast.next;\n        }\n        slow.next = slow.next.next;\n        return dummy.next;\n    }\n}",
    "20. Valid Parentheses": "class Solution {\n    public boolean isValid(String s) {\n        Deque<Character> stk = new ArrayDeque<>();\n        for (char c : s.toCharArray()) {\n            if (c == '(' || c == '{' || c == '[') {\n                stk.push(c);\n            } else if (stk.isEmpty() || !match(stk.pop(), c)) {\n                return false;\n            }\n        }\n        return stk.isEmpty();\n    }\n\n    private boolean match(char l, char r) {\n        return (l == '(' && r == ')') || (l == '{' && r == '}') || (l == '[' && r == ']');\n    }\n}",
    "21. Merge Two Sorted Lists": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {\n        ListNode dummy = new ListNode();\n        ListNode curr = dummy;\n        while (list1 != null && list2 != null) {\n            if (list1.val <= list2.val) {\n                curr.next = list1;\n                list1 = list1.next;\n            } else {\n                curr.next = list2;\n                list2 = list2.next;\n            }\n            curr = curr.next;\n        }\n        curr.next = list1 == null ? list2 : list1;\n        return dummy.next;\n    }\n}",
    "22. Generate Parentheses": "class Solution {\n    private List<String> ans = new ArrayList<>();\n    private int n;\n\n    public List<String> generateParenthesis(int n) {\n        this.n = n;\n        dfs(0, 0, \"\");\n        return ans;\n    }\n\n    private void dfs(int l, int r, String t) {\n        if (l > n || r > n || l < r) {\n            return;\n        }\n        if (l == n && r == n) {\n            ans.add(t);\n            return;\n        }\n        dfs(l + 1, r, t + \"(\");\n        dfs(l, r + 1, t + \")\");\n    }\n}",
    "23. Merge k Sorted Lists": "public class Merge_k_Sorted_Lists {\n\n    public static void main(String[] args) {\n\n        Merge_k_Sorted_Lists out = new Merge_k_Sorted_Lists();\n        Solution s = out.new Solution();\n\n        ListNode l1 = null;\n        ListNode l2 = new ListNode(1);\n\n        s.mergeKLists(new ListNode[]{l1, l2});\n\n    }\n\n    public class Solution {\n        public ListNode mergeKLists(ListNode[] lists) {\n\n            if (lists == null || lists.length == 0) {\n                return null;\n            }\n\n            // same as merge sort array\n            return merge(lists, 0, lists.length - 1);\n        }\n\n        public ListNode merge(ListNode[] lists, int start, int end) {\n\n            // single list\n            if (start == end) {\n                return lists[start];\n            }\n\n            int mid = (end - start) / 2 + start;\n            ListNode leftHalf = merge(lists, start, mid);\n            ListNode rightHalf = merge(lists, mid + 1, end);\n\n            return mergeTwoLists(leftHalf, rightHalf);\n        }\n\n        // from previous question: 21 Merge Two Sorted Lists\n        public ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n\n            ListNode dummy = new ListNode(0);\n            ListNode current = dummy;\n\n            while (l1 != null || l2 != null) {\n                int v1 = (l1 == null ? Integer.MAX_VALUE : l1.val);\n                int v2 = (l2 == null ? Integer.MAX_VALUE : l2.val);\n\n                if (v1 < v2) {\n                    current.next = l1;\n                    l1 = l1.next;\n                } else {\n                    current.next = l2;\n                    l2 = l2.next;\n                }\n\n                current = current.next; // now current is the new end node, but still pointing to next node\n                current.next = null; // @note: key, cut this node from l1 or l2\n            }\n\n            return dummy.next;\n        }\n    }\n\n}\n\n//////\n\nclass Solution_Heap {\n public ListNode mergeKLists(ListNode[] lists) {\n\n  if (lists == null || lists.length == 0) {\n   return null;\n  }\n\n  ListNode dummy = new ListNode(0);\n  ListNode current = dummy;\n\n  // put 1st of each list to heap\n  PriorityQueue<ListNode> heap = new PriorityQueue<>(\n   (a,b) -> a.val - b.val\n  );\n\n  //\n  Arrays.stream(lists).filter(Objects::nonNull).forEach(heap::offer);\n\n  while (heap.size() != 0) {\n   ListNode polled = heap.poll();\n\n   current.next = polled;\n   current = current.next;\n\n   if (polled.next != null) {\n    heap.offer(polled.next); // @note: heap.offer()\u53c2\u6570\u4e0d\u80fd\u662fnull\n   }\n  }\n\n  return dummy.next;\n }\n}\n\n//////\n\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        int n = lists.length;\n        if (n == 0) {\n            return null;\n        }\n        for (int i = 0; i < n - 1; ++i) {\n            lists[i + 1] = mergeLists(lists[i], lists[i + 1]);\n        }\n        return lists[n - 1];\n    }\n\n    private ListNode mergeLists(ListNode l1, ListNode l2) {\n        ListNode dummy = new ListNode();\n        ListNode cur = dummy;\n        while (l1 != null && l2 != null) {\n            if (l1.val <= l2.val) {\n                cur.next = l1;\n                l1 = l1.next;\n            } else {\n                cur.next = l2;\n                l2 = l2.next;\n            }\n            cur = cur.next;\n        }\n        cur.next = l1 == null ? l2 : l1;\n        return dummy.next;\n    }\n}",
    "24. Swap Nodes in Pairs": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        ListNode dummy = new ListNode(0, head);\n        ListNode pre = dummy;\n        ListNode cur = head;\n        while (cur != null && cur.next != null) {\n            ListNode t = cur.next;\n            cur.next = t.next;\n            t.next = cur;\n            pre.next = t;\n            pre = cur;\n            cur = cur.next;\n        }\n        return dummy.next;\n    }\n}",
    "25. Reverse Nodes in k-Group": "public class Reverse_Nodes_in_k_Group {\n\n    class Solution {\n        public ListNode reverseKGroup(ListNode head, int k) {\n            ListNode dummy = new ListNode(0);\n            dummy.next = head;\n\n            ListNode prev = dummy;\n\n            // count total nodes\n            ListNode tmp = head;\n            int count = 0;\n            while (tmp != null) {\n                count++;\n                tmp = tmp.next;\n            }\n\n            // 1->2->3->4->5 , k=3\n            // 2,1,3,4,5\n            // 3,2,1,4,5\n            // => always getting 1's next for prev's next => current (below) not changing in one-batch-swap\n\n            // if only one node left, then no swap\n            while (count >= k) {\n\n                ListNode originalFirst = prev.next;\n\n                int kcopy = k - 1; // @note: since current node is already counted as 1\n                while (kcopy > 0) { // both prev and current, not changed in while loop\n\n                    ListNode nextNextCopy = originalFirst.next.next;\n                    ListNode firstInGroup = prev.next;\n\n                    prev.next = originalFirst.next;\n                    prev.next.next = firstInGroup;\n                    originalFirst.next = nextNextCopy;\n\n                    kcopy--;\n                }\n\n                // @note: update previous AND current. I forgot current...\n                prev = originalFirst; // now current is the last one of this group\n                count -= k;\n            }\n\n            return dummy.next;\n        }\n    }\n}\n\n//////\n\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode reverseKGroup(ListNode head, int k) {\n        ListNode dummy = new ListNode(0, head);\n        ListNode pre = dummy, cur = dummy;\n        while (cur.next != null) {\n            for (int i = 0; i < k && cur != null; ++i) {\n                cur = cur.next;\n            }\n            if (cur == null) {\n                return dummy.next;\n            }\n            ListNode t = cur.next;\n            cur.next = null;\n            ListNode start = pre.next;\n            pre.next = reverseList(start);\n            start.next = t;\n            pre = start;\n            cur = pre;\n        }\n        return dummy.next;\n    }\n\n    private ListNode reverseList(ListNode head) {\n        ListNode pre = null, p = head;\n        while (p != null) {\n            ListNode q = p.next;\n            p.next = pre;\n            pre = p;\n            p = q;\n        }\n        return pre;\n    }\n}",
    "26. Remove Duplicates from Sorted Array": "class Solution {\n    public int removeDuplicates(int[] nums) {\n        int k = 0;\n        for (int x : nums) {\n            if (k == 0 || x != nums[k - 1]) {\n                nums[k++] = x;\n            }\n        }\n        return k;\n    }\n}",
    "27. Remove Element": "class Solution {\n    public int removeElement(int[] nums, int val) {\n        int k = 0;\n        for (int x : nums) {\n            if (x != val) {\n                nums[k++] = x;\n            }\n        }\n        return k;\n    }\n}",
    "29. Divide Two Integers": "class Solution {\n    public int divide(int a, int b) {\n        if (b == 1) {\n            return a;\n        }\n        if (a == Integer.MIN_VALUE && b == -1) {\n            return Integer.MAX_VALUE;\n        }\n        boolean sign = (a > 0 && b > 0) || (a < 0 && b < 0);\n        a = a > 0 ? -a : a;\n        b = b > 0 ? -b : b;\n        int ans = 0;\n        while (a <= b) {\n            int x = b;\n            int cnt = 1;\n            while (x >= (Integer.MIN_VALUE >> 1) && a <= (x << 1)) {\n                x <<= 1;\n                cnt <<= 1;\n            }\n            ans += cnt;\n            a -= x;\n        }\n        return sign ? ans : -ans;\n    }\n}",
    "30. Substring with Concatenation of All Words": "class Solution {\n    public List<Integer> findSubstring(String s, String[] words) {\n        Map<String, Integer> cnt = new HashMap<>();\n        for (String w : words) {\n            cnt.merge(w, 1, Integer::sum);\n        }\n        int m = s.length(), n = words.length;\n        int k = words[0].length();\n        List<Integer> ans = new ArrayList<>();\n        for (int i = 0; i < k; ++i) {\n            Map<String, Integer> cnt1 = new HashMap<>();\n            int l = i, r = i;\n            int t = 0;\n            while (r + k <= m) {\n                String w = s.substring(r, r + k);\n                r += k;\n                if (!cnt.containsKey(w)) {\n                    cnt1.clear();\n                    l = r;\n                    t = 0;\n                    continue;\n                }\n                cnt1.merge(w, 1, Integer::sum);\n                ++t;\n                while (cnt1.get(w) > cnt.get(w)) {\n                    String remove = s.substring(l, l + k);\n                    l += k;\n                    cnt1.merge(remove, -1, Integer::sum);\n                    --t;\n                }\n                if (t == n) {\n                    ans.add(l);\n                }\n            }\n        }\n        return ans;\n    }\n}",
    "31. Next Permutation": "import java.util.Arrays;\n\npublic class Next_Permutation {\n\n    // time: O(N^2)\n    // space: O(1)\n    public class Solution {\n\n        public void nextPermutation(int[] nums) {\n\n            if (nums == null || nums.length == 0) {\n                return;\n            }\n\n            // \u603b\u4f53\u76ee\u6807\u662f\uff0c\u9ad8\u4f4d\u7684\u5c0f\u6570\u5b57\uff0c\u6362\u4f4e\u4f4d\u7684\u5927\u6570\u5b57\uff0c\u624d\u80fd\u5f97\u5230next\n            for (int i = nums.length - 2; i >= 0; --i) { // 3, 4, 5, 2, 1 // \u6ce8\u610f. i < Len - 1. \u4e5f\u5c31\u662f\u505c\u5728\u5012\u6570\u7b2c\u4e8c\u4e2a\n                if (nums[i] < nums[i + 1]) { // \u7b2c\u4e00\u4e2a\u6ce2\u5cf0\u6ce2\u8c37 => 4\n                    for (int j = nums.length - 1; j > i; --j) {\n                        if (nums[j] > nums[i]) {\n                            // \u627e\u5230\u7b2c\u4e00\u4e2a\u6bd4nums-i\u5927\u7684\u6570 => 5\n                            swap(nums, i, j); // 3,5,4,2,1\n\n                            // reverse \u56e0\u4e3a\u5269\u4e0b\u90e8\u5206\u80af\u5b9a\u662f\u4ece\u5927\u5230\u5c0f\n                            // \u627e\u5230\u7b2c\u4e00\u4e2a\u6bd4nums-i\u5927\u7684\u6570\u7684\u4e00\u6b65\uff0c\u76f8\u5f53\u4e8e\u662f\u6392\u5e8f\uff0c\u627einsert position\n                            reverse(nums, i + 1, nums.length - 1); // [4,2,1] reverse to [1,2,4] => 3, 5, 1, 2, 4\n                            return;\n                        }\n                    }\n\n                }\n            }\n\n            reverse(nums, 0, nums.length - 1); // for\u6ca1\u6709return\uff0c\u5c31\u6574\u4e2a\u7ffb\u8f6c\n        }\n\n        private void swap(int[] nums, int i, int j) {\n\n            int tmp = nums[i];\n            nums[i] = nums[j];\n            nums[j] = tmp;\n\n        }\n\n        private void reverse(int[] nums, int i, int j) {\n\n            while (i < j) {\n\n                int tmp = nums[i];\n                nums[i] = nums[j];\n                nums[j] = tmp;\n\n                i++;\n                j--;\n            }\n        }\n    }\n}\n\n//////\n\nclass Solution {\n    public void nextPermutation(int[] nums) {\n        int n = nums.length;\n        int i = n - 2;\n        for (; i >= 0; --i) {\n            if (nums[i] < nums[i + 1]) {\n                break;\n            }\n        }\n        if (i >= 0) {\n            for (int j = n - 1; j > i; --j) {\n                if (nums[j] > nums[i]) {\n                    swap(nums, i, j);\n                    break;\n                }\n            }\n        }\n\n        for (int j = i + 1, k = n - 1; j < k; ++j, --k) {\n            swap(nums, j, k);\n        }\n    }\n\n    private void swap(int[] nums, int i, int j) {\n        int t = nums[j];\n        nums[j] = nums[i];\n        nums[i] = t;\n    }\n}",
    "32. Longest Valid Parentheses": "class Solution {\n    public int longestValidParentheses(String s) {\n        int n = s.length();\n        int[] f = new int[n + 1];\n        int ans = 0;\n        for (int i = 2; i <= n; ++i) {\n            if (s.charAt(i - 1) == ')') {\n                if (s.charAt(i - 2) == '(') {\n                    f[i] = f[i - 2] + 2;\n                } else {\n                    int j = i - f[i - 1] - 1;\n                    if (j > 0 && s.charAt(j - 1) == '(') {\n                        f[i] = f[i - 1] + 2 + f[j - 1];\n                    }\n                }\n                ans = Math.max(ans, f[i]);\n            }\n        }\n        return ans;\n    }\n}\n\n//////\n\nclass Solution_noExtraSpace {\n    public int longestValidParentheses(String s) {\n        int res = 0, left = 0, right = 0, n = s.length();\n\n        // from left to right, '(()' => will never hit left==right\n        for (int i = 0; i < n; ++i) {\n            if (s.charAt(i) == '(') ++left;\n            else ++right;\n\n            if (left == right) res = Math.max(res, 2 * right);\n            else if (right > left) left = right = 0;\n        }\n\n        // from right to left, '())' => will never hit left==right\n        left = right = 0;\n        for (int i = n - 1; i >= 0; --i) {\n            if (s.charAt(i) == '(') ++left;\n            else ++right;\n\n            if (left == right) res = Math.max(res, 2 * left);\n            else if (left > right) left = right = 0;\n        }\n        return res;\n\n    }\n}\n\n//////\n\nclass Solution_stack {\n    public int longestValidParentheses(String s) {\n        Stack<Integer> sk = new Stack<>();\n        int start = 0;\n        int result = 0;\n        for (int i = 0;i < s.length(); i++) {\n            if(s.charAt(i) == '(') {\n                sk.push(i);\n            } else {\n                if (sk.empty()) {\n                    start = i + 1;\n                } else {\n                    sk.pop();\n                    result = Math.max(result, sk.isEmpty() ? i - start + 1 : i - sk.peek());\n                }\n            }\n        }\n        return result;\n\n    }\n}",
    "33. Search in Rotated Sorted Array": "class Solution {\n    public int search(int[] nums, int target) {\n        int n = nums.length;\n        int left = 0, right = n - 1;\n        while (left < right) {\n            int mid = (left + right) >> 1;\n            if (nums[0] <= nums[mid]) {\n                if (nums[0] <= target && target <= nums[mid]) {\n                    right = mid;\n                } else {\n                    left = mid + 1;\n                }\n            } else {\n                if (nums[mid] < target && target <= nums[n - 1]) {\n                    left = mid + 1;\n                } else {\n                    right = mid;\n                }\n            }\n        }\n        return nums[left] == target ? left : -1;\n    }\n}",
    "35. Search Insert Position": "class Solution {\n    public int searchInsert(int[] nums, int target) {\n        int left = 0, right = nums.length;\n        while (left < right) {\n            int mid = (left + right) >>> 1;\n            if (nums[mid] >= target) {\n                right = mid;\n            } else {\n                left = mid + 1;\n            }\n        }\n        return left;\n    }\n}",
    "36. Valid Sudoku": "class Solution {\n    public boolean isValidSudoku(char[][] board) {\n        boolean[][] row = new boolean[9][9];\n        boolean[][] col = new boolean[9][9];\n        boolean[][] sub = new boolean[9][9];\n        for (int i = 0; i < 9; ++i) {\n            for (int j = 0; j < 9; ++j) {\n                char c = board[i][j];\n                if (c == '.') {\n                    continue;\n                }\n                int num = c - '0' - 1;\n                int k = i / 3 * 3 + j / 3;\n                if (row[i][num] || col[j][num] || sub[k][num]) {\n                    return false;\n                }\n                row[i][num] = true;\n                col[j][num] = true;\n                sub[k][num] = true;\n            }\n        }\n        return true;\n    }\n}",
    "37. Sudoku Solver": "class Solution {\n    private boolean ok;\n    private char[][] board;\n    private List<Integer> t = new ArrayList<>();\n    private boolean[][] row = new boolean[9][9];\n    private boolean[][] col = new boolean[9][9];\n    private boolean[][][] block = new boolean[3][3][9];\n\n    public void solveSudoku(char[][] board) {\n        this.board = board;\n        for (int i = 0; i < 9; ++i) {\n            for (int j = 0; j < 9; ++j) {\n                if (board[i][j] == '.') {\n                    t.add(i * 9 + j);\n                } else {\n                    int v = board[i][j] - '1';\n                    row[i][v] = col[j][v] = block[i / 3][j / 3][v] = true;\n                }\n            }\n        }\n        dfs(0);\n    }\n\n    private void dfs(int k) {\n        if (k == t.size()) {\n            ok = true;\n            return;\n        }\n        int i = t.get(k) / 9, j = t.get(k) % 9;\n        for (int v = 0; v < 9; ++v) {\n            if (!row[i][v] && !col[j][v] && !block[i / 3][j / 3][v]) {\n                row[i][v] = col[j][v] = block[i / 3][j / 3][v] = true;\n                board[i][j] = (char) (v + '1');\n                dfs(k + 1);\n                row[i][v] = col[j][v] = block[i / 3][j / 3][v] = false;\n            }\n            if (ok) {\n                return;\n            }\n        }\n    }\n}",
    "38. Count and Say": "class Solution {\n    public String countAndSay(int n) {\n        String s = \"1\";\n        while (--n > 0) {\n            StringBuilder t = new StringBuilder();\n            for (int i = 0; i < s.length();) {\n                int j = i;\n                while (j < s.length() && s.charAt(j) == s.charAt(i)) {\n                    ++j;\n                }\n                t.append((j - i) + \"\");\n                t.append(s.charAt(i));\n                i = j;\n            }\n            s = t.toString();\n        }\n        return s;\n    }\n}",
    "39. Combination Sum": "class Solution {\n    private List<List<Integer>> ans = new ArrayList<>();\n    private List<Integer> t = new ArrayList<>();\n    private int[] candidates;\n\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\n        Arrays.sort(candidates);\n        this.candidates = candidates;\n        dfs(0, target);\n        return ans;\n    }\n\n    private void dfs(int i, int s) {\n        if (s == 0) {\n            ans.add(new ArrayList(t));\n            return;\n        }\n        if (i >= candidates.length || s < candidates[i]) {\n            return;\n        }\n        dfs(i + 1, s);\n        t.add(candidates[i]);\n        dfs(i, s - candidates[i]);\n        t.remove(t.size() - 1);\n    }\n}\n\n//////\n\nclass Solution_dp {\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\n        // for each-target (from 1 to target), its dp[i][j] => so 3-D array dp[][][]\n        List<List<List<Integer>>> dp = new ArrayList<>();\n        Arrays.sort(candidates);\n\n        for (int i = 1; i <= target; ++i) {\n            List<List<Integer>> cur = new ArrayList<>();\n            for (int j = 0; j < candidates.length; ++j) {\n                if (candidates[j] > i) break;\n                if (candidates[j] == i) {\n                    ArrayList<Integer> one = new ArrayList<Integer>();\n                    one.add(candidates[j]);\n                    cur.add(one); // @note: one with proper <Integer>, or else unsupoorted operation error\n                    break;\n                }\n                for (List<Integer> a : dp.get(i - candidates[j] - 1)) {\n                    if (candidates[j] > a.get(0)) {\n                        continue;\n                    }\n\n                    ArrayList<Integer> deepCopied = new ArrayList<>(a); // @note: must have\n                    deepCopied.add(0, candidates[j]); // @note: largest at index=0 for the array\n                    cur.add(deepCopied);\n                }\n            }\n            dp.add(cur);\n        }\n\n        return dp.get(dp.size() - 1);\n    }\n\n}",
    "40. Combination Sum II": "class Solution {\n    private List<List<Integer>> ans = new ArrayList<>();\n    private List<Integer> t = new ArrayList<>();\n    private int[] candidates;\n\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\n        Arrays.sort(candidates);\n        this.candidates = candidates;\n        dfs(0, target);\n        return ans;\n    }\n\n    private void dfs(int i, int s) {\n        if (s == 0) {\n            ans.add(new ArrayList<>(t));\n            return;\n        }\n        if (i >= candidates.length || s < candidates[i]) {\n            return;\n        }\n        for (int j = i; j < candidates.length; ++j) {\n            if (j > i && candidates[j] == candidates[j - 1]) {\n                continue;\n            }\n            t.add(candidates[j]);\n            dfs(j + 1, s - candidates[j]);\n            t.remove(t.size() - 1);\n        }\n    }\n}",
    "41. First Missing Positive": "class Solution {\n    public int firstMissingPositive(int[] nums) {\n        int n = nums.length;\n        for (int i = 0; i < n; ++i) {\n            while (nums[i] >= 1 && nums[i] <= n && nums[i] != nums[nums[i] - 1]) {\n                swap(nums, i, nums[i] - 1);\n            }\n        }\n        for (int i = 0; i < n; ++i) {\n            if (i + 1 != nums[i]) {\n                return i + 1;\n            }\n        }\n        return n + 1;\n    }\n\n    private void swap(int[] nums, int i, int j) {\n        int t = nums[i];\n        nums[i] = nums[j];\n        nums[j] = t;\n    }\n}",
    "42. Trapping Rain Water": "public class Trapping_Rain_Water {\n\n    public static void main(String[] args) {\n        Trapping_Rain_Water out = new Trapping_Rain_Water();\n        Solution_local_minimum s = out.new Solution_local_minimum();\n\n        System.out.println(s.trap(new int[]{5,2,1,2,1,5}));\n    }\n\n    // The short board effect, the storage capacity is related to the short board of the bucket.\n    // Find the longest slab in the height array, and then iterate from both ends to the long slab. When encountering a shorter one, find the storage capacity, and when encountering a longer one, update the edge.\n    public class Solution_optimize {\n        public int trap(int[] height) {\n\n            if (height == null || height.length == 0)     return 0;\n\n            int sum = 0;\n            int maxind = 0;\n            int max = Integer.MIN_VALUE;\n\n            // find max index\n            for (int i = 0; i < height.length; i++) {\n                if (height[i] > max) {\n                    max = height[i];\n                    maxind = i;\n                }\n            }\n\n            // left\n            int leftmax = height[0];\n            for (int i = 1; i < maxind; i++) {\n\n                if (leftmax < height[i]) {\n                    leftmax = height[i];\n                }\n\n                sum += leftmax - height[i];\n            }\n\n            // right\n            int rightmax = height[height.length - 1];\n            for (int i = height.length - 2; i > maxind; i--) {\n                if (rightmax < height[i]) {\n                    rightmax = height[i];\n                }\n\n                sum += rightmax - height[i];\n            }\n\n            return sum;\n        }\n    }\n\n    // local minimum solution is NOT doable. like [5,2,1,2,1,5], there are 2 local minimums with each holding 1 water\n    // but they are just part of a global minimum\n    class Solution_local_minimum {\n\n        public int trap(int[] height) {\n\n            // for each position, probe to left and right, find local minimum\n\n            if (height == null || height.length == 0)     return 0;\n\n            int sum = 0;\n\n            int i = 1; // index=0 or index=length-1 will not be a local min, since nothing on its left to hold water\n            while (i < height.length - 1) {\n\n                // only process local min index\n                if (height[i] < height[i - 1] && height[i] < height[i + 1]) {\n\n                    int left = i - 1;\n                    while (left - 1 >= 0 && height[left] < height[left - 1]) {\n                        left--;\n                    }\n\n                    int right = i + 1;\n                    while (right + 1 < height.length && height[right] < height[right + 1]) {\n                        right++;\n                    }\n\n                    // now find its highest bar on both sides\n                    int lower = Math.min(height[left], height[right]);\n\n                    // add up\n                    while (left < right) {\n\n                        if (height[left] < lower) {\n                            sum += lower - height[left];\n                        }\n\n                        left ++;\n                    }\n\n                    // update pointer to search next local minimum\n                    i = right;\n\n                } else {\n                    i++;\n                }\n            }\n\n            return sum;\n        }\n\n    }\n\n}\n\n\n//////\n\nclass Solution_notFindingMaxHeight {\n    public int trap(int[] height) {\n        if (height == null || height.length == 0)\n            return 0;\n        int length = height.length;\n        int[] leftMax = new int[length]; // `leftMax` represents the maximum height in the subarray from the leftmost index to the current index\n        int[] rightMax = new int[length]; // `rightMax` represents the maximum height in the subarray from the current index to the rightmost index\n        leftMax[0] = height[0];\n        for (int i = 1; i < length; i++)\n            leftMax[i] = Math.max(height[i], leftMax[i - 1]);\n        rightMax[length - 1] = height[length - 1];\n        for (int i = length - 2; i >= 0; i--)\n            rightMax[i] = Math.max(height[i], rightMax[i + 1]);\n        int amount = 0;\n        for (int i = 0; i < length; i++)\n            amount += Math.min(leftMax[i], rightMax[i]) - height[i];\n        return amount;\n    }\n}\n\n//////\n\nclass Solution {\n    public int trap(int[] height) {\n        int n = height.length;\n        if (n < 3) {\n            return 0;\n        }\n\n        int[] lmx = new int[n];\n        int[] rmx = new int[n];\n        lmx[0] = height[0];\n        rmx[n - 1] = height[n - 1];\n        for (int i = 1; i < n; ++i) {\n            lmx[i] = Math.max(lmx[i - 1], height[i]);\n            rmx[n - 1 - i] = Math.max(rmx[n - i], height[n - i - 1]);\n        }\n\n        int res = 0;\n        for (int i = 0; i < n; ++i) {\n            res += Math.min(lmx[i], rmx[i]) - height[i];\n        }\n        return res;\n    }\n}",
    "43. Multiply Strings": "class Solution {\n    public String multiply(String num1, String num2) {\n        if (\"0\".equals(num1) || \"0\".equals(num2)) {\n            return \"0\";\n        }\n        int m = num1.length(), n = num2.length();\n        int[] arr = new int[m + n];\n        for (int i = m - 1; i >= 0; --i) {\n            int a = num1.charAt(i) - '0';\n            for (int j = n - 1; j >= 0; --j) {\n                int b = num2.charAt(j) - '0';\n                arr[i + j + 1] += a * b;\n            }\n        }\n        for (int i = arr.length - 1; i > 0; --i) {\n            arr[i - 1] += arr[i] / 10;\n            arr[i] %= 10;\n        }\n        int i = arr[0] == 0 ? 1 : 0;\n        StringBuilder ans = new StringBuilder();\n        for (; i < arr.length; ++i) {\n            ans.append(arr[i]);\n        }\n        return ans.toString();\n    }\n}",
    "44. Wildcard Matching": "class Solution {\n    public boolean isMatch(String s, String p) {\n        int m = s.length(), n = p.length();\n        boolean[][] dp = new boolean[m + 1][n + 1];\n        dp[0][0] = true;\n        for (int j = 1; j <= n; ++j) {\n            if (p.charAt(j - 1) == '*') {\n                dp[0][j] = dp[0][j - 1];\n            }\n        }\n        for (int i = 1; i <= m; ++i) {\n            for (int j = 1; j <= n; ++j) {\n                if (s.charAt(i - 1) == p.charAt(j - 1) || p.charAt(j - 1) == '?') {\n                    dp[i][j] = dp[i - 1][j - 1];\n                } else if (p.charAt(j - 1) == '*') {\n                    dp[i][j] = dp[i - 1][j] || dp[i][j - 1];\n                }\n            }\n        }\n        return dp[m][n];\n    }\n}",
    "45. Jump Game II": "class Solution {\n    public int jump(int[] nums) {\n        int ans = 0, mx = 0, last = 0;\n        for (int i = 0; i < nums.length - 1; ++i) {\n            mx = Math.max(mx, i + nums[i]);\n            if (last == i) {\n                ++ans;\n                last = mx;\n            }\n        }\n        return ans;\n    }\n}",
    "46. Permutations": "class Solution {\n    private List<List<Integer>> ans = new ArrayList<>();\n    private List<Integer> t = new ArrayList<>();\n    private boolean[] vis;\n    private int[] nums;\n\n    public List<List<Integer>> permute(int[] nums) {\n        this.nums = nums;\n        vis = new boolean[nums.length];\n        dfs(0);\n        return ans;\n    }\n\n    private void dfs(int i) {\n        if (i == nums.length) {\n            ans.add(new ArrayList<>(t));\n            return;\n        }\n        for (int j = 0; j < nums.length; ++j) {\n            if (!vis[j]) {\n                vis[j] = true;\n                t.add(nums[j]);\n                dfs(i + 1);\n                t.remove(t.size() - 1);\n                vis[j] = false;\n            }\n        }\n    }\n}",
    "47. Permutations II": "class Solution {\n    private List<List<Integer>> ans = new ArrayList<>();\n    private List<Integer> t = new ArrayList<>();\n    private int[] nums;\n    private boolean[] vis;\n\n    public List<List<Integer>> permuteUnique(int[] nums) {\n        Arrays.sort(nums);\n        this.nums = nums;\n        vis = new boolean[nums.length];\n        dfs(0);\n        return ans;\n    }\n\n    private void dfs(int i) {\n        if (i == nums.length) {\n            ans.add(new ArrayList<>(t));\n            return;\n        }\n        for (int j = 0; j < nums.length; ++j) {\n            if (vis[j] || (j > 0 && nums[j] == nums[j - 1] && !vis[j - 1])) {\n                continue;\n            }\n            t.add(nums[j]);\n            vis[j] = true;\n            dfs(i + 1);\n            vis[j] = false;\n            t.remove(t.size() - 1);\n        }\n    }\n}",
    "48. Rotate Image": "public class Rotate_Image {\n\n public class Solution {\n     /*  eg:\n\n         1   2   3   4   5\n         6   7   8   9   10\n         11  12  13  14  15\n         16  17  18  19  20\n         21  22  23  24  25\n     */\n\n     public void rotate(int[][] m) { // m for matrix\n\n         if (m == null || m.length == 0) {\n             return;\n         }\n\n         // for each circle, start position is (i,i), length is rectangle size\n         // eg. above: (0,0), length=5; (1,1), length=3\n         int i = 0;\n         int length = m.length;\n\n         while (i < m.length / 2) {\n\n             int count = 0;\n             while (count < length - 1) { // @note: extra attention here \"-1\".\n             // while (count < length) {\n\n                 int tmp = m[i][i + count];\n\n                 // i+length-1: last index of this rectangle\n                 // i+length-1 - count: index from backward\n                 m[i][i + count] = m[i + length - 1 - count][i];\n                 m[i + length - 1 - count][i] = m[i + length - 1][i + length - 1 - count];\n                 m[i + length - 1][i + length - 1 - count] = m[i + count][i + length - 1];\n                 m[i + count][i + length - 1] = tmp;\n\n                 count++;\n             }\n\n             length -= 2; // @note: shrink each edge length by 2\n             i++; // start point moving along diagonal\n         }\n     }\n }\n\n // An Inplace function to rotate a N x N matrix by 90 degrees in anti-clockwise direction\n static void rotateMatrix_anticlock(int N, int mat[][])\n {\n  // Consider all squares one by one\n  for (int x = 0; x < N / 2; x++) {\n   // Consider elements in group of 4 in\n   // current square\n   for (int y = x; y < N-x-1; y++) {\n    // store current cell in temp variable\n    int temp = mat[x][y];\n\n    // move values from right to top\n    mat[x][y] = mat[y][N-1-x];\n\n    // move values from bottom to right\n    mat[y][N-1-x] = mat[N-1-x][N-1-y];\n\n    // move values from left to bottom\n    mat[N-1-x][N-1-y] = mat[N-1-y][x];\n\n    // assign temp to left\n    mat[N-1-y][x] = temp;\n   }\n  }\n }\n\n static void rotateMatrix_clockwise(int N, int mat[][])\n {\n  // Consider all squares one by one\n  for (int x = 0; x < N / 2; x++) {\n   // Consider elements in group of 4 in\n   // current square\n   for (int y = x; y < N-x-1; y++) {\n    // store current cell in temp variable\n    int temp = mat[x][y];\n\n    // move values from right to top\n    mat[x][y] = mat[y][N-1-x];\n\n    // move values from bottom to right\n    mat[y][N-1-x] = mat[N-1-x][N-1-y];\n\n    // move values from left to bottom\n    mat[N-1-x][N-1-y] = mat[N-1-y][x];\n\n    // assign temp to left\n    mat[N-1-y][x] = temp;\n   }\n  }\n }\n}\n\n//////\n\nclass Solution_diagonal {\n public void rotate(int[][] matrix) {\n  transpose(matrix);\n  reflect(matrix);\n }\n\n public void transpose(int[][] matrix) {\n  int n = matrix.length;\n  for (int i = 0; i < n; i++) {\n   for (int j = i; j < n; j++) {\n    int tmp = matrix[j][i];\n    matrix[j][i] = matrix[i][j];\n    matrix[i][j] = tmp;\n   }\n  }\n }\n\n public void reflect(int[][] matrix) {\n  int n = matrix.length;\n  for (int i = 0; i < n; i++) {\n   for (int j = 0; j < n / 2; j++) {\n    int tmp = matrix[i][j];\n    matrix[i][j] = matrix[i][n - j - 1];\n    matrix[i][n - j - 1] = tmp;\n   }\n  }\n }\n}\n\n//////\n\nclass Solution {\n    public void rotate(int[][] matrix) {\n        int s = 0, n = matrix.length;\n        while (s < (n >> 1)) {\n            int e = n - s - 1;\n            for (int i = s; i < e; ++i) {\n                int t = matrix[i][e];\n                matrix[i][e] = matrix[s][i];\n                matrix[s][i] = matrix[n - i - 1][s];\n                matrix[n - i - 1][s] = matrix[e][n - i - 1];\n                matrix[e][n - i - 1] = t;\n            }\n            ++s;\n        }\n    }\n}",
    "49. Group Anagrams": "class Solution {\n    public List<List<String>> groupAnagrams(String[] strs) {\n        Map<String, List<String>> d = new HashMap<>();\n        for (String s : strs) {\n            char[] t = s.toCharArray();\n            Arrays.sort(t);\n            String k = String.valueOf(t);\n            d.computeIfAbsent(k, key -> new ArrayList<>()).add(s);\n        }\n        return new ArrayList<>(d.values());\n    }\n}",
    "50. Pow(x, n)": "class Solution {\n    public double myPow(double x, int n) {\n        return n >= 0 ? qpow(x, n) : 1 / qpow(x, -(long) n);\n    }\n\n    private double qpow(double a, long n) {\n        double ans = 1;\n        for (; n > 0; n >>= 1) {\n            if ((n & 1) == 1) {\n                ans = ans * a;\n            }\n            a = a * a;\n        }\n        return ans;\n    }\n}",
    "51. N-Queens": "class Solution {\n    private List<List<String>> ans = new ArrayList<>();\n    private int[] col;\n    private int[] dg;\n    private int[] udg;\n    private String[][] g;\n    private int n;\n\n    public List<List<String>> solveNQueens(int n) {\n        this.n = n;\n        col = new int[n];\n        dg = new int[n << 1];\n        udg = new int[n << 1];\n        g = new String[n][n];\n        for (int i = 0; i < n; ++i) {\n            Arrays.fill(g[i], \".\");\n        }\n        dfs(0);\n        return ans;\n    }\n\n    private void dfs(int i) {\n        if (i == n) {\n            List<String> t = new ArrayList<>();\n            for (int j = 0; j < n; ++j) {\n                t.add(String.join(\"\", g[j]));\n            }\n            ans.add(t);\n            return;\n        }\n        for (int j = 0; j < n; ++j) {\n            if (col[j] + dg[i + j] + udg[n - i + j] == 0) {\n                g[i][j] = \"Q\";\n                col[j] = dg[i + j] = udg[n - i + j] = 1;\n                dfs(i + 1);\n                col[j] = dg[i + j] = udg[n - i + j] = 0;\n                g[i][j] = \".\";\n            }\n        }\n    }\n}",
    "52. N-Queens II": "class Solution {\n    private int n;\n    private int ans;\n    private boolean[] cols = new boolean[10];\n    private boolean[] dg = new boolean[20];\n    private boolean[] udg = new boolean[20];\n\n    public int totalNQueens(int n) {\n        this.n = n;\n        dfs(0);\n        return ans;\n    }\n\n    private void dfs(int i) {\n        if (i == n) {\n            ++ans;\n            return;\n        }\n        for (int j = 0; j < n; ++j) {\n            int a = i + j, b = i - j + n;\n            if (cols[j] || dg[a] || udg[b]) {\n                continue;\n            }\n            cols[j] = true;\n            dg[a] = true;\n            udg[b] = true;\n            dfs(i + 1);\n            cols[j] = false;\n            dg[a] = false;\n            udg[b] = false;\n        }\n    }\n}",
    "53. Maximum Subarray": "class Solution {\n    public int maxSubArray(int[] nums) {\n        int ans = nums[0];\n        for (int i = 1, f = nums[0]; i < nums.length; ++i) {\n            f = Math.max(f, 0) + nums[i];\n            ans = Math.max(ans, f);\n        }\n        return ans;\n    }\n}",
    "54. Spiral Matrix": "class Solution {\n    public List<Integer> spiralOrder(int[][] matrix) {\n        int m = matrix.length, n = matrix[0].length;\n        int[] dirs = {0, 1, 0, -1, 0};\n        int i = 0, j = 0, k = 0;\n        List<Integer> ans = new ArrayList<>();\n        boolean[][] vis = new boolean[m][n];\n        for (int h = m * n; h > 0; --h) {\n            ans.add(matrix[i][j]);\n            vis[i][j] = true;\n            int x = i + dirs[k], y = j + dirs[k + 1];\n            if (x < 0 || x >= m || y < 0 || y >= n || vis[x][y]) {\n                k = (k + 1) % 4;\n            }\n            i += dirs[k];\n            j += dirs[k + 1];\n        }\n        return ans;\n    }\n}",
    "55. Jump Game": "class Solution {\n    public boolean canJump(int[] nums) {\n        int mx = 0;\n        for (int i = 0; i < nums.length; ++i) {\n            if (mx < i) {\n                return false;\n            }\n            mx = Math.max(mx, i + nums[i]);\n        }\n        return true;\n    }\n}",
    "56. Merge Intervals": "class Solution {\n    public int[][] merge(int[][] intervals) {\n        Arrays.sort(intervals, (a, b) -> a[0] - b[0]);\n        List<int[]> ans = new ArrayList<>();\n        ans.add(intervals[0]);\n        for (int i = 1; i < intervals.length; ++i) {\n            int s = intervals[i][0], e = intervals[i][1];\n            if (ans.get(ans.size() - 1)[1] < s) {\n                ans.add(intervals[i]);\n            } else {\n                ans.get(ans.size() - 1)[1] = Math.max(ans.get(ans.size() - 1)[1], e);\n            }\n        }\n        return ans.toArray(new int[ans.size()][]);\n    }\n}",
    "57. Insert Interval": "class Solution {\n    public int[][] insert(int[][] intervals, int[] newInterval) {\n        int[][] newIntervals = new int[intervals.length + 1][2];\n        for (int i = 0; i < intervals.length; ++i) {\n            newIntervals[i] = intervals[i];\n        }\n        newIntervals[intervals.length] = newInterval;\n        return merge(newIntervals);\n    }\n\n    private int[][] merge(int[][] intervals) {\n        Arrays.sort(intervals, (a, b) -> a[0] - b[0]);\n        List<int[]> ans = new ArrayList<>();\n        ans.add(intervals[0]);\n        for (int i = 1; i < intervals.length; ++i) {\n            int s = intervals[i][0], e = intervals[i][1];\n            if (ans.get(ans.size() - 1)[1] < s) {\n                ans.add(intervals[i]);\n            } else {\n                ans.get(ans.size() - 1)[1] = Math.max(ans.get(ans.size() - 1)[1], e);\n            }\n        }\n        return ans.toArray(new int[ans.size()][]);\n    }\n}",
    "58. Length of Last Word": "class Solution {\n    public int lengthOfLastWord(String s) {\n        int i = s.length() - 1;\n        while (i >= 0 && s.charAt(i) == ' ') {\n            --i;\n        }\n        int j = i;\n        while (j >= 0 && s.charAt(j) != ' ') {\n            --j;\n        }\n        return i - j;\n    }\n}",
    "59. Spiral Matrix II": "class Solution {\n    public int[][] generateMatrix(int n) {\n        int[][] ans = new int[n][n];\n        int i = 0, j = 0, k = 0;\n        int[][] dirs = { {0, 1}, {1, 0}, {0, -1}, {-1, 0} };\n        for (int v = 1; v <= n * n; ++v) {\n            ans[i][j] = v;\n            int x = i + dirs[k][0], y = j + dirs[k][1];\n            if (x < 0 || y < 0 || x >= n || y >= n || ans[x][y] > 0) {\n                k = (k + 1) % 4;\n                x = i + dirs[k][0];\n                y = j + dirs[k][1];\n            }\n            i = x;\n            j = y;\n        }\n        return ans;\n    }\n}",
    "60. Permutation Sequence": "class Solution {\n    public String getPermutation(int n, int k) {\n        StringBuilder ans = new StringBuilder();\n        boolean[] vis = new boolean[n + 1];\n        for (int i = 0; i < n; ++i) {\n            int fact = 1;\n            for (int j = 1; j < n - i; ++j) {\n                fact *= j;\n            }\n            for (int j = 1; j <= n; ++j) {\n                if (!vis[j]) {\n                    if (k > fact) {\n                        k -= fact;\n                    } else {\n                        ans.append(j);\n                        vis[j] = true;\n                        break;\n                    }\n                }\n            }\n        }\n        return ans.toString();\n    }\n}",
    "61. Rotate List": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if (head == null || head.next == null) {\n            return head;\n        }\n        ListNode cur = head;\n        int n = 0;\n        for (; cur != null; cur = cur.next) {\n            n++;\n        }\n        k %= n;\n        if (k == 0) {\n            return head;\n        }\n        ListNode fast = head;\n        ListNode slow = head;\n        while (k-- > 0) {\n            fast = fast.next;\n        }\n        while (fast.next != null) {\n            fast = fast.next;\n            slow = slow.next;\n        }\n        ListNode ans = slow.next;\n        slow.next = null;\n        fast.next = head;\n        return ans;\n    }\n}",
    "62. Unique Paths": "class Solution {\n    public int uniquePaths(int m, int n) {\n        int[] f = new int[n];\n        Arrays.fill(f, 1);\n        for (int i = 1; i < m; ++i) {\n            for (int j = 1; j < n; ++j) {\n                f[j] += f[j - 1];\n            }\n        }\n        return f[n - 1];\n    }\n}",
    "63. Unique Paths II": "class Solution {\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\n        int m = obstacleGrid.length, n = obstacleGrid[0].length;\n        int[][] dp = new int[m][n];\n        for (int i = 0; i < m && obstacleGrid[i][0] == 0; ++i) {\n            dp[i][0] = 1;\n        }\n        for (int j = 0; j < n && obstacleGrid[0][j] == 0; ++j) {\n            dp[0][j] = 1;\n        }\n        for (int i = 1; i < m; ++i) {\n            for (int j = 1; j < n; ++j) {\n                if (obstacleGrid[i][j] == 0) {\n                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n                }\n            }\n        }\n        return dp[m - 1][n - 1];\n    }\n}",
    "64. Minimum Path Sum": "class Solution {\n    public int minPathSum(int[][] grid) {\n        int m = grid.length, n = grid[0].length;\n        int[][] f = new int[m][n];\n        f[0][0] = grid[0][0];\n        for (int i = 1; i < m; ++i) {\n            f[i][0] = f[i - 1][0] + grid[i][0];\n        }\n        for (int j = 1; j < n; ++j) {\n            f[0][j] = f[0][j - 1] + grid[0][j];\n        }\n        for (int i = 1; i < m; ++i) {\n            for (int j = 1; j < n; ++j) {\n                f[i][j] = Math.min(f[i - 1][j], f[i][j - 1]) + grid[i][j];\n            }\n        }\n        return f[m - 1][n - 1];\n    }\n}",
    "65. Valid Number": "class Solution {\n    public boolean isNumber(String s) {\n        int n = s.length();\n        int i = 0;\n        if (s.charAt(i) == '+' || s.charAt(i) == '-') {\n            ++i;\n        }\n        if (i == n) {\n            return false;\n        }\n        if (s.charAt(i) == '.'\n            && (i + 1 == n || s.charAt(i + 1) == 'e' || s.charAt(i + 1) == 'E')) {\n            return false;\n        }\n        int dot = 0, e = 0;\n        for (int j = i; j < n; ++j) {\n            if (s.charAt(j) == '.') {\n                if (e > 0 || dot > 0) {\n                    return false;\n                }\n                ++dot;\n            } else if (s.charAt(j) == 'e' || s.charAt(j) == 'E') {\n                if (e > 0 || j == i || j == n - 1) {\n                    return false;\n                }\n                ++e;\n                if (s.charAt(j + 1) == '+' || s.charAt(j + 1) == '-') {\n                    if (++j == n - 1) {\n                        return false;\n                    }\n                }\n            } else if (s.charAt(j) < '0' || s.charAt(j) > '9') {\n                return false;\n            }\n        }\n        return true;\n    }\n}",
    "66. Plus One": "class Solution {\n    public int[] plusOne(int[] digits) {\n        int n = digits.length;\n        for (int i = n - 1; i >= 0; --i) {\n            ++digits[i];\n            digits[i] %= 10;\n            if (digits[i] != 0) {\n                return digits;\n            }\n        }\n        digits = new int[n + 1];\n        digits[0] = 1;\n        return digits;\n    }\n}",
    "67. Add Binary": "class Solution {\n    public String addBinary(String a, String b) {\n        var sb = new StringBuilder();\n        int i = a.length() - 1, j = b.length() - 1;\n        for (int carry = 0; i >= 0 || j >= 0 || carry > 0; --i, --j) {\n            carry += (i >= 0 ? a.charAt(i) - '0' : 0) + (j >= 0 ? b.charAt(j) - '0' : 0);\n            sb.append(carry % 2);\n            carry /= 2;\n        }\n        return sb.reverse().toString();\n    }\n}",
    "68. Text Justification": "class Solution {\n    public List<String> fullJustify(String[] words, int maxWidth) {\n        List<String> ans = new ArrayList<>();\n        for (int i = 0, n = words.length; i < n;) {\n            List<String> t = new ArrayList<>();\n            t.add(words[i]);\n            int cnt = words[i].length();\n            ++i;\n            while (i < n && cnt + 1 + words[i].length() <= maxWidth) {\n                cnt += 1 + words[i].length();\n                t.add(words[i++]);\n            }\n            if (i == n || t.size() == 1) {\n                String left = String.join(\" \", t);\n                String right = \" \".repeat(maxWidth - left.length());\n                ans.add(left + right);\n                continue;\n            }\n            int spaceWidth = maxWidth - (cnt - t.size() + 1);\n            int w = spaceWidth / (t.size() - 1);\n            int m = spaceWidth % (t.size() - 1);\n            StringBuilder row = new StringBuilder();\n            for (int j = 0; j < t.size() - 1; ++j) {\n                row.append(t.get(j));\n                row.append(\" \".repeat(w + (j < m ? 1 : 0)));\n            }\n            row.append(t.get(t.size() - 1));\n            ans.add(row.toString());\n        }\n        return ans;\n    }\n}",
    "70. Climbing Stairs": "class Solution {\n    public int climbStairs(int n) {\n        int a = 0, b = 1;\n        for (int i = 0; i < n; ++i) {\n            int c = a + b;\n            a = b;\n            b = c;\n        }\n        return b;\n    }\n}",
    "71. Simplify Path": "class Solution {\n    public String simplifyPath(String path) {\n        Deque<String> stk = new ArrayDeque<>();\n        for (String s : path.split(\"/\")) {\n            if (\"\".equals(s) || \".\".equals(s)) {\n                continue;\n            }\n            if (\"..\".equals(s)) {\n                stk.pollLast();\n            } else {\n                stk.offerLast(s);\n            }\n        }\n        return \"/\" + String.join(\"/\", stk);\n    }\n}",
    "72. Edit Distance": "class Solution {\n    public int minDistance(String word1, String word2) {\n        int m = word1.length(), n = word2.length();\n        int[][] f = new int[m + 1][n + 1];\n        for (int j = 1; j <= n; ++j) {\n            f[0][j] = j;\n        }\n        for (int i = 1; i <= m; ++i) {\n            f[i][0] = i;\n            for (int j = 1; j <= n; ++j) {\n                if (word1.charAt(i - 1) == word2.charAt(j - 1)) {\n                    f[i][j] = f[i - 1][j - 1];\n                } else {\n                    f[i][j] = Math.min(f[i - 1][j], Math.min(f[i][j - 1], f[i - 1][j - 1])) + 1;\n                }\n            }\n        }\n        return f[m][n];\n    }\n}",
    "73. Set Matrix Zeroes": "class Solution {\n    public void setZeroes(int[][] matrix) {\n        int m = matrix.length, n = matrix[0].length;\n        boolean i0 = false, j0 = false;\n        for (int j = 0; j < n; ++j) {\n            if (matrix[0][j] == 0) {\n                i0 = true;\n                break;\n            }\n        }\n        for (int i = 0; i < m; ++i) {\n            if (matrix[i][0] == 0) {\n                j0 = true;\n                break;\n            }\n        }\n        for (int i = 1; i < m; ++i) {\n            for (int j = 1; j < n; ++j) {\n                if (matrix[i][j] == 0) {\n                    matrix[i][0] = 0;\n                    matrix[0][j] = 0;\n                }\n            }\n        }\n        for (int i = 1; i < m; ++i) {\n            for (int j = 1; j < n; ++j) {\n                if (matrix[i][0] == 0 || matrix[0][j] == 0) {\n                    matrix[i][j] = 0;\n                }\n            }\n        }\n        if (i0) {\n            for (int j = 0; j < n; ++j) {\n                matrix[0][j] = 0;\n            }\n        }\n        if (j0) {\n            for (int i = 0; i < m; ++i) {\n                matrix[i][0] = 0;\n            }\n        }\n    }\n}",
    "74. Search a 2D Matrix": "class Solution {\n    public boolean searchMatrix(int[][] matrix, int target) {\n        int m = matrix.length, n = matrix[0].length;\n        int left = 0, right = m * n - 1;\n        while (left < right) {\n            int mid = (left + right) >> 1;\n            int x = mid / n, y = mid % n;\n            if (matrix[x][y] >= target) {\n                right = mid;\n            } else {\n                left = mid + 1;\n            }\n        }\n        return matrix[left / n][left % n] == target;\n    }\n}",
    "75. Sort Colors": "class Solution {\n    public void sortColors(int[] nums) {\n        int i = -1, j = nums.length, k = 0;\n        while (k < j) {\n            if (nums[k] == 0) {\n                swap(nums, ++i, k++);\n            } else if (nums[k] == 2) {\n                swap(nums, --j, k);\n            } else {\n                ++k;\n            }\n        }\n    }\n\n    private void swap(int[] nums, int i, int j) {\n        int t = nums[i];\n        nums[i] = nums[j];\n        nums[j] = t;\n    }\n}",
    "76. Minimum Window Substring": "class Solution {\n    public String minWindow(String s, String t) {\n        int[] need = new int[128];\n        int[] window = new int[128];\n        int m = s.length(), n = t.length();\n        for (int i = 0; i < n; ++i) {\n            ++need[t.charAt(i)];\n        }\n        int cnt = 0, j = 0, k = -1, mi = 1 << 30;\n        for (int i = 0; i < m; ++i) {\n            ++window[s.charAt(i)];\n            if (need[s.charAt(i)] >= window[s.charAt(i)]) {\n                ++cnt;\n            }\n            while (cnt == n) {\n                if (i - j + 1 < mi) {\n                    mi = i - j + 1;\n                    k = j;\n                }\n                if (need[s.charAt(j)] >= window[s.charAt(j)]) {\n                    --cnt;\n                }\n                --window[s.charAt(j++)];\n            }\n        }\n        return k < 0 ? \"\" : s.substring(k, k + mi);\n    }\n}",
    "77. Combinations": "public class Combinations {\n\n    public class Solution_dfs {\n\n        List<List<Integer>> result = new ArrayList<>();\n        List<Integer> tmp = new ArrayList<>();\n\n        public List<List<Integer>> combine(int n, int k) {\n\n            if (k > n || n <= 0 || k <= 0) {\n                return result;\n            }\n\n            dfs(n, k, 1);\n\n            return result;\n\n        }\n\n        private void dfs(int n, int k, int start) {\n\n            if (k == 0) {\n                result.add(new ArrayList<>(tmp));\n                return;\n            }\n\n            for (int i = start; i <= n; i++) {\n                tmp.add(i);\n                dfs(n, k - 1, i + 1);\n                tmp.remove(tmp.size() - 1);\n            }\n\n        }\n    }\n\n    public class Solution_iteration {\n        public List<List<Integer>> combine(int n, int k) {\n\n            List<List<Integer>> res = new ArrayList<>();\n            int[] out = new int[k];\n\n            int i = 0;\n            while (i >= 0) {\n                ++out[i];\n                if (out[i] > n) --i;\n                else if (i == k - 1) res.add(Arrays.stream(out).boxed().collect(Collectors.toList()));\n                else {\n                    ++i;\n                    out[i] = out[i - 1];\n                }\n            }\n\n            return res;\n        }\n    }\n\n}\n\n\n//////\n\nclass Solution {\n    public List<List<Integer>> combine(int n, int k) {\n        List<List<Integer>> res = new ArrayList<>();\n        dfs(1, n, k, new ArrayList<>(), res);\n        return res;\n    }\n\n    private void dfs(int i, int n, int k, List<Integer> t, List<List<Integer>> res) {\n        if (t.size() == k) {\n            res.add(new ArrayList<>(t));\n            return;\n        }\n        for (int j = i; j <= n; ++j) {\n            t.add(j);\n            dfs(j + 1, n, k, t, res);\n            t.remove(t.size() - 1);\n        }\n    }\n}",
    "78. Subsets": "class Solution {\n    private List<List<Integer>> ans = new ArrayList<>();\n    private List<Integer> t = new ArrayList<>();\n    private int[] nums;\n\n    public List<List<Integer>> subsets(int[] nums) {\n        this.nums = nums;\n        dfs(0);\n        return ans;\n    }\n\n    private void dfs(int i) {\n        if (i == nums.length) {\n            ans.add(new ArrayList<>(t));\n            return;\n        }\n        dfs(i + 1);\n        t.add(nums[i]);\n        dfs(i + 1);\n        t.remove(t.size() - 1);\n    }\n}",
    "79. Word Search": "class Solution {\n    private int m;\n    private int n;\n    private String word;\n    private char[][] board;\n\n    public boolean exist(char[][] board, String word) {\n        m = board.length;\n        n = board[0].length;\n        this.word = word;\n        this.board = board;\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (dfs(i, j, 0)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    private boolean dfs(int i, int j, int k) {\n        if (k == word.length() - 1) {\n            return board[i][j] == word.charAt(k);\n        }\n        if (board[i][j] != word.charAt(k)) {\n            return false;\n        }\n        char c = board[i][j];\n        board[i][j] = '0';\n        int[] dirs = {-1, 0, 1, 0, -1};\n        for (int u = 0; u < 4; ++u) {\n            int x = i + dirs[u], y = j + dirs[u + 1];\n            if (x >= 0 && x < m && y >= 0 && y < n && board[x][y] != '0' && dfs(x, y, k + 1)) {\n                return true;\n            }\n        }\n        board[i][j] = c;\n        return false;\n    }\n}",
    "80. Remove Duplicates from Sorted Array II": "class Solution {\n    public int removeDuplicates(int[] nums) {\n        int k = 0;\n        for (int x : nums) {\n            if (k < 2 || x != nums[k - 2]) {\n                nums[k++] = x;\n            }\n        }\n        return k;\n    }\n}",
    "81. Search in Rotated Sorted Array II": "class Solution {\n    public boolean search(int[] nums, int target) {\n        int l = 0, r = nums.length - 1;\n        while (l < r) {\n            int mid = (l + r) >> 1;\n            if (nums[mid] > nums[r]) {\n                if (nums[l] <= target && target <= nums[mid]) {\n                    r = mid;\n                } else {\n                    l = mid + 1;\n                }\n            } else if (nums[mid] < nums[r]) {\n                if (nums[mid] < target && target <= nums[r]) {\n                    l = mid + 1;\n                } else {\n                    r = mid;\n                }\n            } else {\n                --r;\n            }\n        }\n        return nums[l] == target;\n    }\n}",
    "82. Remove Duplicates from Sorted List II": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode deleteDuplicates(ListNode head) {\n        ListNode dummy = new ListNode(0, head);\n        ListNode pre = dummy;\n        ListNode cur = head;\n        while (cur != null) {\n            while (cur.next != null && cur.next.val == cur.val) {\n                cur = cur.next;\n            }\n            if (pre.next == cur) {\n                pre = cur;\n            } else {\n                pre.next = cur.next;\n            }\n            cur = cur.next;\n        }\n        return dummy.next;\n    }\n}",
    "83. Remove Duplicates from Sorted List": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode deleteDuplicates(ListNode head) {\n        ListNode cur = head;\n        while (cur != null && cur.next != null) {\n            if (cur.val == cur.next.val) {\n                cur.next = cur.next.next;\n            } else {\n                cur = cur.next;\n            }\n        }\n        return head;\n    }\n}",
    "84. Largest Rectangle in Histogram": "class Solution {\n    public int largestRectangleArea(int[] heights) {\n        int res = 0, n = heights.length;\n        Deque<Integer> stk = new ArrayDeque<>();\n        int[] left = new int[n];\n        int[] right = new int[n];\n        Arrays.fill(right, n);\n        for (int i = 0; i < n; ++i) {\n            while (!stk.isEmpty() && heights[stk.peek()] >= heights[i]) {\n                right[stk.pop()] = i;\n            }\n            left[i] = stk.isEmpty() ? -1 : stk.peek();\n            stk.push(i);\n        }\n        for (int i = 0; i < n; ++i) {\n            res = Math.max(res, heights[i] * (right[i] - left[i] - 1));\n        }\n        return res;\n    }\n}",
    "85. Maximal Rectangle": "import java.util.Arrays;\nimport java.util.Stack;\n\npublic class Solution {\n        public int maximalRectangle(char[][] m) {\n            /*\n         original:\n\n         \"0010\",\n         \"1111\",\n         \"1111\",\n         \"0111\",\n         \"1100\",\n         \"1111\",\n         \"1110\"\n\n         */\n\n\n\n  /*\n   \"01101\",\n   \"11010\",\n   \"01110\",\n   \"11110\",\n   \"11111\",\n   \"00000\",\n\n\n   [0, 1, 1, 0, 1],\n   [1, 2, 0, 1, 0],\n   [0, 3, 1, 2, 0],\n   [1, 4, 2, 3, 0],\n   [2, 5, 3, 4, 1],\n   [0, 0, 0, 0, 0]]\n  */\n\n            if (m == null || m.length == 0) {\n                return 0;\n            }\n\n\n            int row = m.length;\n            int col = m[0].length;\n\n            // build dp, dp[i][j]\u5c31\u662f\u5f53\u524d\u7684\u7b2cj\u5217\u7684\uff0c\u4ece\u4e0a\u9762\u5f00\u59cb\u5230\u7b2ci\u884c\u8fde\u7eed1\u7684\u4e2a\u6570\n            int[][] dp = new int[row][col];\n\n            // process first row\n            for (int j = 0; j < col; j++) {\n                dp[0][j] = m[0][j] - '0';\n            }\n\n            //@note: assumption, at least 2 rows\n            for (int i = 1; i < row; i++) {\n                for (int j = 0; j < col; j++) {\n                    if (m[i][j] - '0' != 0) {\n                        dp[i][j] = 1 + dp[i - 1][j];\n                    }\n                }\n            }\n\n            if (m.length == 1) {\n                return findRowMax(dp[0]);\n            }\n\n\n            // search each row of dp array\n            int max = 0;\n            for (int i = 0; i < row; i++) {\n                int rowMax = findRowMax(dp[i]);\n                max = max > rowMax ? max : rowMax;\n            }\n\n            return max;\n        }\n\n        public int findRowMax(int[] rowOriginal) {\n\n            int[] row = new int[rowOriginal.length + 1];\n            row = Arrays.copyOfRange(rowOriginal, 0, rowOriginal.length + 1);\n\n            int max = 0;\n            int length = row.length;\n\n            // stack store index, not the actual value\n            Stack<Integer> sk = new Stack<>();\n            int i = 0;\n            while (i < length) {\n                // if (i == 0 || row[i] >= row[sk.peek()]) {\n                if (sk.isEmpty() || row[i] >= row[sk.peek()]) {\n                    sk.push(i);\n                    i++;\n                } else {\n\n                    // while (!sk.isEmpty() && row[i] < row[sk.peek()]) {\n\n                    //     int index = sk.pop();\n                    //     int prevIndex = sk.isEmpty()? 0 : sk.peek();\n\n                    //     int area = (i - 1 - prevIndex) * row[index]; // i-1 is the highest bar before i\n                    //     max = max > area ? max : area;\n\n                    // }\n\n                    int index = sk.pop();\n                    // int prevIndex = sk.isEmpty()? 0 : sk.peek();\n                    // int prevIndex = sk.isEmpty() ? i : sk.peek();\n\n                    // \u8fd9\u91cc\u662f\uff1a\u9ad8\u5ea6(row[index]) * \u957f\u5ea6\n                    int area = (sk.isEmpty() ? i : (i - 1 - sk.peek())) * row[index]; // i-1 is the highest bar before i\n                    max = max > area ? max : area;\n\n                    // sk.push(i++);\n                }\n            }\n\n            // final check when reaching end of array. OR add dummy number to array end\n            // while (!sk.isEmpty()) {\n\n            //     int index = sk.pop();\n            //     int prevIndex = sk.isEmpty()? 0 : sk.peek();\n\n            //     int area = (i - 1 - prevIndex) * row[index]; // i-1 is the highest bar before i\n            //     max = max > area ? max : area;\n            // }\n\n            return max;\n        }\n    }\n\n}\n\n############\n\nclass Solution {\n    public int maximalRectangle(char[][] matrix) {\n        int n = matrix[0].length;\n        int[] heights = new int[n];\n        int ans = 0;\n        for (var row : matrix) {\n            for (int j = 0; j < n; ++j) {\n                if (row[j] == '1') {\n                    heights[j] += 1;\n                } else {\n                    heights[j] = 0;\n                }\n            }\n            ans = Math.max(ans, largestRectangleArea(heights));\n        }\n        return ans;\n    }\n\n    private int largestRectangleArea(int[] heights) {\n        int res = 0, n = heights.length;\n        Deque<Integer> stk = new ArrayDeque<>();\n        int[] left = new int[n];\n        int[] right = new int[n];\n        Arrays.fill(right, n);\n        for (int i = 0; i < n; ++i) {\n            while (!stk.isEmpty() && heights[stk.peek()] >= heights[i]) {\n                right[stk.pop()] = i;\n            }\n            left[i] = stk.isEmpty() ? -1 : stk.peek();\n            stk.push(i);\n        }\n        for (int i = 0; i < n; ++i) {\n            res = Math.max(res, heights[i] * (right[i] - left[i] - 1));\n        }\n        return res;\n    }\n}",
    "86. Partition List": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode partition(ListNode head, int x) {\n        ListNode d1 = new ListNode();\n        ListNode d2 = new ListNode();\n        ListNode t1 = d1, t2 = d2;\n        while (head != null) {\n            if (head.val < x) {\n                t1.next = head;\n                t1 = t1.next;\n            } else {\n                t2.next = head;\n                t2 = t2.next;\n            }\n            head = head.next;\n        }\n        t1.next = d2.next;\n        t2.next = null;\n        return d1.next;\n    }\n}",
    "87. Scramble String": "class Solution {\n    private Boolean[][][] f;\n    private String s1;\n    private String s2;\n\n    public boolean isScramble(String s1, String s2) {\n        int n = s1.length();\n        this.s1 = s1;\n        this.s2 = s2;\n        f = new Boolean[n][n][n + 1];\n        return dfs(0, 0, n);\n    }\n\n    private boolean dfs(int i, int j, int k) {\n        if (f[i][j][k] != null) {\n            return f[i][j][k];\n        }\n        if (k == 1) {\n            return s1.charAt(i) == s2.charAt(j);\n        }\n        for (int h = 1; h < k; ++h) {\n            if (dfs(i, j, h) && dfs(i + h, j + h, k - h)) {\n                return f[i][j][k] = true;\n            }\n            if (dfs(i + h, j, k - h) && dfs(i, j + k - h, h)) {\n                return f[i][j][k] = true;\n            }\n        }\n        return f[i][j][k] = false;\n    }\n}",
    "88. Merge Sorted Array": "class Solution {\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\n        for (int i = m - 1, j = n - 1, k = m + n - 1; j >= 0; --k) {\n            nums1[k] = i >= 0 && nums1[i] > nums2[j] ? nums1[i--] : nums2[j--];\n        }\n    }\n}",
    "90. Subsets II": "class Solution {\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\n        Arrays.sort(nums);\n        int n = nums.length;\n        List<List<Integer>> ans = new ArrayList<>();\n        for (int mask = 0; mask < 1 << n; ++mask) {\n            List<Integer> t = new ArrayList<>();\n            boolean ok = true;\n            for (int i = 0; i < n; ++i) {\n                if ((mask >> i & 1) == 1) {\n                    if (i > 0 && (mask >> (i - 1) & 1) == 0 && nums[i] == nums[i - 1]) {\n                        ok = false;\n                        break;\n                    }\n                    t.add(nums[i]);\n                }\n            }\n            if (ok) {\n                ans.add(t);\n            }\n        }\n        return ans;\n    }\n}",
    "91. Decode Ways": "class Solution {\n    public int numDecodings(String s) {\n        int n = s.length();\n        int f = 0, g = 1;\n        for (int i = 1; i <= n; ++i) {\n            int h = s.charAt(i - 1) != '0' ? g : 0;\n            if (i > 1 && s.charAt(i - 2) != '0' && Integer.valueOf(s.substring(i - 2, i)) <= 26) {\n                h += f;\n            }\n            f = g;\n            g = h;\n        }\n        return g;\n    }\n}",
    "92. Reverse Linked List II": "import java.util.Stack;\n\npublic class Reverse_Linked_List_II {\n\n /**\n  * Definition for singly-linked list.\n  * public class ListNode {\n  *     int val;\n  *     ListNode next;\n  *     ListNode(int x) { val = x; }\n  * }\n  */\n\n public class Solution_optimize {\n     public ListNode reverseBetween(ListNode head, int m, int n) {\n\n         ListNode dummy = new ListNode(0);\n         ListNode prev = dummy;\n\n         // I missed this one\n         prev.next = head;\n\n         ListNode p = head;\n\n         for (int i = 1; i < m; i++) {\n             prev = p;\n             p = p.next;\n         }\n\n         // @note:@memorize: now p is pointing to m-th node\n         ListNode originalFirst = p;\n         for (int i = m; i < n; i++) {\n             ListNode currentHead = prev.next;\n             ListNode futureHead = originalFirst.next;\n\n             // swap\n             // prev.next = currentHead.next;\n             prev.next = futureHead;\n             // currentHead.next = futureHead.next;\n             originalFirst.next = futureHead.next;\n             futureHead.next = currentHead;\n         }\n\n         return dummy.next;\n     }\n }\n\n\n public class Solution {\n     public ListNode reverseBetween(ListNode head, int m, int n) {\n\n      if (m > n) {\n          return reverseBetween(head, n, m);\n         }\n\n      int diff = n - m;\n      if (diff == 0) {\n       return head;\n      }\n\n      ListNode p1 = head;\n\n      // set diff for both pointers\n      // @note: corner case: n-m > list-length\n      while (diff > 0 && p1 != null) {\n       p1 = p1.next;\n       diff--;\n      }\n\n      ListNode dummy = new ListNode(0);\n      dummy.next = head;\n\n      ListNode prev = dummy;\n      ListNode p2 = head;\n\n      int mm = m;\n      while (mm - 1> 0) {\n       prev = prev.next;\n       p1 = p1.next;\n       p2 = p2.next;\n\n       mm--;\n      }\n\n      ListNode nextRecord = p1.next;\n      diff = n - m;\n\n      // start reverse from p1 to p2\n      // 1->2->3->4->5\n      Stack<ListNode> sk = new Stack<>();\n      while (p2 != p1.next) { // @note: here, when p1==p2 should enter loop\n       sk.push(p2);\n       p2 = p2.next;\n      }\n\n      while (!sk.isEmpty()) {\n       prev.next = sk.pop();\n       prev = prev.next;\n      }\n\n      prev.next = nextRecord;\n\n      return dummy.next;\n     }\n }\n}\n\n############\n\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode reverseBetween(ListNode head, int left, int right) {\n        if (head.next == null || left == right) {\n            return head;\n        }\n        ListNode dummy = new ListNode(0, head);\n        ListNode pre = dummy;\n        for (int i = 0; i < left - 1; ++i) {\n            pre = pre.next;\n        }\n        ListNode p = pre;\n        ListNode q = pre.next;\n        ListNode cur = q;\n        for (int i = 0; i < right - left + 1; ++i) {\n            ListNode t = cur.next;\n            cur.next = pre;\n            pre = cur;\n            cur = t;\n        }\n        p.next = pre;\n        q.next = cur;\n        return dummy.next;\n    }\n}",
    "93. Restore IP Addresses": "class Solution {\n    private int n;\n    private String s;\n    private List<String> ans = new ArrayList<>();\n    private List<String> t = new ArrayList<>();\n\n    public List<String> restoreIpAddresses(String s) {\n        n = s.length();\n        this.s = s;\n        dfs(0);\n        return ans;\n    }\n\n    private void dfs(int i) {\n        if (i >= n && t.size() == 4) {\n            ans.add(String.join(\".\", t));\n            return;\n        }\n        if (i >= n || t.size() >= 4) {\n            return;\n        }\n        int x = 0;\n        for (int j = i; j < Math.min(i + 3, n); ++j) {\n            x = x * 10 + s.charAt(j) - '0';\n            if (x > 255 || (s.charAt(i) == '0' && i != j)) {\n                break;\n            }\n            t.add(s.substring(i, j + 1));\n            dfs(j + 1);\n            t.remove(t.size() - 1);\n        }\n    }\n}\n\n//////\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Restore_IP_Addresses {\n\n public static void main(String[] args) {\n\n  // @note:@memorize: test substring boundary\n  String a = \"abc\";\n  // a = a.substring(0, 4); // String index out of range: 4\n  a = a.substring(0, 3); // ok\n  System.out.println(a);\n\n  Restore_IP_Addresses out = new Restore_IP_Addresses();\n  Solution s = out.new Solution();\n\n  for (String each: (s.restoreIpAddresses(\"25525511135\"))) {\n   System.out.println(each);\n  }\n }\n\n List<String> list = new ArrayList<>();\n\n public class Solution {\n     public List<String> restoreIpAddresses(String s) {\n\n      if (s.length() < 4 || s.length() > 12 || !s.matches(\"\\\\d+\")) {\n          return list;\n         }\n\n      restore(s, \"\", 0);\n\n      return list;\n     }\n\n     // seg: segment, in total 4\n     private void restore(String s, String result, int seg) {\n      if (seg == 4) {\n       if (s.length() == 0) {\n\n        // remove last \".\"\n        result = result.substring(0, result.length() - 1);\n\n        list.add(result);\n       }\n\n       return;\n      }\n\n      // for (int i = 0; i < 3; i++) { // @note: out of boundary\n      for (int i = 0; i < 3 && i < s.length(); i++) {\n       String thisSeg = s.substring(0, i + 1);\n\n       if (isValid(thisSeg)) {\n        restore(s.substring(i + 1), result + thisSeg + \".\", seg + 1);\n       }\n      }\n     }\n\n     private boolean isValid(String s) {\n\n      // can NOT be: 10.01.1.1\n      if (s.length() > 1 && s.startsWith(\"0\")) {\n       return false;\n      }\n\n      int n = Integer.valueOf(s);\n      if (n > 255) {\n       return false;\n      }\n\n      return true;\n     }\n }\n}",
    "94. Binary Tree Inorder Traversal": "import java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Stack;\n\npublic class Binary_Tree_Inorder_Traversal {\n\n /**\n  * Definition for a binary tree node.\n  * public class TreeNode {\n  *     int val;\n  *     TreeNode left;\n  *     TreeNode right;\n  *     TreeNode(int x) { val = x; }\n  * }\n  */\n\n    public class Solution_optmize {\n        public List<Integer> inorderTraversal(TreeNode root) {\n\n            List<Integer> list = new ArrayList<Integer>();\n            if (root == null) {\n                return list;\n            }\n\n            Stack<TreeNode> sk = new Stack<>();\n            TreeNode current = root;\n\n            while (!sk.isEmpty() || current != null) {\n\n                while (current != null) {\n                    sk.push(current);\n                    current = current.left;\n                } // @note: \u4e00\u903c\u64b8\u5230\u6700\u5de6\u8fb9\n\n                // @note: \u6ca1\u6709push left\u7684\u64cd\u4f5c\uff0c\u5c31\u4e0d\u4f1a\u65e0\u9650\u5faa\u73af\uff0c\u4e5f\u4e0d\u9700\u8981mark\u662f\u5426visited\n                TreeNode leftOrMiddle = sk.pop();\n                list.add(leftOrMiddle.val);\n\n                current = leftOrMiddle.right; // if right is null here, next time pop parent node\n            }\n\n            return list;\n        }\n    }\n\n    class Solution_noStack { // but modifying original tree\n        public List<Integer> inorderTraversal(TreeNode root) {\n\n            List<Integer> result = new ArrayList<>();\n            TreeNode current = root;\n            TreeNode prev;\n\n            while (current != null) {\n                if (current.left == null) {\n                    result.add(current.val);\n\n                    // only handle right child\n                    current = current.right; // move to next right node\n                } else { // has a left subtree\n                    prev = current.left;\n                    while (prev.right != null) { // find rightmost\n                        prev = prev.right;\n                    }\n                    prev.right = current; // put cur after the pre node\n                    TreeNode temp = current; // store cur node\n                    current = current.left; // move cur to the top of the new tree\n                    temp.left = null; // original cur left be null, avoid infinite loops\n                }\n            }\n\n            return result;\n        }\n    }\n\n    public class Solution {\n\n        List<Integer> list = new ArrayList<Integer>();\n\n        public List<Integer> inorderTraversal(TreeNode root) {\n\n            // mark if a node is visited already: true is visited. or, just use a Set\n            HashSet<TreeNode> hs = new HashSet<>();\n\n            Stack<TreeNode> sk = new Stack<>();\n            sk.push(root);\n\n            while (!sk.isEmpty()) {\n\n                TreeNode current = sk.pop();\n\n                if (current == null) {\n                    continue;\n                }\n\n                // @note: careful to check left visited, or else infinite looping\n                if (current.left != null && !hs.contains(current.left)) {\n                    sk.push(current);\n                    sk.push(current.left);\n\n                } else {\n\n                    if (current.right != null && !hs.contains(current.right)) {\n                        sk.push(current.right);\n                    }\n\n                    hs.add(current);\n                    list.add(current.val);\n                }\n            }\n\n            return list;\n        }\n    }\n\n    class Solution_recursion {\n\n        List<Integer> result = new ArrayList<>();\n\n        public List<Integer> inorderTraversal(TreeNode root) {\n            dfs(root);\n            return result;\n        }\n\n        public void dfs(TreeNode root) {\n            if (root == null) {\n                return;\n            }\n\n            dfs(root.left);\n            result.add(root.val);\n            dfs(root.right);\n        }\n    }\n}\n\n//////\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public List<Integer> inorderTraversal(TreeNode root) {\n        List<Integer> ans = new ArrayList<>();\n        while (root != null) {\n            if (root.left == null) {\n                ans.add(root.val);\n                root = root.right;\n            } else {\n                TreeNode prev = root.left;\n                while (prev.right != null && prev.right != root) {\n                    prev = prev.right;\n                }\n                if (prev.right == null) {\n                    prev.right = root;\n                    root = root.left;\n                } else {\n                    ans.add(root.val);\n                    prev.right = null;\n                    root = root.right;\n                }\n            }\n        }\n        return ans;\n    }\n}",
    "95. Unique Binary Search Trees II": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public List<TreeNode> generateTrees(int n) {\n        return dfs(1, n);\n    }\n\n    private List<TreeNode> dfs(int i, int j) {\n        List<TreeNode> ans = new ArrayList<>();\n        if (i > j) {\n            ans.add(null);\n            return ans;\n        }\n        for (int v = i; v <= j; ++v) {\n            var left = dfs(i, v - 1);\n            var right = dfs(v + 1, j);\n            for (var l : left) {\n                for (var r : right) {\n                    ans.add(new TreeNode(v, l, r));\n                }\n            }\n        }\n        return ans;\n    }\n}",
    "96. Unique Binary Search Trees": "public class Unique_Binary_Search_Trees {\n\n    public static void main(String[] args) {\n        Unique_Binary_Search_Trees out = new Unique_Binary_Search_Trees();\n        Solution s = out.new Solution();\n\n        System.out.println(s.numTrees(3));\n    }\n\n    public class Solution {\n        public int numTrees(int n) {\n            if (n <= 0) {\n                return 0;\n            }\n\n            // dp[i] represents the number of BST that can be composed of i numbers\n            int[] dp = new int[n + 1];\n            dp[0] = 1; // null is counted as one unique tree\n\n            for (int i = 1; i <= n; i++) { // 1...n\n\n                for (int j = 1; j <= i; j++) {\n                    // for each fixed n, calculate its sum\n                    dp[i] += dp[j - 1] * dp[i - j];\n                }\n            }\n\n            return dp[n];\n        }\n    }\n\n    public class Solution_recursion {\n        public int numTrees(int n) {\n            if (n < 0) {\n                return 0;\n            }\n\n            if (n == 0 || n == 1) {\n                return 1;\n            }\n\n            int sum = 0;\n\n            for (int i = 1; i <= n; i++) {\n\n                // 2 conditions: unique && BST. => inorder-visit will generate ordered sequence\n                // so, if decide root, then left and right can be calculated\n                // @note: root is \"i\", left has \"i-1\" nodes, right has \"n - (i - 1) - 1\"==\"n - i\" nodes\n                sum += numTrees(i - 1) * numTrees(n - i);\n            }\n\n            return sum;\n        }\n    }\n}\n\n//////\n\nclass Solution {\n    public int numTrees(int n) {\n        int[] dp = new int[n + 1];\n        dp[0] = 1;\n        for (int i = 1; i <= n; ++i) {\n            for (int j = 0; j < i; ++j) {\n                dp[i] += dp[j] * dp[i - j - 1];\n            }\n        }\n        return dp[n];\n    }\n}",
    "97. Interleaving String": "class Solution {\n    public boolean isInterleave(String s1, String s2, String s3) {\n        int m = s1.length(), n = s2.length();\n        if (m + n != s3.length()) {\n            return false;\n        }\n        boolean[] f = new boolean[n + 1];\n        f[0] = true;\n        for (int i = 0; i <= m; ++i) {\n            for (int j = 0; j <= n; ++j) {\n                int k = i + j - 1;\n                if (i > 0) {\n                    f[j] &= s1.charAt(i - 1) == s3.charAt(k);\n                }\n                if (j > 0) {\n                    f[j] |= (f[j - 1] & s2.charAt(j - 1) == s3.charAt(k));\n                }\n            }\n        }\n        return f[n];\n    }\n}\n\n//////\n\npublic class Solution {\n    public boolean isInterleave(String s1, String s2, String s3) {\n        if (s1.length() == 0 || s1 == null) {\n            return s2.equals(s3);\n        }\n\n        if (s2.length() == 0 || s2 == null) {\n            return s1.equals(s3);\n        }\n\n        // @note: missed this simple check\n        if (s1.length() + s2.length() != s3.length()) {\n            return false;\n        }\n\n        // 1-to-i of s1, and 1-to-j of s2, can for 1-to-(i+j) of s3\n        boolean[][] dp = new boolean[s1.length() + 1][s2.length() + 1]; // +1 for empty string\n\n        dp[0][0] = true;\n\n        // pre-process for empty string case\n        for (int i = 1; i < s1.length() + 1; i++) {\n            dp[i][0] = (s1.charAt(i - 1) == s3.charAt(i - 1))\n                && dp[i - 1][0];\n        }\n        for (int i = 1; i < s2.length() + 1; i++) {\n            dp[0][i] = (s2.charAt(i - 1) == s3.charAt(i - 1))\n                && dp[0][i - 1];\n        }\n\n        for (int i = 1; i < s1.length() + 1; i++) {\n            for (int j = 1; j < s2.length() + 1; j++) {\n\n                boolean withS1 = s1.charAt(i - 1) == s3.charAt(i - 1 + j) && dp[i - 1][j];\n                boolean withS2 = s2.charAt(j - 1) == s3.charAt(i - 1 + j) && dp[i][j - 1];\n\n                dp[i][j] = withS1 || withS2;\n            }\n        }\n\n        return dp[s1.length()][s2.length()];\n    }\n}",
    "98. Validate Binary Search Tree": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    private Integer prev;\n\n    public boolean isValidBST(TreeNode root) {\n        prev = null;\n        return dfs(root);\n    }\n\n    private boolean dfs(TreeNode root) {\n        if (root == null) {\n            return true;\n        }\n        if (!dfs(root.left)) {\n            return false;\n        }\n        if (prev != null && prev >= root.val) {\n            return false;\n        }\n        prev = root.val;\n        if (!dfs(root.right)) {\n            return false;\n        }\n        return true;\n    }\n}",
    "99. Recover Binary Search Tree": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    private TreeNode prev;\n    private TreeNode first;\n    private TreeNode second;\n\n    public void recoverTree(TreeNode root) {\n        dfs(root);\n        int t = first.val;\n        first.val = second.val;\n        second.val = t;\n    }\n\n    private void dfs(TreeNode root) {\n        if (root == null) {\n            return;\n        }\n        dfs(root.left);\n        if (prev != null && prev.val > root.val) {\n            if (first == null) {\n                first = prev;\n            }\n            second = root;\n        }\n        prev = root;\n        dfs(root.right);\n    }\n}",
    "100. Same Tree": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\n\npublic class Same_Tree {\n\n    /**\n     * Definition for a binary tree node.\n     * public class TreeNode {\n     * int val;\n     * TreeNode left;\n     * TreeNode right;\n     * TreeNode(int x) { val = x; }\n     * }\n     */\n\n    public class Solution_iteration {\n        public boolean isSameTree(TreeNode p, TreeNode q) {\n            if (p == null) {\n                return q == null;\n            }\n\n            if (q == null) {\n                return p == null;\n            }\n\n            Stack<TreeNode> sk1 = new Stack<TreeNode>();\n            Stack<TreeNode> sk2 = new Stack<TreeNode>();\n\n            sk1.push(p);\n            sk2.push(q);\n\n            while (!sk1.isEmpty() && !sk2.isEmpty()) {\n                TreeNode current1 = sk1.pop();\n                TreeNode current2 = sk2.pop();\n\n                if (current1 == null && current2 == null) {\n                    continue; // @note: missed both null check\n                } else if (current1 == null && current2 != null) {\n                    return false;\n                } else if (current1 != null && current2 == null) {\n                    return false;\n                } else if (current1.val != current2.val) {\n                    return false;\n                }\n\n                sk1.push(current1.left);\n                sk2.push(current2.left);\n\n                sk1.push(current1.right);\n                sk2.push(current2.right);\n\n            }\n\n            // final check\n            if (!sk1.isEmpty() || !sk2.isEmpty()) {\n                return false;\n            }\n\n            return true;\n\n        }\n    }\n\n\n    public class Solution_recursion {\n        public boolean isSameTree(TreeNode p, TreeNode q) {\n\n            if (p == null) {\n                return q == null;\n            }\n\n            if (q == null) {\n                return p == null;\n            }\n\n            if (p.val != q.val) {\n                return false;\n            }\n\n            return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n        }\n    }\n\n}\n\n//////\n\nclass Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if (p == q) return true;\n        if (p == null || q == null || p.val != q.val) return false;\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n    }\n}",
    "101. Symmetric Tree": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public boolean isSymmetric(TreeNode root) {\n        return dfs(root, root);\n    }\n\n    private boolean dfs(TreeNode root1, TreeNode root2) {\n        if (root1 == null && root2 == null) {\n            return true;\n        }\n        if (root1 == null || root2 == null || root1.val != root2.val) {\n            return false;\n        }\n        return dfs(root1.left, root2.right) && dfs(root1.right, root2.left);\n    }\n}",
    "102. Binary Tree Level Order Traversal": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public List<List<Integer>> levelOrder(TreeNode root) {\n        List<List<Integer>> ans = new ArrayList<>();\n        if (root == null) {\n            return ans;\n        }\n        Deque<TreeNode> q = new ArrayDeque<>();\n        q.offer(root);\n        while (!q.isEmpty()) {\n            List<Integer> t = new ArrayList<>();\n            for (int n = q.size(); n > 0; --n) {\n                TreeNode node = q.poll();\n                t.add(node.val);\n                if (node.left != null) {\n                    q.offer(node.left);\n                }\n                if (node.right != null) {\n                    q.offer(node.right);\n                }\n            }\n            ans.add(t);\n        }\n        return ans;\n    }\n}",
    "103. Binary Tree Zigzag Level Order Traversal": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\n        List<List<Integer>> ans = new ArrayList<>();\n        if (root == null) {\n            return ans;\n        }\n        Deque<TreeNode> q = new ArrayDeque<>();\n        q.offer(root);\n        boolean left = true;\n        while (!q.isEmpty()) {\n            List<Integer> t = new ArrayList<>();\n            for (int n = q.size(); n > 0; --n) {\n                TreeNode node = q.poll();\n                t.add(node.val);\n                if (node.left != null) {\n                    q.offer(node.left);\n                }\n                if (node.right != null) {\n                    q.offer(node.right);\n                }\n            }\n            if (!left) {\n                Collections.reverse(t);\n            }\n            ans.add(t);\n            left = !left;\n        }\n        return ans;\n    }\n}\n\n//////\n\npublic class Binary_Tree_Zigzag_Level_Order_Traversal {\n\n    /**\n     * Definition for a binary tree node.\n     * public class TreeNode {\n     * int val;\n     * TreeNode left;\n     * TreeNode right;\n     * TreeNode(int x) { val = x; }\n     * }\n     */\n\n    // count as level marker\n    class Solution {\n        public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\n\n            List<List<Integer>> result = new ArrayList<>();\n\n            if (root == null) {\n                return result;\n            }\n\n            boolean isLeftToRight = true;\n\n            Queue<TreeNode> q = new LinkedList<>();\n            q.offer(root);\n\n            int currentLevelCount = 1;\n            int nextLevelCount = 0;\n\n            List<Integer> one = new ArrayList<>();\n\n            while (!q.isEmpty()) {\n                TreeNode current = q.poll();\n                currentLevelCount--;\n\n                if (isLeftToRight) {\n                    one.add(current.val);\n                } else {\n                    one.add(0, current.val);\n                }\n\n                if (current.left != null) {\n                    q.offer(current.left);\n                    nextLevelCount++;\n                }\n                if (current.right != null) {\n                    q.offer(current.right);\n                    nextLevelCount++;\n                }\n\n                if (currentLevelCount == 0) {\n                    currentLevelCount = nextLevelCount;\n                    nextLevelCount = 0;\n\n                    result.add(one);\n                    one = new ArrayList<>();\n\n                    isLeftToRight = !isLeftToRight;\n                }\n            }\n\n            return result;\n        }\n    }\n\n    public class Solution_nullAsMarker {\n        public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\n\n            List<List<Integer>> list = new ArrayList<List<Integer>>();\n\n            if (root == null) {\n                return list;\n            }\n\n            Queue<TreeNode> q = new LinkedList<>();\n\n            q.offer(root);\n            q.offer(null);// @note: use null as marker for end of level\n\n            boolean direction = true; // true: left=>right, false: right=>left\n            List<Integer> oneLevel = new ArrayList<>();\n            while (!q.isEmpty()) {\n\n                TreeNode current = q.poll();\n\n                if (current == null) {\n                    List<Integer> copy = new ArrayList<>(oneLevel);\n                    list.add(copy);\n\n                    // clean after one level recorded\n                    oneLevel.clear();// @memorize: this api\n                    direction = !direction;\n\n                    // @note:@memorize: if stack is now empty then DO NOT add null, or else infinite looping\n                    // sk.offer(null); // add marker\n                    if (!q.isEmpty()) {\n                        q.offer(null); // add marker\n                    }\n\n                    continue;\n                }\n\n                if (direction) {\n                    oneLevel.add(current.val);\n                } else {\n                    oneLevel.add(0, current.val);\n                }\n\n                // @note:@memorize: since using null as marker, then must avoid adding null when children are null\n                // sk.offer(current.left);\n                // sk.offer(current.right);\n                if (current.left != null) {\n                    q.offer(current.left);\n                }\n                if (current.right != null) {\n                    q.offer(current.right);\n                }\n\n            }\n\n            return list;\n        }\n    }\n\n}",
    "104. Maximum Depth of Binary Tree": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        if (root == null) {\n            return 0;\n        }\n        int l = maxDepth(root.left);\n        int r = maxDepth(root.right);\n        return 1 + Math.max(l, r);\n    }\n}",
    "105. Construct Binary Tree from Preorder and Inorder Traversal": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    private int[] preorder;\n    private Map<Integer, Integer> d = new HashMap<>();\n\n    public TreeNode buildTree(int[] preorder, int[] inorder) {\n        int n = preorder.length;\n        this.preorder = preorder;\n        for (int i = 0; i < n; ++i) {\n            d.put(inorder[i], i);\n        }\n        return dfs(0, 0, n);\n    }\n\n    private TreeNode dfs(int i, int j, int n) {\n        if (n <= 0) {\n            return null;\n        }\n        int v = preorder[i];\n        int k = d.get(v);\n        TreeNode l = dfs(i + 1, j, k - j);\n        TreeNode r = dfs(i + 1 + k - j, k + 1, n - 1 - (k - j));\n        return new TreeNode(v, l, r);\n    }\n}",
    "106. Construct Binary Tree from Inorder and Postorder Traversal": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    private Map<Integer, Integer> indexes = new HashMap<>();\n\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\n        for (int i = 0; i < inorder.length; ++i) {\n            indexes.put(inorder[i], i);\n        }\n        return dfs(inorder, postorder, 0, 0, inorder.length);\n    }\n\n    private TreeNode dfs(int[] inorder, int[] postorder, int i, int j, int n) {\n        if (n <= 0) {\n            return null;\n        }\n        int v = postorder[j + n - 1];\n        int k = indexes.get(v);\n        TreeNode root = new TreeNode(v);\n        root.left = dfs(inorder, postorder, i, j, k - i);\n        root.right = dfs(inorder, postorder, k + 1, j + k - i, n - k + i - 1);\n        return root;\n    }\n}",
    "107. Binary Tree Level Order Traversal II": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public List<List<Integer>> levelOrderBottom(TreeNode root) {\n        LinkedList<List<Integer>> ans = new LinkedList<>();\n        if (root == null) {\n            return ans;\n        }\n        Deque<TreeNode> q = new LinkedList<>();\n        q.offerLast(root);\n        while (!q.isEmpty()) {\n            List<Integer> t = new ArrayList<>();\n            for (int i = q.size(); i > 0; --i) {\n                TreeNode node = q.pollFirst();\n                t.add(node.val);\n                if (node.left != null) {\n                    q.offerLast(node.left);\n                }\n                if (node.right != null) {\n                    q.offerLast(node.right);\n                }\n            }\n            ans.addFirst(t);\n        }\n        return ans;\n    }\n}",
    "108. Convert Sorted Array to Binary Search Tree": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    private int[] nums;\n\n    public TreeNode sortedArrayToBST(int[] nums) {\n        this.nums = nums;\n        return dfs(0, nums.length - 1);\n    }\n\n    private TreeNode dfs(int l, int r) {\n        if (l > r) {\n            return null;\n        }\n        int mid = (l + r) >> 1;\n        TreeNode left = dfs(l, mid - 1);\n        TreeNode right = dfs(mid + 1, r);\n        return new TreeNode(nums[mid], left, right);\n    }\n}",
    "109. Convert Sorted List to Binary Search Tree": "public class Convert_Sorted_List_to_Binary_Search_Tree {\n\n /**\n  * Definition for singly-linked list.\n  * public class ListNode {\n  *     int val;\n  *     ListNode next;\n  *     ListNode(int x) { val = x; next = null; }\n  * }\n  */\n /**\n  * Definition for binary tree\n  * public class TreeNode {\n  *     int val;\n  *     TreeNode left;\n  *     TreeNode right;\n  *     TreeNode(int x) { val = x; }\n  * }\n  */\n    public class Solution {\n        public TreeNode sortedListToBST(ListNode head) {\n\n            if (head == null) {\n                return null;\n            }\n            if (head.next == null) {\n                return new TreeNode(head.val);\n            }\n\n            // find mid\n            ListNode dummy = new ListNode(0);\n            dummy.next = head;\n            ListNode slow = head, fast = head, prev = dummy;\n            while (fast != null && fast.next != null) {\n                prev = slow;\n                slow = slow.next;\n                fast = fast.next.next;\n            }\n\n            // prev is one before mid\n            // ListNode 2ndPartHead = slow.next; // @note@note: illegal, cannot start with number\n            ListNode newHead = slow.next;\n            prev.next = null; // @note: cut\n\n            TreeNode root = new TreeNode(slow.val);\n            root.left = sortedListToBST(head);\n            root.right = sortedListToBST(newHead);\n\n            return root;\n        }\n    }\n\n}\n\n############\n\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        List<Integer> nums = new ArrayList<>();\n        for (; head != null; head = head.next) {\n            nums.add(head.val);\n        }\n        return buildBST(nums, 0, nums.size() - 1);\n    }\n\n    private TreeNode buildBST(List<Integer> nums, int start, int end) {\n        if (start > end) {\n            return null;\n        }\n        int mid = (start + end) >> 1;\n        TreeNode root = new TreeNode(nums.get(mid));\n        root.left = buildBST(nums, start, mid - 1);\n        root.right = buildBST(nums, mid + 1, end);\n        return root;\n    }\n}",
    "110. Balanced Binary Tree": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public boolean isBalanced(TreeNode root) {\n        return height(root) >= 0;\n    }\n\n    private int height(TreeNode root) {\n        if (root == null) {\n            return 0;\n        }\n        int l = height(root.left);\n        int r = height(root.right);\n        if (l == -1 || r == -1 || Math.abs(l - r) > 1) {\n            return -1;\n        }\n        return 1 + Math.max(l, r);\n    }\n}",
    "111. Minimum Depth of Binary Tree": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public int minDepth(TreeNode root) {\n        if (root == null) {\n            return 0;\n        }\n        if (root.left == null) {\n            return 1 + minDepth(root.right);\n        }\n        if (root.right == null) {\n            return 1 + minDepth(root.left);\n        }\n        return 1 + Math.min(minDepth(root.left), minDepth(root.right));\n    }\n}",
    "112. Path Sum": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public boolean hasPathSum(TreeNode root, int targetSum) {\n        return dfs(root, targetSum);\n    }\n\n    private boolean dfs(TreeNode root, int s) {\n        if (root == null) {\n            return false;\n        }\n        s -= root.val;\n        if (root.left == null && root.right == null && s == 0) {\n            return true;\n        }\n        return dfs(root.left, s) || dfs(root.right, s);\n    }\n}",
    "113. Path Sum II": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    private List<List<Integer>> ans = new ArrayList<>();\n    private List<Integer> t = new ArrayList<>();\n\n    public List<List<Integer>> pathSum(TreeNode root, int targetSum) {\n        dfs(root, targetSum);\n        return ans;\n    }\n\n    private void dfs(TreeNode root, int s) {\n        if (root == null) {\n            return;\n        }\n        s -= root.val;\n        t.add(root.val);\n        if (root.left == null && root.right == null && s == 0) {\n            ans.add(new ArrayList<>(t));\n        }\n        dfs(root.left, s);\n        dfs(root.right, s);\n        t.remove(t.size() - 1);\n    }\n}",
    "114. Flatten Binary Tree to Linked List": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public void flatten(TreeNode root) {\n        while (root != null) {\n            if (root.left != null) {\n                TreeNode pre = root.left;\n                while (pre.right != null) {\n                    pre = pre.right;\n                }\n                pre.right = root.right;\n                root.right = root.left;\n                root.left = null;\n            }\n            root = root.right;\n        }\n    }\n}",
    "115. Distinct Subsequences": "class Solution {\n    public int numDistinct(String s, String t) {\n        int n = t.length();\n        int[] f = new int[n + 1];\n        f[0] = 1;\n        for (char a : s.toCharArray()) {\n            for (int j = n; j > 0; --j) {\n                char b = t.charAt(j - 1);\n                if (a == b) {\n                    f[j] += f[j - 1];\n                }\n            }\n        }\n        return f[n];\n    }\n}",
    "116. Populating Next Right Pointers in Each Node": "/*\n// Definition for a Node.\nclass Node {\n    public int val;\n    public Node left;\n    public Node right;\n    public Node next;\n\n    public Node() {}\n\n    public Node(int _val) {\n        val = _val;\n    }\n\n    public Node(int _val, Node _left, Node _right, Node _next) {\n        val = _val;\n        left = _left;\n        right = _right;\n        next = _next;\n    }\n};\n*/\n\nclass Solution {\n    public Node connect(Node root) {\n        if (root == null) {\n            return root;\n        }\n        Deque<Node> q = new ArrayDeque<>();\n        q.offer(root);\n        while (!q.isEmpty()) {\n            Node p = null;\n            for (int n = q.size(); n > 0; --n) {\n                Node node = q.poll();\n                if (p != null) {\n                    p.next = node;\n                }\n                p = node;\n                if (node.left != null) {\n                    q.offer(node.left);\n                }\n                if (node.right != null) {\n                    q.offer(node.right);\n                }\n            }\n        }\n        return root;\n    }\n}",
    "117. Populating Next Right Pointers in Each Node II": "/*\n// Definition for a Node.\nclass Node {\n    public int val;\n    public Node left;\n    public Node right;\n    public Node next;\n\n    public Node() {}\n\n    public Node(int _val) {\n        val = _val;\n    }\n\n    public Node(int _val, Node _left, Node _right, Node _next) {\n        val = _val;\n        left = _left;\n        right = _right;\n        next = _next;\n    }\n};\n*/\n\nclass Solution {\n    private Node prev, next;\n\n    public Node connect(Node root) {\n        Node node = root;\n        while (node != null) {\n            prev = null;\n            next = null;\n            while (node != null) {\n                modify(node.left);\n                modify(node.right);\n                node = node.next;\n            }\n            node = next;\n        }\n        return root;\n    }\n\n    private void modify(Node curr) {\n        if (curr == null) {\n            return;\n        }\n        if (next == null) {\n            next = curr;\n        }\n        if (prev != null) {\n            prev.next = curr;\n        }\n        prev = curr;\n    }\n}",
    "118. Pascal's Triangle": "class Solution {\n    public List<List<Integer>> generate(int numRows) {\n        List<List<Integer>> f = new ArrayList<>();\n        f.add(List.of(1));\n        for (int i = 0; i < numRows - 1; ++i) {\n            List<Integer> g = new ArrayList<>();\n            g.add(1);\n            for (int j = 0; j < f.get(i).size() - 1; ++j) {\n                g.add(f.get(i).get(j) + f.get(i).get(j + 1));\n            }\n            g.add(1);\n            f.add(g);\n        }\n        return f;\n    }\n}",
    "119. Pascal's Triangle II": "class Solution {\n    public List<Integer> getRow(int rowIndex) {\n        List<Integer> f = new ArrayList<>();\n        for (int i = 0; i < rowIndex + 1; ++i) {\n            f.add(1);\n        }\n        for (int i = 2; i < rowIndex + 1; ++i) {\n            for (int j = i - 1; j > 0; --j) {\n                f.set(j, f.get(j) + f.get(j - 1));\n            }\n        }\n        return f;\n    }\n}",
    "120. Triangle": "class Solution {\n    public int minimumTotal(List<List<Integer>> triangle) {\n        for (int i = triangle.size() - 2; i >= 0; --i) {\n            for (int j = 0; j <= i; ++j) {\n                int x = triangle.get(i).get(j);\n                int y = Math.min(triangle.get(i + 1).get(j), triangle.get(i + 1).get(j + 1));\n                triangle.get(i).set(j, x + y);\n            }\n        }\n        return triangle.get(0).get(0);\n    }\n}",
    "121. Best Time to Buy and Sell Stock": "class Solution {\n    public int maxProfit(int[] prices) {\n        int ans = 0, mi = prices[0];\n        for (int v : prices) {\n            ans = Math.max(ans, v - mi);\n            mi = Math.min(mi, v);\n        }\n        return ans;\n    }\n}",
    "122. Best Time to Buy and Sell Stock II": "class Solution {\n    public int maxProfit(int[] prices) {\n        int ans = 0;\n        for (int i = 1; i < prices.length; ++i) {\n            ans += Math.max(0, prices[i] - prices[i - 1]);\n        }\n        return ans;\n    }\n}",
    "123. Best Time to Buy and Sell Stock III": "public class Solution {\n    public int MaxProfit(int[] prices) {\n        int f1 = -prices[0], f2 = 0, f3 = -prices[0], f4 = 0;\n        for (int i = 1; i < prices.Length; ++i) {\n            f1 = Math.Max(f1, -prices[i]);\n            f2 = Math.Max(f2, f1 + prices[i]);\n            f3 = Math.Max(f3, f2 - prices[i]);\n            f4 = Math.Max(f4, f3 + prices[i]);\n        }\n        return f4;\n    }\n}",
    "124. Binary Tree Maximum Path Sum": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    private int ans = -1001;\n\n    public int maxPathSum(TreeNode root) {\n        dfs(root);\n        return ans;\n    }\n\n    private int dfs(TreeNode root) {\n        if (root == null) {\n            return 0;\n        }\n        int left = Math.max(0, dfs(root.left));\n        int right = Math.max(0, dfs(root.right));\n        ans = Math.max(ans, root.val + left + right);\n        return root.val + Math.max(left, right);\n    }\n}",
    "125. Valid Palindrome": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            if (!Character.isLetterOrDigit(s.charAt(i))) {\n                ++i;\n            } else if (!Character.isLetterOrDigit(s.charAt(j))) {\n                --j;\n            } else if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) {\n                return false;\n            } else {\n                ++i;\n                --j;\n            }\n        }\n        return true;\n    }\n}",
    "126. Word Ladder II": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Queue;\nimport java.util.Set;\n\npublic class Word_Ladder_II {\n\n // iteration bfs\n // https://leetcode.com/problems/word-ladder-ii/solution/\n    public class Solution {\n\n        List<List<String>> list = new ArrayList<List<String>>();\n\n        public List<List<String>> findLadders(String start, String end, Set<String> dict) {\n\n            if (start == null || end == null || dict == null) return list;\n\n            dict.add(end); // !!!\n\n            Queue<String> q = new LinkedList<String>();\n            int level = 1;\n            int currentLevelCount = 1;\n            int newLevelCount = 0;\n            boolean found = false;\n            int foundLevel = -1;\n\n            // from end word, to all paths\n            HashMap<String, ArrayList<ArrayList<String>>> hm = new HashMap<String, ArrayList<ArrayList<String>>>();\n\n\n            q.offer(start);\n            ArrayList<String> singlePath = new ArrayList<String>();\n            ArrayList<ArrayList<String>> allPaths = new ArrayList<ArrayList<String>>();\n\n            singlePath.add(start);\n            allPaths.add(singlePath);\n            hm.put(start, allPaths);\n\n            while (!q.isEmpty()) {\n\n                String current = q.poll();\n                currentLevelCount--; // \u8fd9\u91cc\u7528\u4e86\u65b0\u65e7count\u6765\u6807\u8bb0\u6bcf\u4e2alevel\uff0c\u6ca1\u6709\u7528null\n\n                for (int i = 0; i < current.length(); i++) {\n                    char[] array = current.toCharArray();\n\n                    for (char c = 'a'; c <= 'z'; c++) {\n                        array[i] = c;\n                        String each = new String(array);\n                        if (each.equals(end)) {\n                            found = true;\n                            foundLevel = level;\n                        }\n\n\n                        if (dict.contains(each)) {\n                            // q.offer(each);\n                            newLevelCount++;\n\n                            ArrayList<ArrayList<String>> prevAllPaths = hm.get(current);\n\n                            if (hm.containsKey(each))\n                                allPaths = hm.get(each);\n                            else {\n                                /* @note@note:\n                                 enqueue is here. if no path ending at this one, then has to explore in future\n                                 if there is path ending at this one, meaning it's been explored already. no need to enqueue\n                             */\n                                q.offer(each);\n                                allPaths = new ArrayList<ArrayList<String>>();\n                                hm.put(each, allPaths);\n                            }\n\n                            // @note@note: this if is the key !!! no path for new word, or new word path is one more than previous path\n                            // using this if, the\"if visited\" check can be removed\n                            // if (allPaths.size() == 0 || prevAllPaths.size() + 1 == allPaths.size()) {\n                            if (allPaths.size() == 0 || prevAllPaths.get(0).size() + 1 == allPaths.get(0).size()) {\n                                for (ArrayList<String> eachPath : prevAllPaths) {\n                                    ArrayList<String> newone = new ArrayList<String>(eachPath);\n                                    newone.add(each);\n                                    allPaths.add(newone);\n                                }\n                            }\n                        }\n                    }\n                }\n\n                // @note@note: also the key, to make sure only find shortest\n                if (found && foundLevel != level) {\n                    break;\n                }\n\n                // @note: must be after trying the last word of currentLevel, then update\n                if (currentLevelCount == 0) {\n                    currentLevelCount = newLevelCount;\n                    newLevelCount = 0;\n                    level++;\n\n                }\n\n            }\n\n            if (!found) {\n                return list;\n            }\n\n            for (ArrayList<String> each : hm.get(end)) {\n                list.add(each);\n            }\n\n            return list;\n\n        }\n    }\n\n\n    public class Solution_recursion {\n\n        private List<String> findPath(String fromWord, String toWord,\n                                      Set<String> seenWords) {\n\n            if (fromWord.equals(toWord)) {\n                ArrayList<String> result = new ArrayList<>();\n                result.add(toWord);\n                return result;\n            }\n\n            // Find all words that you can go to from fromWord\n            List<String> nextWords = getNextWords(fromWord, seenWords);\n            for (String word : nextWords) {\n                Set<String> newSeenWords = new HashSet<String>(seenWords);\n                newSeenWords.add(word);\n                List<String> subPath = findPath(word, toWord, newSeenWords);\n                if (subPath != null) {\n                    subPath.add(fromWord);\n                    return subPath;\n                }\n            }\n\n            // There wasn't a path\n            return null;\n\n        }\n\n        private final List<String> WORDS = Arrays.asList(\"head\", \"heal\",\n            \"teal\", \"tell\", \"tall\", \"tail\");\n\n        private final List<Character> ALPHA = Arrays.asList('a', 'b',\n            'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n',\n            'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z');\n\n        private final HashSet<String> DICTIONARY = new HashSet<String>(\n            WORDS);\n\n        private List<String> getNextWords(String fromWord,\n                                          Set<String> seenWords) {\n            List<String> outList = new ArrayList<String>();\n            StringBuilder builder;\n            for (int i = 0; i < fromWord.length(); i++) {\n                builder = new StringBuilder(fromWord);\n                for (Character j : ALPHA) {\n                    if (j == fromWord.charAt(i)) {\n                        continue;\n                    }\n                    builder.setCharAt(i, j);\n                    String potentialWord = builder.toString();\n                    if (DICTIONARY.contains(potentialWord)\n                        && !seenWords.contains(potentialWord)) {\n                        outList.add(potentialWord);\n                    }\n                }\n            }\n            return outList;\n        }\n    }\n}\n\n//////\n\nclass Solution {\n    private List<List<String>> ans;\n    private Map<String, Set<String>> prev;\n\n    public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {\n        ans = new ArrayList<>();\n        Set<String> words = new HashSet<>(wordList);\n        if (!words.contains(endWord)) {\n            return ans;\n        }\n        words.remove(beginWord);\n        Map<String, Integer> dist = new HashMap<>();\n        dist.put(beginWord, 0);\n        prev = new HashMap<>();\n        Queue<String> q = new ArrayDeque<>();\n        q.offer(beginWord);\n        boolean found = false;\n        int step = 0;\n        while (!q.isEmpty() && !found) {\n            ++step;\n            for (int i = q.size(); i > 0; --i) {\n                String p = q.poll();\n                char[] chars = p.toCharArray();\n                for (int j = 0; j < chars.length; ++j) {\n                    char ch = chars[j];\n                    for (char k = 'a'; k <= 'z'; ++k) {\n                        chars[j] = k;\n                        String t = new String(chars);\n                        if (dist.getOrDefault(t, 0) == step) {\n                            prev.get(t).add(p);\n                        }\n                        if (!words.contains(t)) {\n                            continue;\n                        }\n                        prev.computeIfAbsent(t, key -> new HashSet<>()).add(p);\n                        words.remove(t);\n                        q.offer(t);\n                        dist.put(t, step);\n                        if (endWord.equals(t)) {\n                            found = true;\n                        }\n                    }\n                    chars[j] = ch;\n                }\n            }\n        }\n        if (found) {\n            Deque<String> path = new ArrayDeque<>();\n            path.add(endWord);\n            dfs(path, beginWord, endWord);\n        }\n        return ans;\n    }\n\n    private void dfs(Deque<String> path, String beginWord, String cur) {\n        if (cur.equals(beginWord)) {\n            ans.add(new ArrayList<>(path));\n            return;\n        }\n        for (String precursor : prev.get(cur)) {\n            path.addFirst(precursor);\n            dfs(path, beginWord, precursor);\n            path.removeFirst();\n        }\n    }\n}",
    "127. Word Ladder": "class Solution {\n    private Set<String> words;\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        words = new HashSet<>(wordList);\n        if (!words.contains(endWord)) {\n            return 0;\n        }\n        Queue<String> q1 = new ArrayDeque<>();\n        Queue<String> q2 = new ArrayDeque<>();\n        Map<String, Integer> m1 = new HashMap<>();\n        Map<String, Integer> m2 = new HashMap<>();\n        q1.offer(beginWord);\n        q2.offer(endWord);\n        m1.put(beginWord, 0);\n        m2.put(endWord, 0);\n        while (!q1.isEmpty() && !q2.isEmpty()) {\n            int t = q1.size() <= q2.size() ? extend(m1, m2, q1) : extend(m2, m1, q2);\n            if (t != -1) {\n                return t + 1;\n            }\n        }\n        return 0;\n    }\n\n    private int extend(Map<String, Integer> m1, Map<String, Integer> m2, Queue<String> q) {\n        for (int i = q.size(); i > 0; --i) {\n            String s = q.poll();\n            int step = m1.get(s);\n            char[] chars = s.toCharArray();\n            for (int j = 0; j < chars.length; ++j) {\n                char ch = chars[j];\n                for (char k = 'a'; k <= 'z'; ++k) {\n                    chars[j] = k;\n                    String t = new String(chars);\n                    if (!words.contains(t) || m1.containsKey(t)) {\n                        continue;\n                    }\n                    if (m2.containsKey(t)) {\n                        return step + 1 + m2.get(t);\n                    }\n                    q.offer(t);\n                    m1.put(t, step + 1);\n                }\n                chars[j] = ch;\n            }\n        }\n        return -1;\n    }\n}",
    "128. Longest Consecutive Sequence": "class Solution {\n    public int longestConsecutive(int[] nums) {\n        Set<Integer> s = new HashSet<>();\n        for (int x : nums) {\n            s.add(x);\n        }\n        int ans = 0;\n        for (int x : nums) {\n            if (!s.contains(x - 1)) {\n                int y = x + 1;\n                while (s.contains(y)) {\n                    ++y;\n                }\n                ans = Math.max(ans, y - x);\n            }\n        }\n        return ans;\n    }\n}",
    "129. Sum Root to Leaf Numbers": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public int sumNumbers(TreeNode root) {\n        return dfs(root, 0);\n    }\n\n    private int dfs(TreeNode root, int s) {\n        if (root == null) {\n            return 0;\n        }\n        s = s * 10 + root.val;\n        if (root.left == null && root.right == null) {\n            return s;\n        }\n        return dfs(root.left, s) + dfs(root.right, s);\n    }\n}",
    "130. Surrounded Regions": "class Solution {\n    private char[][] board;\n    private int m;\n    private int n;\n\n    public void solve(char[][] board) {\n        m = board.length;\n        n = board[0].length;\n        this.board = board;\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if ((i == 0 || i == m - 1 || j == 0 || j == n - 1) && board[i][j] == 'O') {\n                    dfs(i, j);\n                }\n            }\n        }\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (board[i][j] == '.') {\n                    board[i][j] = 'O';\n                } else if (board[i][j] == 'O') {\n                    board[i][j] = 'X';\n                }\n            }\n        }\n    }\n\n    private void dfs(int i, int j) {\n        board[i][j] = '.';\n        int[] dirs = {-1, 0, 1, 0, -1};\n        for (int k = 0; k < 4; ++k) {\n            int x = i + dirs[k];\n            int y = j + dirs[k + 1];\n            if (x >= 0 && x < m && y >= 0 && y < n && board[x][y] == 'O') {\n                dfs(x, y);\n            }\n        }\n    }\n}",
    "131. Palindrome Partitioning": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class Palindrome_Partitioning {\n\n    public class Solution_dp {\n\n        public List<List<String>> partition(String s) {\n\n            int n = s.length();\n            List<List<String>> res = new ArrayList<>();\n            List<String> out = new ArrayList<>();\n            boolean[][] dp = new boolean[n][n];\n            for (int i = 0; i < n; ++i) {\n                for (int j = 0; j <= i; ++j) {\n                    if (s.charAt(i) == s.charAt(j) && (i - j <= 2 || dp[j + 1][i - 1])) {\n                        dp[j][i] = true;\n                    }\n                }\n            }\n\n            helper(s, 0, dp, out, res);\n            return res;\n        }\n\n        void helper(String s, int start, boolean[][] dp, List<String> out, List<List<String>> res) {\n            if (start == s.length()) {\n                res.add(new ArrayList<>(out));\n                return;\n            }\n            for (int i = start; i < s.length(); ++i) {\n                if (!dp[start][i]) continue;\n\n                out.add(s.substring(start, i + 1));\n                helper(s, i + 1, dp, out, res);\n                out.remove(out.size() - 1);\n            }\n        }\n    }\n\n    // based on part-I, just count each partition to find min...\n    public class Solution_over_time {\n        List<List<String>> list = new ArrayList<>();\n\n        public List<List<String>> partition(String s) {\n\n            if (s == null || s.length() == 0) {\n                return list;\n            }\n\n            find(s, new ArrayList<String>());\n\n            return list;\n        }\n\n        private void find(String s, ArrayList<String> currentList) {\n\n            if (s.length() == 0) {\n                list.add(currentList);\n\n                return;\n            }\n\n            // idea is, scan from index=0, to find each palindrome, then rest substring to next recursion\n            for (int i = 0; i < s.length(); i++) {\n\n                String sub = s.substring(0, i + 1); // @note: substring 0-s[i]\n                // System.out.println(\"substring is: \" + sub);\n\n                if (isPal(sub)) {\n\n                    ArrayList<String> nextList = new ArrayList<>(currentList); // deep copy\n                    nextList.add(sub);\n                    find(s.substring(i + 1), nextList);\n                }\n            }\n\n        }\n\n        private boolean isPal(String s) {\n            int i = 0;\n            int j = s.length() - 1;\n\n            while (i <= j) {\n\n                // @note: better in if (s.charAt(i++) != s.charAt(j--)) { // @note: \u5fd8\u4e86\u8fd9\u91cc\u7684++\u548c--\u3002\u3002\u3002\n                if (s.charAt(i) != s.charAt(j)) {\n                    return false;\n                }\n\n                i++;\n                j--;\n\n            }\n\n            return true;\n        }\n    }\n\n}\n\n############\n\nclass Solution {\n    private boolean[][] dp;\n    private List<List<String>> ans;\n    private int n;\n\n    public List<List<String>> partition(String s) {\n        ans = new ArrayList<>();\n        n = s.length();\n        dp = new boolean[n][n];\n        for (int i = 0; i < n; ++i) {\n            Arrays.fill(dp[i], true);\n        }\n        for (int i = n - 1; i >= 0; --i) {\n            for (int j = i + 1; j < n; ++j) {\n                dp[i][j] = s.charAt(i) == s.charAt(j) && dp[i + 1][j - 1];\n            }\n        }\n        dfs(s, 0, new ArrayList<>());\n        return ans;\n    }\n\n    private void dfs(String s, int i, List<String> t) {\n        if (i == n) {\n            ans.add(new ArrayList<>(t));\n            return;\n        }\n        for (int j = i; j < n; ++j) {\n            if (dp[i][j]) {\n                t.add(s.substring(i, j + 1));\n                dfs(s, j + 1, t);\n                t.remove(t.size() - 1);\n            }\n        }\n    }\n}",
    "132. Palindrome Partitioning II": "class Solution {\n    public int minCut(String s) {\n        int n = s.length();\n        boolean[][] dp1 = new boolean[n][n];\n        for (int i = n - 1; i >= 0; i--) {\n            for (int j = i; j < n; j++) {\n                dp1[i][j] = s.charAt(i) == s.charAt(j) && (j - i < 3 || dp1[i + 1][j - 1]);\n            }\n        }\n        int[] dp2 = new int[n];\n        for (int i = 0; i < n; i++) {\n            if (!dp1[0][i]) {\n                dp2[i] = i;\n                for (int j = 1; j <= i; j++) {\n                    if (dp1[j][i]) {\n                        dp2[i] = Math.min(dp2[i], dp2[j - 1] + 1);\n                    }\n                }\n            }\n        }\n        return dp2[n - 1];\n    }\n}\n\n//////\n\npublic class Palindrome_Partitioning_II {\n\n    public class Solution {\n        public int minCut(String s) {\n\n            if (s == null || s.length() == 0) {\n                return -1;\n            }\n\n            // 'abcba', when reaching 'c', minCut=2\n            //          when reaching 2nd 'b', minCut=1\n            //          when reaching 2nd 'a', minCut=0\n            // so, if a substring is palindrome, cut is prev_segment+1\n\n            // set up a fast lookup for if palindrome from i to j\n            boolean[][] isPal = new boolean[s.length()][s.length()];\n            for (int i = 0; i < s.length(); i++) {\n                for (int j = i; j >= 0; j--) {\n                    if (i == j || (s.charAt(i) == s.charAt(j) && (i - j == 1 || isPal[j + 1][i - 1]))) {\n                        isPal[j][i] = true; // j is first, then i\n                    }\n                }\n            }\n\n            // set up min count array, worst case, each char is a palindrome\n            int[] minCut = new int[s.length()];\n            for (int i = 0; i < s.length(); i++) {\n                minCut[i] = i;\n            }\n\n            // how to cound, eg: 'aabcba', 'aabcbaz'\n            // @note: if a substring is palindrome, cut is prev_segment+1\n            for (int i = 0; i < s.length(); i++) {\n                for (int j = 0; j < s.length(); j++) {\n                    if (isPal[i][j]) {\n                        if (i - 1 >= 0) { // @note: eg, 'aabcba'\n                            minCut[j] = Math.min(minCut[j], 1 + minCut[i - 1]);\n                        } else { // i.e., i==0. eg, 'abcba'\n                            minCut[j] = 0;\n                        }\n                    }\n                }\n            }\n\n            int min = minCut[s.length() - 1];\n            return min;\n        }\n    }\n}",
    "133. Clone Graph": "/*\n// Definition for a Node.\nclass Node {\n    public int val;\n    public List<Node> neighbors;\n    public Node() {\n        val = 0;\n        neighbors = new ArrayList<Node>();\n    }\n    public Node(int _val) {\n        val = _val;\n        neighbors = new ArrayList<Node>();\n    }\n    public Node(int _val, ArrayList<Node> _neighbors) {\n        val = _val;\n        neighbors = _neighbors;\n    }\n}\n*/\n\nclass Solution {\n    private Map<Node, Node> visited = new HashMap<>();\n\n    public Node cloneGraph(Node node) {\n        if (node == null) {\n            return null;\n        }\n        if (visited.containsKey(node)) {\n            return visited.get(node);\n        }\n        Node clone = new Node(node.val);\n        visited.put(node, clone);\n        for (Node e : node.neighbors) {\n            clone.neighbors.add(cloneGraph(e));\n        }\n        return clone;\n    }\n}",
    "134. Gas Station": "class Solution {\n    public int canCompleteCircuit(int[] gas, int[] cost) {\n        int n = gas.length;\n        int i = n - 1, j = n - 1;\n        int cnt = 0, s = 0;\n        while (cnt < n) {\n            s += gas[j] - cost[j];\n            ++cnt;\n            j = (j + 1) % n;\n            while (s < 0 && cnt < n) {\n                --i;\n                s += gas[i] - cost[i];\n                ++cnt;\n            }\n        }\n        return s < 0 ? -1 : i;\n    }\n}",
    "135. Candy": "class Solution {\n    public int candy(int[] ratings) {\n        int n = ratings.length;\n        int up = 0;\n        int down = 0;\n        int peak = 0;\n        int candies = 1;\n        for (int i = 1; i < n; i++) {\n            if (ratings[i - 1] < ratings[i]) {\n                up++;\n                peak = up + 1;\n                down = 0;\n                candies += peak;\n            } else if (ratings[i] == ratings[i - 1]) {\n                peak = 0;\n                up = 0;\n                down = 0;\n                candies++;\n            } else {\n                down++;\n                up = 0;\n                candies += down + (peak > down ? 0 : 1);\n            }\n        }\n        return candies;\n    }\n}",
    "136. Single Number": "class Solution {\n    public int singleNumber(int[] nums) {\n        int ans = 0;\n        for (int v : nums) {\n            ans ^= v;\n        }\n        return ans;\n    }\n}",
    "137. Single Number II": "class Solution {\n    public int singleNumber(int[] nums) {\n        int a = 0, b = 0;\n        for (int c : nums) {\n            int aa = (~a & b & c) | (a & ~b & ~c);\n            int bb = ~a & (b ^ c);\n            a = aa;\n            b = bb;\n        }\n        return b;\n    }\n}",
    "138. Copy List with Random Pointer": "public class Copy_List_with_Random_Pointer {\n\n    /**\n     * Definition for singly-linked list with a random pointer.\n     * class RandomListNode {\n     *     int label;\n     *     RandomListNode next, random;\n     *     RandomListNode(int x) { this.label = x; }\n     * };\n     */\n\n    /*\n        1. \u5728\u539f\u94fe\u8868\u7684\u6bcf\u4e2a\u8282\u70b9\u540e\u9762\u62f7\u8d1d\u51fa\u4e00\u4e2a\u65b0\u7684\u8282\u70b9\u3002\n        2. \u4f9d\u6b21\u7ed9\u65b0\u7684\u8282\u70b9\u7684\u968f\u673a\u6307\u9488\u8d4b\u503c\uff0c\u800c\u4e14\u8fd9\u4e2a\u8d4b\u503c\u975e\u5e38\u5bb9\u6613 cur->next->random = cur->random->next\u3002\n        3. \u65ad\u5f00\u94fe\u8868\u53ef\u5f97\u5230\u6df1\u5ea6\u62f7\u8d1d\u540e\u7684\u65b0\u94fe\u8868\u3002\n     */\n    public class Solution_noExtraMap {\n        public RandomListNode copyRandomList(RandomListNode head) {\n            if (head == null) {\n                return null;\n            }\n\n            // duplicate new node right after\n            RandomListNode current = head;\n            while (current != null) {\n                RandomListNode t = new RandomListNode(current.label);\n                t.next = current.next;\n                current.next = t;\n                current = t.next;\n            }\n\n            // random pointer update for duplicate new node\n            current = head;\n            while (current != null) {\n                if (current.random != null) {\n                    current.next.random = current.random.next;\n                }\n                current = current.next.next;\n            }\n\n            // cut copied list out\n            current = head;\n            RandomListNode res = head.next;\n            while (current != null) {\n                RandomListNode t = current.next;\n                current.next = t.next;\n                if (t.next != null) {\n                    t.next = t.next.next;\n                }\n                current = current.next;\n            }\n\n            return res;\n        }\n    }\n\n    public class Solution {\n\n        // map from original node, to its copy node\n        HashMap<RandomListNode, RandomListNode> hm = new HashMap<>();\n\n        public RandomListNode copyRandomList(RandomListNode head) {\n\n            if (head == null) {\n                return null;\n            }\n\n            RandomListNode current = head;\n\n            while (current != null) {\n\n                RandomListNode currentCopy = getNodeCopy(current);\n\n                RandomListNode currentNextCopy = getNodeCopy(current.next);\n                RandomListNode currentRandomCopy = getNodeCopy(current.random);\n\n                currentCopy.next = currentNextCopy;\n                currentCopy.random = currentRandomCopy;\n\n                current = current.next;\n            }\n\n            return hm.get(head);\n        }\n\n        private RandomListNode getNodeCopy (RandomListNode originalNode) {\n\n            if (originalNode == null) { // @note: missed this check, last node will cause error, whose next is null\n                return null;\n            }\n\n            if (hm.containsKey(originalNode)) {\n                return hm.get(originalNode);\n\n            } else {\n                RandomListNode nodeCopy = new RandomListNode(originalNode.label);\n                hm.put(originalNode, nodeCopy);\n\n                return nodeCopy;\n            }\n        }\n    }\n\n}\n\n############\n\n/*\n// Definition for a Node.\nclass Node {\n    int val;\n    Node next;\n    Node random;\n\n    public Node(int val) {\n        this.val = val;\n        this.next = null;\n        this.random = null;\n    }\n}\n*/\nclass Solution {\n    public Node copyRandomList(Node head) {\n        if (head == null) {\n            return null;\n        }\n        for (Node cur = head; cur != null;) {\n            Node node = new Node(cur.val, cur.next);\n            cur.next = node;\n            cur = node.next;\n        }\n        for (Node cur = head; cur != null; cur = cur.next.next) {\n            if (cur.random != null) {\n                cur.next.random = cur.random.next;\n            }\n        }\n        Node ans = head.next;\n        for (Node cur = head; cur != null;) {\n            Node nxt = cur.next;\n            if (nxt != null) {\n                cur.next = nxt.next;\n            }\n            cur = nxt;\n        }\n        return ans;\n    }\n}",
    "139. Word Break": "import java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Set;\n\npublic class Word_Break {\n\n\n /*\n input - 1:\n \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab\",\n [\"a\",\"aa\",\"aaa\",\"aaaa\",\"aaaaa\",\"aaaaaa\",\"aaaaaaa\",\"aaaaaaaa\",\"aaaaaaaaa\",\"aaaaaaaaaa\"]\n\n input - 2:\n \"baaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\n [\"a\",\"aa\",\"aaa\",\"aaaa\",\"aaaaa\",\"aaaaaa\",\"aaaaaaa\",\"aaaaaaaa\",\"aaaaaaaaa\",\"aaaaaaaaaa\"]\n\n */\n\n public class Solution_dp {\n     public boolean wordBreak(String s, Set<String> dict) {\n\n         if (s == null || dict == null || dict.size() == 0)  return false;\n\n         int length = s.length();\n\n         // since both dfs and bfs not working, try dynamic programming here\n         // construct dp, dp[i] meaning position i-1 can from dict or not\n         boolean[] dp = new boolean[length + 1];\n         dp[0] = true; // @note: initiate\n\n         for (int i = 0; i < length + 1; i++) {\n\n             if (dp[i] == false)  {\n              continue;\n\n             } else { // if some previous dict word ending at index i-1\n\n              for (String each: dict) {\n\n                  if (i + each.length() > length)  continue;\n\n                  if (s.substring(i, i + each.length()).equals(each)) {\n\n                      dp[i + each.length()] = true;\n                      // i = i + each.length() - 1; // i++ later\n                      // break;\n                  }\n              }\n             }\n         }\n\n         return dp[length];\n     }\n }\n\n\n\n\n public class Solution_bfs_over_time {\n        public boolean wordBreak(String s, Set<String> wordDict) {\n\n            if (s == null || s.length() == 0 || wordDict == null || wordDict.size() == 0) {\n                return false;\n            }\n\n            // since dfs is not working, now try bfs. all valid word's substring enqueue\n            Queue<String> q = new LinkedList<>();\n\n            q.offer(s);\n\n            while (!q.isEmpty()) {\n\n                String current = q.poll();\n\n             // if (current.length() == 0) { // meaning all previoius matched in dict\n\n             //     return true;\n             // }\n\n                for (int i = 0; i < current.length(); i++) {\n\n                    String sub = current.substring(0, i + 1);\n\n                    if (wordDict.contains(sub)) {\n\n                        if (s.endsWith(sub)) { // @note: here is key, I missed it and the last word keeps dequeue and enqueue, infinite looping\n                            return true;\n                        }\n\n                        // q.offer(s.substring(i + 1)); // @note: mistake here, should be current.substring(), not s.substring()\n                        q.offer(current.substring(i + 1));\n                    }\n                }\n            }\n\n            return false;\n        }\n }\n\n\n public class Solution_dfs_over_time {\n\n     public boolean wordBreak(String s, Set<String> wordDict) {\n\n         // @note: here is contradictory somehow, maybe a separate helper method would be good\n         // if (s == null || s.length() == 0 || wordDict == null || wordDict.size() == 0) {\n         if (s == null || wordDict == null) {\n             return false;\n         }\n\n         if (s.length() == 0) {\n             return true;\n         }\n\n         // substring from index 0 to i, check if in wordDict\n         for (int i = 0; i < s.length(); i++) {\n             String sub = s.substring(0, i + 1);\n\n             if (wordDict.contains(sub)) {\n                 boolean isBreakable = wordBreak(s.substring(i + 1), wordDict);\n\n                 // just write out logic more clearly\n                 if (isBreakable) {\n                     return true;\n                 }\n             }\n         }\n\n         return false;\n     }\n }\n\n}\n\n//////\n\nclass Solution {\n    public boolean wordBreak(String s, List<String> wordDict) {\n        Set<String> words = new HashSet<>(wordDict);\n        int n = s.length();\n        boolean[] dp = new boolean[n + 1];\n        dp[0] = true;\n        for (int i = 1; i <= n; ++i) {\n            for (int j = 0; j < i; ++j) {\n                if (dp[j] && words.contains(s.substring(j, i))) {\n                    dp[i] = true;\n                    break;\n                }\n            }\n        }\n        return dp[n];\n    }\n}",
    "140. Word Break II": "class Trie {\n    Trie[] children = new Trie[26];\n    boolean isEnd;\n\n    void insert(String word) {\n        Trie node = this;\n        for (char c : word.toCharArray()) {\n            c -= 'a';\n            if (node.children[c] == null) {\n                node.children[c] = new Trie();\n            }\n            node = node.children[c];\n        }\n        node.isEnd = true;\n    }\n\n    boolean search(String word) {\n        Trie node = this;\n        for (char c : word.toCharArray()) {\n            c -= 'a';\n            if (node.children[c] == null) {\n                return false;\n            }\n            node = node.children[c];\n        }\n        return node.isEnd;\n    }\n}\n\nclass Solution {\n    private Trie trie = new Trie();\n\n    public List<String> wordBreak(String s, List<String> wordDict) {\n        for (String w : wordDict) {\n            trie.insert(w);\n        }\n        List<List<String>> res = dfs(s);\n        return res.stream().map(e -> String.join(\" \", e)).collect(Collectors.toList());\n    }\n\n    private List<List<String>> dfs(String s) {\n        List<List<String>> res = new ArrayList<>();\n        if (\"\".equals(s)) {\n            res.add(new ArrayList<>());\n            return res;\n        }\n        for (int i = 1; i <= s.length(); ++i) {\n            if (trie.search(s.substring(0, i))) {\n                for (List<String> v : dfs(s.substring(i))) {\n                    v.add(0, s.substring(0, i));\n                    res.add(v);\n                }\n            }\n        }\n        return res;\n    }\n}",
    "141. Linked List Cycle": "/**\n * Definition for singly-linked list.\n * class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public boolean hasCycle(ListNode head) {\n        ListNode slow = head;\n        ListNode fast = head;\n        while (fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n            if (slow == fast) {\n                return true;\n            }\n        }\n        return false;\n    }\n}",
    "142. Linked List Cycle II": "/**\n * Definition for singly-linked list.\n * class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        ListNode fast = head, slow = head;\n        while (fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n            if (slow == fast) {\n                ListNode ans = head;\n                while (ans != slow) {\n                    ans = ans.next;\n                    slow = slow.next;\n                }\n                return ans;\n            }\n        }\n        return null;\n    }\n}",
    "143. Reorder List": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public void reorderList(ListNode head) {\n        ListNode fast = head, slow = head;\n        while (fast.next != null && fast.next.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n\n        ListNode cur = slow.next;\n        slow.next = null;\n\n        ListNode pre = null;\n        while (cur != null) {\n            ListNode t = cur.next;\n            cur.next = pre;\n            pre = cur;\n            cur = t;\n        }\n        cur = head;\n\n        while (pre != null) {\n            ListNode t = pre.next;\n            pre.next = cur.next;\n            cur.next = pre;\n            cur = pre.next;\n            pre = t;\n        }\n    }\n}",
    "144. Binary Tree Preorder Traversal": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public List<Integer> preorderTraversal(TreeNode root) {\n        List<Integer> ans = new ArrayList<>();\n        while (root != null) {\n            if (root.left == null) {\n                ans.add(root.val);\n                root = root.right;\n            } else {\n                TreeNode prev = root.left;\n                while (prev.right != null && prev.right != root) {\n                    prev = prev.right;\n                }\n                if (prev.right == null) {\n                    ans.add(root.val);\n                    prev.right = root;\n                    root = root.left;\n                } else {\n                    prev.right = null;\n                    root = root.right;\n                }\n            }\n        }\n        return ans;\n    }\n}",
    "145. Binary Tree Postorder Traversal": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public List<Integer> postorderTraversal(TreeNode root) {\n        LinkedList<Integer> ans = new LinkedList<>();\n        while (root != null) {\n            if (root.right == null) {\n                ans.addFirst(root.val);\n                root = root.left;\n            } else {\n                TreeNode next = root.right;\n                while (next.left != null && next.left != root) {\n                    next = next.left;\n                }\n                if (next.left == null) {\n                    ans.addFirst(root.val);\n                    next.left = root;\n                    root = root.right;\n                } else {\n                    next.left = null;\n                    root = root.left;\n                }\n            }\n        }\n        return ans;\n    }\n}",
    "146. LRU Cache": "class Node {\n    int key;\n    int val;\n    Node prev;\n    Node next;\n\n    Node() {\n    }\n\n    Node(int key, int val) {\n        this.key = key;\n        this.val = val;\n    }\n}\n\nclass LRUCache {\n    private Map<Integer, Node> cache = new HashMap<>();\n    private Node head = new Node();\n    private Node tail = new Node();\n    private int capacity;\n    private int size;\n\n    public LRUCache(int capacity) {\n        this.capacity = capacity;\n        head.next = tail;\n        tail.prev = head;\n    }\n\n    public int get(int key) {\n        if (!cache.containsKey(key)) {\n            return -1;\n        }\n        Node node = cache.get(key);\n        moveToHead(node);\n        return node.val;\n    }\n\n    public void put(int key, int value) {\n        if (cache.containsKey(key)) {\n            Node node = cache.get(key);\n            node.val = value;\n            moveToHead(node);\n        } else {\n            Node node = new Node(key, value);\n            cache.put(key, node);\n            addToHead(node);\n            ++size;\n            if (size > capacity) {\n                node = removeTail();\n                cache.remove(node.key);\n                --size;\n            }\n        }\n    }\n\n    private void moveToHead(Node node) {\n        removeNode(node);\n        addToHead(node);\n    }\n\n    private void removeNode(Node node) {\n        node.prev.next = node.next;\n        node.next.prev = node.prev;\n    }\n\n    private void addToHead(Node node) {\n        node.next = head.next;\n        node.prev = head;\n        head.next = node;\n        node.next.prev = node;\n    }\n\n    private Node removeTail() {\n        Node node = tail.prev;\n        removeNode(node);\n        return node;\n    }\n}\n\n/**\n * Your LRUCache object will be instantiated and called as such:\n * LRUCache obj = new LRUCache(capacity);\n * int param_1 = obj.get(key);\n * obj.put(key,value);\n */",
    "147. Insertion Sort List": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode insertionSortList(ListNode head) {\n        if (head == null || head.next == null) {\n            return head;\n        }\n        ListNode dummy = new ListNode(head.val, head);\n        ListNode pre = dummy, cur = head;\n        while (cur != null) {\n            if (pre.val <= cur.val) {\n                pre = cur;\n                cur = cur.next;\n                continue;\n            }\n            ListNode p = dummy;\n            while (p.next.val <= cur.val) {\n                p = p.next;\n            }\n            ListNode t = cur.next;\n            cur.next = p.next;\n            p.next = cur;\n            pre.next = t;\n            cur = t;\n        }\n        return dummy.next;\n    }\n}",
    "148. Sort List": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode sortList(ListNode head) {\n        if (head == null || head.next == null) {\n            return head;\n        }\n        ListNode slow = head, fast = head.next;\n        while (fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        ListNode t = slow.next;\n        slow.next = null;\n        ListNode l1 = sortList(head);\n        ListNode l2 = sortList(t);\n        ListNode dummy = new ListNode();\n        ListNode cur = dummy;\n        while (l1 != null && l2 != null) {\n            if (l1.val <= l2.val) {\n                cur.next = l1;\n                l1 = l1.next;\n            } else {\n                cur.next = l2;\n                l2 = l2.next;\n            }\n            cur = cur.next;\n        }\n        cur.next = l1 == null ? l2 : l1;\n        return dummy.next;\n    }\n}",
    "149. Max Points on a Line": "class Solution {\n    public int maxPoints(int[][] points) {\n        int n = points.length;\n        int ans = 1;\n        for (int i = 0; i < n; ++i) {\n            int x1 = points[i][0], y1 = points[i][1];\n            Map<String, Integer> cnt = new HashMap<>();\n            for (int j = i + 1; j < n; ++j) {\n                int x2 = points[j][0], y2 = points[j][1];\n                int dx = x2 - x1, dy = y2 - y1;\n                int g = gcd(dx, dy);\n                String k = (dx / g) + \".\" + (dy / g);\n                cnt.put(k, cnt.getOrDefault(k, 0) + 1);\n                ans = Math.max(ans, cnt.get(k) + 1);\n            }\n        }\n        return ans;\n    }\n\n    private int gcd(int a, int b) {\n        return b == 0 ? a : gcd(b, a % b);\n    }\n}",
    "150. Evaluate Reverse Polish Notation": "class Solution {\n    public int evalRPN(String[] tokens) {\n        Deque<Integer> stk = new ArrayDeque<>();\n        for (String t : tokens) {\n            if (t.length() > 1 || Character.isDigit(t.charAt(0))) {\n                stk.push(Integer.parseInt(t));\n            } else {\n                int y = stk.pop();\n                int x = stk.pop();\n                switch (t) {\n                case \"+\":\n                    stk.push(x + y);\n                    break;\n                case \"-\":\n                    stk.push(x - y);\n                    break;\n                case \"*\":\n                    stk.push(x * y);\n                    break;\n                default:\n                    stk.push(x / y);\n                    break;\n                }\n            }\n        }\n        return stk.pop();\n    }\n}",
    "151. Reverse Words in a String": "class Solution {\n    public String reverseWords(String s) {\n        List<String> words = Arrays.asList(s.trim().split(\"\\\\s+\"));\n        Collections.reverse(words);\n        return String.join(\" \", words);\n    }\n}",
    "152. Maximum Product Subarray": "class Solution {\n    public int maxProduct(int[] nums) {\n        int f = nums[0], g = nums[0], ans = nums[0];\n        for (int i = 1; i < nums.length; ++i) {\n            int ff = f, gg = g;\n            f = Math.max(nums[i], Math.max(ff * nums[i], gg * nums[i]));\n            g = Math.min(nums[i], Math.min(ff * nums[i], gg * nums[i]));\n            ans = Math.max(ans, f);\n        }\n        return ans;\n    }\n}",
    "153. Find Minimum in Rotated Sorted Array": "class Solution {\n    public int findMin(int[] nums) {\n        int n = nums.length;\n        if (nums[0] <= nums[n - 1]) {\n            return nums[0];\n        }\n        int left = 0, right = n - 1;\n        while (left < right) {\n            int mid = (left + right) >> 1;\n            if (nums[0] <= nums[mid]) {\n                left = mid + 1;\n            } else {\n                right = mid;\n            }\n        }\n        return nums[left];\n    }\n}",
    "154. Find Minimum in Rotated Sorted Array II": "class Solution {\n    public int findMin(int[] nums) {\n        int left = 0, right = nums.length - 1;\n        while (left < right) {\n            int mid = (left + right) >> 1;\n            if (nums[mid] > nums[right]) {\n                left = mid + 1;\n            } else if (nums[mid] < nums[right]) {\n                right = mid;\n            } else {\n                --right;\n            }\n        }\n        return nums[left];\n    }\n}",
    "155. Min Stack": "class MinStack {\n    private Deque<Integer> stk1 = new ArrayDeque<>();\n    private Deque<Integer> stk2 = new ArrayDeque<>();\n\n    public MinStack() {\n        stk2.push(Integer.MAX_VALUE);\n    }\n\n    public void push(int val) {\n        stk1.push(val);\n        stk2.push(Math.min(val, stk2.peek()));\n    }\n\n    public void pop() {\n        stk1.pop();\n        stk2.pop();\n    }\n\n    public int top() {\n        return stk1.peek();\n    }\n\n    public int getMin() {\n        return stk2.peek();\n    }\n}\n\n/**\n * Your MinStack object will be instantiated and called as such:\n * MinStack obj = new MinStack();\n * obj.push(val);\n * obj.pop();\n * int param_3 = obj.top();\n * int param_4 = obj.getMin();\n */",
    "160. Intersection of Two Linked Lists": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        ListNode a = headA, b = headB;\n        while (a != b) {\n            a = a == null ? headB : a.next;\n            b = b == null ? headA : b.next;\n        }\n        return a;\n    }\n}",
    "162. Find Peak Element": "class Solution {\n    public int findPeakElement(int[] nums) {\n        int left = 0, right = nums.length - 1;\n        while (left < right) {\n            int mid = (left + right) >> 1;\n            if (nums[mid] > nums[mid + 1]) {\n                right = mid;\n            } else {\n                left = mid + 1;\n            }\n        }\n        return left;\n    }\n}",
    "164. Maximum Gap": "public class Maximum_Gap {\n\n    public class Solution {\n        public int maximumGap(int[] nums) {\n            if (nums == null || nums.length <= 1) {\n                return 0;\n            }\n\n            // Step 1: find max and min element\n            int max = Integer.MIN_VALUE;\n            int min = Integer.MAX_VALUE;\n            for (int num : nums) {\n                if (num > max) {\n                    max = num;\n                }\n\n                if (num < min) {\n                    min = num;\n                }\n            }\n\n            int len = nums.length;\n\n            // Step 2: calculate the intervals and number of buckets.\n            int interval = (int) Math.ceil((double) (max - min) / (len - 1));\n\n            if (interval == 0) {\n                interval = 1;\n            }\n            int numBuckets = (max - min) / interval + 1;\n            Bucket[] buckets = new Bucket[numBuckets];\n            for (int i = 0; i < numBuckets; i++) {\n                buckets[i] = new Bucket();\n            }\n\n            // Step 3: iterate through the nums and assign the number into the buckets.\n            for (int num : nums) {\n                int bucketNum = (num - min) / interval;\n                if (num > buckets[bucketNum].max) {\n                    buckets[bucketNum].max = num;\n                }\n\n                if (num < buckets[bucketNum].min) {\n                    buckets[bucketNum].min = num;\n                }\n            }\n\n            // Step 4: iterate through the buckets and get the maximal gap\n            int prev = buckets[0].max;\n            int maxGap = 0;\n            for (int i = 1; i < numBuckets; i++) {\n                if (prev != Integer.MIN_VALUE && buckets[i].min != Integer.MAX_VALUE) {\n                    maxGap = Math.max(maxGap, buckets[i].min - prev);\n                    prev = buckets[i].max;\n                }\n            }\n\n            return maxGap;\n        }\n\n        private class Bucket {\n            public int min;\n            public int max;\n\n            public Bucket() {\n                min = Integer.MAX_VALUE;\n                max = Integer.MIN_VALUE;\n            }\n        }\n    }\n\n}\n\n//////\n\nclass Solution {\n    public int maximumGap(int[] nums) {\n        int n = nums.length;\n        if (n < 2) {\n            return 0;\n        }\n        int inf = 0x3f3f3f3f;\n        int mi = inf, mx = -inf;\n        for (int v : nums) {\n            mi = Math.min(mi, v);\n            mx = Math.max(mx, v);\n        }\n        int bucketSize = Math.max(1, (mx - mi) / (n - 1));\n        int bucketCount = (mx - mi) / bucketSize + 1;\n        int[][] buckets = new int[bucketCount][2];\n        for (var bucket : buckets) {\n            bucket[0] = inf;\n            bucket[1] = -inf;\n        }\n        for (int v : nums) {\n            int i = (v - mi) / bucketSize;\n            buckets[i][0] = Math.min(buckets[i][0], v);\n            buckets[i][1] = Math.max(buckets[i][1], v);\n        }\n        int prev = inf;\n        int ans = 0;\n        for (var bucket : buckets) {\n            if (bucket[0] > bucket[1]) {\n                continue;\n            }\n            ans = Math.max(ans, bucket[0] - prev);\n            prev = bucket[1];\n        }\n        return ans;\n    }\n}",
    "165. Compare Version Numbers": "class Solution {\n    public int compareVersion(String version1, String version2) {\n        int m = version1.length(), n = version2.length();\n        for (int i = 0, j = 0; i < m || j < n; ++i, ++j) {\n            int a = 0, b = 0;\n            while (i < m && version1.charAt(i) != '.') {\n                a = a * 10 + (version1.charAt(i++) - '0');\n            }\n            while (j < n && version2.charAt(j) != '.') {\n                b = b * 10 + (version2.charAt(j++) - '0');\n            }\n            if (a != b) {\n                return a < b ? -1 : 1;\n            }\n        }\n        return 0;\n    }\n}",
    "166. Fraction to Recurring Decimal": "class Solution {\n    public String fractionToDecimal(int numerator, int denominator) {\n        if (numerator == 0) {\n            return \"0\";\n        }\n        StringBuilder sb = new StringBuilder();\n        boolean neg = (numerator > 0) ^ (denominator > 0);\n        sb.append(neg ? \"-\" : \"\");\n        long num = Math.abs((long) numerator);\n        long d = Math.abs((long) denominator);\n        sb.append(num / d);\n        num %= d;\n        if (num == 0) {\n            return sb.toString();\n        }\n        sb.append(\".\");\n        Map<Long, Integer> mp = new HashMap<>();\n        while (num != 0) {\n            mp.put(num, sb.length());\n            num *= 10;\n            sb.append(num / d);\n            num %= d;\n            if (mp.containsKey(num)) {\n                int idx = mp.get(num);\n                sb.insert(idx, \"(\");\n                sb.append(\")\");\n                break;\n            }\n        }\n        return sb.toString();\n    }\n}",
    "167. Two Sum II - Input array is sorted": "public class Two_Sum_II_Input_array_is_sorted {\n\n    // time: O(N)\n    // space: O(1)\n    class Solution {\n        public int[] twoSum(int[] numbers, int target) {\n            int i = 0, j = numbers.length-1;\n            int sum;\n            while (i < j) {\n                sum = numbers[i] + numbers[j];\n                if (sum == target)\n                    return new int[]{i+1, j+1};\n                else if (sum < target)\n                    i++;\n                else\n                    j--;\n            }\n\n            return null;\n\n        }\n    }\n}\n\n\n############\n\nclass Solution {\n    public int[] twoSum(int[] numbers, int target) {\n        int i = 1, j = numbers.length;\n        while (i < j) {\n            int x = numbers[i - 1] + numbers[j - 1];\n            if (x == target) {\n                return new int[] {i, j};\n            }\n            if (x < target) {\n                ++i;\n            } else {\n                --j;\n            }\n        }\n        return new int[] {-1, -1};\n    }\n}",
    "168. Excel Sheet Column Title": "class Solution {\n    public String convertToTitle(int columnNumber) {\n        StringBuilder res = new StringBuilder();\n        while (columnNumber != 0) {\n            --columnNumber;\n            res.append((char) ('A' + columnNumber % 26));\n            columnNumber /= 26;\n        }\n        return res.reverse().toString();\n    }\n}",
    "169. Majority Element": "class Solution {\n    public int majorityElement(int[] nums) {\n        int cnt = 0, m = 0;\n        for (int x : nums) {\n            if (cnt == 0) {\n                m = x;\n                cnt = 1;\n            } else {\n                cnt += m == x ? 1 : -1;\n            }\n        }\n        return m;\n    }\n}",
    "171. Excel Sheet Column Number": "class Solution {\n    public int titleToNumber(String columnTitle) {\n        int res = 0;\n        for (char c : columnTitle.toCharArray()) {\n            res = res * 26 + (c - 'A' + 1);\n        }\n        return res;\n    }\n}",
    "172. Factorial Trailing Zeroes": "class Solution {\n    public int trailingZeroes(int n) {\n        int ans = 0;\n        while (n > 0) {\n            n /= 5;\n            ans += n;\n        }\n        return ans;\n    }\n}",
    "173. Binary Search Tree Iterator": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Stack;\n\npublic class Binary_Search_Tree_Iterator {\n\n    /**\n     * Definition for binary tree\n     * public class TreeNode {\n     *     int val;\n     *     TreeNode left;\n     *     TreeNode right;\n     *     TreeNode(int x) { val = x; }\n     * }\n     */\n    public class BSTIterator {\n\n        Stack<TreeNode> sk;\n\n        // @note:@memorize: important feature, min is always going left branch to leaf\n        public BSTIterator(TreeNode root) {\n            sk = new Stack<>();\n\n            // all the way to leftmost leaf\n            while (root != null) {\n                sk.push(root);\n                root = root.left;\n            }\n\n        }\n\n        /** @return whether we have a next smallest number */\n        public boolean hasNext() {\n            return !sk.isEmpty();\n        }\n\n        /** @return the next smallest number */\n        public int next() {\n            TreeNode minNode = sk.pop();\n\n            TreeNode current = minNode;\n            // update stack, possible next time min is frmo its right-then-left branch\n            if (current.right != null) {\n                current = current.right;\n\n                // same logic as in constructor\n                while (current != null) {\n                    sk.push(current.left);\n                    current = current.left;\n                }\n            }\n\n            return minNode.val;\n        }\n    }\n\n/**\n * Your BSTIterator will be called like this:\n * BSTIterator i = new BSTIterator(root);\n * while (i.hasNext()) v[f()] = i.next();\n */\n}\n\n############\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass BSTIterator {\n    private Deque<TreeNode> stack = new LinkedList<>();\n\n    public BSTIterator(TreeNode root) {\n        for (; root != null; root = root.left) {\n            stack.offerLast(root);\n        }\n    }\n\n    public int next() {\n        TreeNode cur = stack.pollLast();\n        for (TreeNode node = cur.right; node != null; node = node.left) {\n            stack.offerLast(node);\n        }\n        return cur.val;\n    }\n\n    public boolean hasNext() {\n        return !stack.isEmpty();\n    }\n}\n\n/**\n * Your BSTIterator object will be instantiated and called as such:\n * BSTIterator obj = new BSTIterator(root);\n * int param_1 = obj.next();\n * boolean param_2 = obj.hasNext();\n */",
    "174. Dungeon Game": "class Solution {\n    public int calculateMinimumHP(int[][] dungeon) {\n        int m = dungeon.length, n = dungeon[0].length;\n        int[][] dp = new int[m + 1][n + 1];\n        for (var e : dp) {\n            Arrays.fill(e, 1 << 30);\n        }\n        dp[m][n - 1] = dp[m - 1][n] = 1;\n        for (int i = m - 1; i >= 0; --i) {\n            for (int j = n - 1; j >= 0; --j) {\n                dp[i][j] = Math.max(1, Math.min(dp[i + 1][j], dp[i][j + 1]) - dungeon[i][j]);\n            }\n        }\n        return dp[0][0];\n    }\n}",
    "179. Largest Number": "class Solution {\n    public String largestNumber(int[] nums) {\n        List<String> vs = new ArrayList<>();\n        for (int v : nums) {\n            vs.add(v + \"\");\n        }\n        vs.sort((a, b) -> (b + a).compareTo(a + b));\n        if (\"0\".equals(vs.get(0))) {\n            return \"0\";\n        }\n        return String.join(\"\", vs);\n    }\n}",
    "187. Repeated DNA Sequences": "class Solution {\n    public List<String> findRepeatedDnaSequences(String s) {\n        Map<String, Integer> cnt = new HashMap<>();\n        List<String> ans = new ArrayList<>();\n        for (int i = 0; i < s.length() - 10 + 1; ++i) {\n            String t = s.substring(i, i + 10);\n            if (cnt.merge(t, 1, Integer::sum) == 2) {\n                ans.add(t);\n            }\n        }\n        return ans;\n    }\n}",
    "188. Best Time to Buy and Sell Stock IV": "class Solution {\n    public int maxProfit(int k, int[] prices) {\n        int n = prices.length;\n        int[][] f = new int[k + 1][2];\n        for (int j = 1; j <= k; ++j) {\n            f[j][1] = -prices[0];\n        }\n        for (int i = 1; i < n; ++i) {\n            for (int j = k; j > 0; --j) {\n                f[j][0] = Math.max(f[j][1] + prices[i], f[j][0]);\n                f[j][1] = Math.max(f[j - 1][0] - prices[i], f[j][1]);\n            }\n        }\n        return f[k][0];\n    }\n}",
    "189. Rotate Array": "class Solution {\n    private int[] nums;\n\n    public void rotate(int[] nums, int k) {\n        this.nums = nums;\n        int n = nums.length;\n        k %= n;\n        reverse(0, n - 1);\n        reverse(0, k - 1);\n        reverse(k, n - 1);\n    }\n\n    private void reverse(int i, int j) {\n        for (; i < j; ++i, --j) {\n            int t = nums[i];\n            nums[i] = nums[j];\n            nums[j] = t;\n        }\n    }\n}",
    "190. Reverse Bits": "public class Solution {\n    // you need treat n as an unsigned value\n    public int reverseBits(int n) {\n        int res = 0;\n        for (int i = 0; i < 32 && n != 0; ++i) {\n            res |= ((n & 1) << (31 - i));\n            n >>>= 1;\n        }\n        return res;\n    }\n}",
    "191. Number of 1 Bits": "public class Solution {\n    // you need to treat n as an unsigned value\n    public int hammingWeight(int n) {\n        int ans = 0;\n        while (n != 0) {\n            n &= n - 1;\n            ++ans;\n        }\n        return ans;\n    }\n}",
    "198. House Robber": "public class House_Robber {\n\n\n    class Solution {\n        public int rob(int[] nums) {\n\n            if (nums == null || nums.length == 0) {\n                return 0;\n            }\n\n            // dp[i] means until i, max possible amount\n            int[] dp = new int[nums.length + 1];\n\n            dp[0] = 0;\n            dp[1] = nums[0];\n\n            for (int i = 2; i <= nums.length; i++) {\n                // 2 cases: rob current house, not rob current\n                dp[i] = Math.max(nums[i - 1] + dp[i - 2], dp[i - 1]);\n            }\n\n            return dp[nums.length];\n        }\n    }\n}\n\n/////////\n\nclass Solution {\n    public int rob(int[] nums) {\n        int a = 0, b = nums[0];\n        for (int i = 1; i < nums.length; ++i) {\n            int c = Math.max(nums[i] + a, b);\n            a = b;\n            b = c;\n        }\n        return b;\n    }\n}",
    "199. Binary Tree Right Side View": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public List<Integer> rightSideView(TreeNode root) {\n        List<Integer> ans = new ArrayList<>();\n        if (root == null) {\n            return ans;\n        }\n        Deque<TreeNode> q = new ArrayDeque<>();\n        q.offer(root);\n        while (!q.isEmpty()) {\n            ans.add(q.peekLast().val);\n            for (int n = q.size(); n > 0; --n) {\n                TreeNode node = q.poll();\n                if (node.left != null) {\n                    q.offer(node.left);\n                }\n                if (node.right != null) {\n                    q.offer(node.right);\n                }\n            }\n        }\n        return ans;\n    }\n}",
    "200. Number of Islands": "class Solution {\n    private char[][] grid;\n    private int m;\n    private int n;\n\n    public int numIslands(char[][] grid) {\n        m = grid.length;\n        n = grid[0].length;\n        this.grid = grid;\n        int ans = 0;\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (grid[i][j] == '1') {\n                    dfs(i, j);\n                    ++ans;\n                }\n            }\n        }\n        return ans;\n    }\n\n    private void dfs(int i, int j) {\n        grid[i][j] = '0';\n        int[] dirs = {-1, 0, 1, 0, -1};\n        for (int k = 0; k < 4; ++k) {\n            int x = i + dirs[k];\n            int y = j + dirs[k + 1];\n            if (x >= 0 && x < m && y >= 0 && y < n && grid[x][y] == '1') {\n                dfs(x, y);\n            }\n        }\n    }\n}\n\n//////\n\nclass Solution {\n    private char[][] grid;\n    private int m;\n    private int n;\n\n    public int numIslands(char[][] grid) {\n        m = grid.length;\n        n = grid[0].length;\n        this.grid = grid;\n        int ans = 0;\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (grid[i][j] == '1') {\n                    bfs(i, j);\n                    ++ans;\n                }\n            }\n        }\n        return ans;\n    }\n\n    private void bfs(int i, int j) {\n        grid[i][j] = '0';\n        Deque<int[]> q = new ArrayDeque<>();\n        q.offer(new int[] {i, j});\n        int[] dirs = {-1, 0, 1, 0, -1};\n        while (!q.isEmpty()) {\n            int[] p = q.poll();\n            for (int k = 0; k < 4; ++k) {\n                int x = p[0] + dirs[k];\n                int y = p[1] + dirs[k + 1];\n                if (x >= 0 && x < m && y >= 0 && y < n && grid[x][y] == '1') {\n                    q.offer(new int[] {x, y});\n                    grid[x][y] = '0';\n                }\n            }\n        }\n    }\n}",
    "201. Bitwise AND of Numbers Range": "class Solution {\n    public int rangeBitwiseAnd(int left, int right) {\n        while (left < right) {\n            right &= (right - 1);\n        }\n        return right;\n    }\n}",
    "202. Happy Number": "class Solution {\n    public boolean isHappy(int n) {\n        int slow = n, fast = next(n);\n        while (slow != fast) {\n            slow = next(slow);\n            fast = next(next(fast));\n        }\n        return slow == 1;\n    }\n\n    private int next(int x) {\n        int y = 0;\n        for (; x > 0; x /= 10) {\n            y += (x % 10) * (x % 10);\n        }\n        return y;\n    }\n}",
    "203. Remove Linked List Elements": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode removeElements(ListNode head, int val) {\n        ListNode dummy = new ListNode(-1, head);\n        ListNode pre = dummy;\n        while (pre.next != null) {\n            if (pre.next.val != val)\n                pre = pre.next;\n            else\n                pre.next = pre.next.next;\n        }\n        return dummy.next;\n    }\n}",
    "204. Count Primes": "class Solution {\n    public int countPrimes(int n) {\n        boolean[] primes = new boolean[n];\n        Arrays.fill(primes, true);\n        int ans = 0;\n        for (int i = 2; i < n; ++i) {\n            if (primes[i]) {\n                ++ans;\n                for (int j = i + i; j < n; j += i) {\n                    primes[j] = false;\n                }\n            }\n        }\n        return ans;\n    }\n}",
    "205. Isomorphic Strings": "class Solution {\n    public boolean isIsomorphic(String s, String t) {\n        int[] d1 = new int[256];\n        int[] d2 = new int[256];\n        int n = s.length();\n        for (int i = 0; i < n; ++i) {\n            char a = s.charAt(i), b = t.charAt(i);\n            if (d1[a] != d2[b]) {\n                return false;\n            }\n            d1[a] = i + 1;\n            d2[b] = i + 1;\n        }\n        return true;\n    }\n}",
    "206. Reverse Linked List": "public class Reverse_Linked_List {\n\n    /**\n     * Definition for singly-linked list.\n     * public class ListNode {\n     *     int val;\n     *     ListNode next;\n     *     ListNode(int x) { val = x; }\n     * }\n     */\n\n    /*\n        1,2,3,4,5\n        2,1 prev=2 - 3,4,5 current=3\n        3,2,1 prev=3 - 4,5 current=4\n        ...\n     */\n    // https://leetcode.com/problems/reverse-linked-list/solution/\n    class Solution_oj_iterative {\n        public ListNode reverseList(ListNode head) {\n            ListNode prev = null;\n            ListNode curr = head;\n            while (curr != null) {\n                ListNode nextTemp = curr.next;\n                curr.next = prev;\n                prev = curr;\n                curr = nextTemp;\n            }\n            return prev;\n        }\n    }\n    class Solution_oj_recursively {\n        public ListNode reverseList(ListNode head) {\n            if (head == null || head.next == null) return head;\n            ListNode p = reverseList(head.next);\n            head.next.next = head;\n            head.next = null;\n            return p;\n        }\n    }\n\n    class Solution_recursively {\n        public ListNode reverseList(ListNode head) {\n\n            ListNode dummy = new ListNode(0);\n            // dummy.next = head;\n\n            ListNode current = head;\n\n            reverse(dummy, current);\n\n            return dummy.next;\n        }\n\n        private void reverse(ListNode dummy, ListNode current) {\n\n            if (current == null) {\n                return;\n            }\n\n            ListNode newHead = current.next;\n            ListNode oldDummyNext = dummy.next;\n\n            dummy.next = current;\n            current.next = oldDummyNext;\n\n            current = newHead;\n\n            this.reverse(dummy, current);\n        }\n    }\n\n\n    class Solution_iteratively {\n        public ListNode reverseList(ListNode head) {\n\n            ListNode dummy = new ListNode(0);\n            // dummy.next = head;\n\n            ListNode current = head;\n            while (current != null) {\n\n                ListNode newHead = current.next;\n                ListNode oldDummyNext = dummy.next;\n\n                dummy.next = current;\n                current.next = oldDummyNext; // initial node, oldDummyNext is null, which is what we want, and which is why \"// dummy.next = head;\" is commented out above\n\n                current = newHead;\n            }\n\n            return dummy.next;\n        }\n    }\n}\n\n############\n\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode dummy = new ListNode();\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode next = curr.next;\n            curr.next = dummy.next;\n            dummy.next = curr;\n            curr = next;\n        }\n        return dummy.next;\n    }\n}",
    "207. Course Schedule": "public class Course_Schedule {\n\n    public class Solution_bfs {\n        public boolean canFinish(int numCourses, int[][] prerequisites) { // Kahn's Algorithm\n            if(numCourses <= 0) {\n                return false;\n            }\n\n            if(prerequisites == null || prerequisites.length == 0) {\n                return true;\n            }\n\n            int[] inDegree = new int[numCourses];\n\n            // 1. setup indgree count\n            for(int[] edge : prerequisites) {\n                inDegree[edge[0]]++;\n            }\n\n            Queue<Integer> queue = new LinkedList<>();\n\n            // 2. start from node with no indgree, i.e. no prerquisites for this course\n            for(int i = 0; i < inDegree.length; i++) {\n                if(inDegree[i] == 0) {\n                    queue.offer(i);\n                }\n            }\n\n            List<Integer> result = new ArrayList<>();\n\n            while(!queue.isEmpty()) {\n                int currentCourse = queue.poll();\n                result.add(currentCourse);\n\n                for(int[] edge : prerequisites) {\n                    if(edge[1] == currentCourse) { // if a course requires current course\n\n                        if(--inDegree[edge[0]] == 0) // -1, since current course is taken, and fulfill course edge[0]\n                            queue.offer(edge[0]);\n                    }\n                }\n            }\n\n            return result.size() == numCourses;\n        }\n    }\n\n    public class Solution_dfs {\n        public boolean canFinish(int numCourses, int[][] prerequisites) {\n\n            if(prerequisites == null || prerequisites.length < 2) {\n                return true;\n            }\n\n            // 0 for not visited\uff0c1 for globally visited\uff0c-1 for visisted AND on current path\n            int[] isVisited = new int[numCourses];\n            List<List<Integer>> graph = new ArrayList<>();\n\n            // 1. build graph\n            for (int i = 0; i < numCourses; i++) {\n                graph.add(new ArrayList<>());\n            }\n            for (int[] each: prerequisites) {\n                graph.get(each[1]).add(each[0]);\n            }\n\n            // 2. dfs\n            for (int i = 0; i < numCourses; i++) {\n                if (!dfs(i, isVisited, graph)) {\n                    return false;\n                }\n            }\n\n            return true;\n        }\n\n        private boolean dfs(int courseIndex, int[] isVisited, List<List<Integer>> graph) {\n            if (isVisited[courseIndex] == 1) {\n                return true;\n            }\n            if (isVisited[courseIndex] == -1) {\n                return false; // cycle found\n            }\n\n            isVisited[courseIndex] = -1;\n            for (Integer next: graph.get(courseIndex)) {\n                if(!dfs(next, isVisited, graph)) {\n                    return false;\n                }\n            }\n\n            isVisited[courseIndex] = 1;\n            return true;\n        }\n    }\n\n}\n\n//////\n\nclass Solution {\n    public boolean canFinish(int numCourses, int[][] prerequisites) {\n        List<Integer>[] g = new List[numCourses];\n        Arrays.setAll(g, k -> new ArrayList<>());\n        int[] indeg = new int[numCourses];\n        for (var p : prerequisites) {\n            int a = p[0], b = p[1];\n            g[b].add(a);\n            ++indeg[a];\n        }\n        Deque<Integer> q = new ArrayDeque<>();\n        for (int i = 0; i < numCourses; ++i) {\n            if (indeg[i] == 0) {\n                q.offer(i);\n            }\n        }\n        int cnt = 0;\n        while (!q.isEmpty()) {\n            int i = q.poll();\n            ++cnt;\n            for (int j : g[i]) {\n                if (--indeg[j] == 0) {\n                    q.offer(j);\n                }\n            }\n        }\n        return cnt == numCourses;\n    }\n}",
    "208. Implement Trie (Prefix Tree)": "public class Implement_Trie_Prefix_Tree {\n\n    public static void main(String[] args) {\n        Implement_Trie_Prefix_Tree out = new Implement_Trie_Prefix_Tree();\n\n        Trie trie = out.new Trie();\n        trie.insert(\"abc\");\n        trie.insert(\"ab\");\n        System.out.println(trie.search(\"ab\"));\n        trie.insert(\"ab\");\n        System.out.println(trie.search(\"ab\"));\n        System.out.println(trie.startsWith(\"a\"));\n\n    }\n\n    class TrieNode {\n\n        // R children to node children\n        private TrieNode[] children;\n\n        private final int R = 26;\n\n        private boolean isEnd;\n\n        public TrieNode() {\n            children = new TrieNode[R];\n        }\n\n        public boolean containsKey(char ch) {\n            return children[ch - 'a'] != null;\n        }\n\n        public TrieNode get(char ch) {\n            return children[ch - 'a'];\n        }\n\n        public void put(char ch, TrieNode node) {\n            children[ch - 'a'] = node;\n        }\n\n        public void setEnd() {\n            isEnd = true;\n        }\n\n        public boolean isEnd() {\n            return isEnd;\n        }\n    }\n\n    class Trie {\n        private TrieNode root;\n\n        public Trie() {\n            root = new TrieNode();\n        }\n\n        // Inserts a word into the trie.\n        public void insert(String word) {\n            TrieNode node = root;\n\n            // @note:@memorize: iteration is better than recursion during trie building\n            for (int i = 0; i < word.length(); i++) {\n                char currentChar = word.charAt(i);\n                if (!node.containsKey(currentChar)) {\n                    node.put(currentChar, new TrieNode());\n                }\n                node = node.get(currentChar);\n            }\n            node.setEnd();\n        }\n\n        // search a prefix or whole key in trie and\n        // returns the node where search ends\n        private TrieNode searchPrefix(String word) {\n            TrieNode node = root;\n            for (int i = 0; i < word.length(); i++) {\n                char curLetter = word.charAt(i);\n                if (node.containsKey(curLetter)) {\n                    node = node.get(curLetter);\n                } else {\n                    return null;\n                }\n            }\n            return node;\n        }\n\n        // Returns if the word is in the trie.\n        public boolean search(String word) {\n            TrieNode node = searchPrefix(word);\n            return node != null && node.isEnd();\n        }\n\n        // Returns if there is any word in the trie\n        // that starts with the given prefix.\n        public boolean startsWith(String prefix) {\n            TrieNode node = searchPrefix(prefix);\n            return node != null;\n        }\n    }\n\n    // Your Trie object will be instantiated and called as such:\n    // Trie trie = new Trie();\n    // trie.insert(\"somestring\");\n    // trie.search(\"key\");\n\n}\n\n\n//////\n\nclass Trie {\n    private Trie[] children;\n    private boolean isEnd;\n\n    public Trie() {\n        children = new Trie[26];\n    }\n\n    public void insert(String word) {\n        Trie node = this;\n        for (char c : word.toCharArray()) {\n            int idx = c - 'a';\n            if (node.children[idx] == null) {\n                node.children[idx] = new Trie();\n            }\n            node = node.children[idx];\n        }\n        node.isEnd = true;\n    }\n\n    public boolean search(String word) {\n        Trie node = searchPrefix(word);\n        return node != null && node.isEnd;\n    }\n\n    public boolean startsWith(String prefix) {\n        Trie node = searchPrefix(prefix);\n        return node != null;\n    }\n\n    private Trie searchPrefix(String s) {\n        Trie node = this;\n        for (char c : s.toCharArray()) {\n            int idx = c - 'a';\n            if (node.children[idx] == null) {\n                return null;\n            }\n            node = node.children[idx];\n        }\n        return node;\n    }\n}\n\n/**\n * Your Trie object will be instantiated and called as such:\n * Trie obj = new Trie();\n * obj.insert(word);\n * boolean param_2 = obj.search(word);\n * boolean param_3 = obj.startsWith(prefix);\n */",
    "209. Minimum Size Subarray Sum": "class Solution {\n    public int minSubArrayLen(int target, int[] nums) {\n        int n = nums.length;\n        long s = 0;\n        int ans = n + 1;\n        for (int i = 0, j = 0; i < n; ++i) {\n            s += nums[i];\n            while (j < n && s >= target) {\n                ans = Math.min(ans, i - j + 1);\n                s -= nums[j++];\n            }\n        }\n        return ans <= n ? ans : 0;\n    }\n}",
    "210. Course Schedule II": "class Solution {\n    public int[] findOrder(int numCourses, int[][] prerequisites) {\n        List<Integer>[] g = new List[numCourses];\n        Arrays.setAll(g, k -> new ArrayList<>());\n        int[] indeg = new int[numCourses];\n        for (var p : prerequisites) {\n            int a = p[0], b = p[1];\n            g[b].add(a);\n            ++indeg[a];\n        }\n        Deque<Integer> q = new ArrayDeque<>();\n        for (int i = 0; i < numCourses; ++i) {\n            if (indeg[i] == 0) {\n                q.offer(i);\n            }\n        }\n        int[] ans = new int[numCourses];\n        int cnt = 0;\n        while (!q.isEmpty()) {\n            int i = q.poll();\n            ans[cnt++] = i;\n            for (int j : g[i]) {\n                if (--indeg[j] == 0) {\n                    q.offer(j);\n                }\n            }\n        }\n        return cnt == numCourses ? ans : new int[0];\n    }\n}",
    "211. Add and Search Word - Data structure design": "class Trie {\n    Trie[] children = new Trie[26];\n    boolean isEnd;\n}\n\nclass WordDictionary {\n    private Trie trie;\n\n    /** Initialize your data structure here. */\n    public WordDictionary() {\n        trie = new Trie();\n    }\n\n    public void addWord(String word) {\n        Trie node = trie;\n        for (char c : word.toCharArray()) {\n            int idx = c - 'a';\n            if (node.children[idx] == null) {\n                node.children[idx] = new Trie();\n            }\n            node = node.children[idx];\n        }\n        node.isEnd = true;\n    }\n\n    public boolean search(String word) {\n        return search(word, trie);\n    }\n\n    private boolean search(String word, Trie node) {\n        for (int i = 0; i < word.length(); ++i) {\n            char c = word.charAt(i);\n            int idx = c - 'a';\n            if (c != '.' && node.children[idx] == null) {\n                return false;\n            }\n            if (c == '.') {\n                for (Trie child : node.children) {\n                    if (child != null && search(word.substring(i + 1), child)) {\n                        return true;\n                    }\n                }\n                return false;\n            }\n            node = node.children[idx];\n        }\n        return node.isEnd;\n    }\n}\n\n/**\n * Your WordDictionary object will be instantiated and called as such:\n * WordDictionary obj = new WordDictionary();\n * obj.addWord(word);\n * boolean param_2 = obj.search(word);\n */",
    "212. Word Search II": "class Trie {\n    Trie[] children = new Trie[26];\n    int ref = -1;\n\n    public void insert(String w, int ref) {\n        Trie node = this;\n        for (int i = 0; i < w.length(); ++i) {\n            int j = w.charAt(i) - 'a';\n            if (node.children[j] == null) {\n                node.children[j] = new Trie();\n            }\n            node = node.children[j];\n        }\n        node.ref = ref;\n    }\n}\n\nclass Solution {\n    private char[][] board;\n    private String[] words;\n    private List<String> ans = new ArrayList<>();\n\n    public List<String> findWords(char[][] board, String[] words) {\n        this.board = board;\n        this.words = words;\n        Trie tree = new Trie();\n        for (int i = 0; i < words.length; ++i) {\n            tree.insert(words[i], i);\n        }\n        int m = board.length, n = board[0].length;\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                dfs(tree, i, j);\n            }\n        }\n        return ans;\n    }\n\n    private void dfs(Trie node, int i, int j) {\n        int idx = board[i][j] - 'a';\n        if (node.children[idx] == null) {\n            return;\n        }\n        node = node.children[idx];\n        if (node.ref != -1) {\n            ans.add(words[node.ref]);\n            node.ref = -1;\n        }\n        char c = board[i][j];\n        board[i][j] = '#';\n        int[] dirs = {-1, 0, 1, 0, -1};\n        for (int k = 0; k < 4; ++k) {\n            int x = i + dirs[k], y = j + dirs[k + 1];\n            if (x >= 0 && x < board.length && y >= 0 && y < board[0].length && board[x][y] != '#') {\n                dfs(node, x, y);\n            }\n        }\n        board[i][j] = c;\n    }\n}",
    "213. House Robber II": "class Solution {\n    public int rob(int[] nums) {\n        int n = nums.length;\n        if (n == 1) {\n            return nums[0];\n        }\n        return Math.max(rob(nums, 0, n - 2), rob(nums, 1, n - 1));\n    }\n\n    private int rob(int[] nums, int l, int r) {\n        int f = 0, g = 0;\n        for (; l <= r; ++l) {\n            int ff = Math.max(f, g);\n            g = f + nums[l];\n            f = ff;\n        }\n        return Math.max(f, g);\n    }\n}",
    "214. Shortest Palindrome": "public class Shortest_Palindrome {\n\n\n    public class Solution {\n        public String shortestPalindrome(String s) {\n\n            if (s == null || s.length() == 0) {\n                return \"\";\n            }\n\n            int i = 0, n = s.length();\n            for (int j = n - 1; j >= 0; --j) { // @note: j will cross i, eg. making i=2 for \"adcba\"\n                if (s.charAt(i) == s.charAt(j)) {\n                    ++i;\n                }\n            }\n            // now [0, i) is a possible palindrome, but need extra check\n            if (i == n) {\n                return s;\n            }\n\n            String remaining = s.substring(i); // need to add reverse part of it\n            String rem_rev = new StringBuilder(remaining).reverse().toString();\n            return rem_rev + shortestPalindrome(s.substring(0, i)) + remaining;\n\n        }\n    }\n}\n\n############\n\nclass Solution {\n    public String shortestPalindrome(String s) {\n        int base = 131;\n        int mul = 1;\n        int mod = (int) 1e9 + 7;\n        int prefix = 0, suffix = 0;\n        int idx = 0;\n        int n = s.length();\n        for (int i = 0; i < n; ++i) {\n            int t = s.charAt(i) - 'a' + 1;\n            prefix = (int) (((long) prefix * base + t) % mod);\n            suffix = (int) ((suffix + (long) t * mul) % mod);\n            mul = (int) (((long) mul * base) % mod);\n            if (prefix == suffix) {\n                idx = i + 1;\n            }\n        }\n        if (idx == n) {\n            return s;\n        }\n        return new StringBuilder(s.substring(idx)).reverse().toString() + s;\n    }\n}",
    "215. Kth Largest Element in an Array": "class Solution {\n    public int findKthLargest(int[] nums, int k) {\n        int n = nums.length;\n        return quickSort(nums, 0, n - 1, n - k);\n    }\n\n    private int quickSort(int[] nums, int left, int right, int k) {\n        if (left == right) {\n            return nums[left];\n        }\n        int i = left - 1, j = right + 1;\n        int x = nums[(left + right) >>> 1];\n        while (i < j) {\n            while (nums[++i] < x)\n                ;\n            while (nums[--j] > x)\n                ;\n            if (i < j) {\n                int t = nums[i];\n                nums[i] = nums[j];\n                nums[j] = t;\n            }\n        }\n        if (j < k) {\n            return quickSort(nums, j + 1, right, k);\n        }\n        return quickSort(nums, left, j, k);\n    }\n}",
    "216. Combination Sum III": "class Solution {\n    private List<List<Integer>> ans = new ArrayList<>();\n    private List<Integer> t = new ArrayList<>();\n    private int k;\n\n    public List<List<Integer>> combinationSum3(int k, int n) {\n        this.k = k;\n        dfs(1, n);\n        return ans;\n    }\n\n    private void dfs(int i, int s) {\n        if (s == 0) {\n            if (t.size() == k) {\n                ans.add(new ArrayList<>(t));\n            }\n            return;\n        }\n        if (i > 9 || i > s || t.size() >= k) {\n            return;\n        }\n        t.add(i);\n        dfs(i + 1, s - i);\n        t.remove(t.size() - 1);\n        dfs(i + 1, s);\n    }\n}",
    "217. Contains Duplicate": "class Solution {\n    public boolean containsDuplicate(int[] nums) {\n        Set<Integer> s = new HashSet<>();\n        for (int num : nums) {\n            if (!s.add(num)) {\n                return true;\n            }\n        }\n        return false;\n    }\n}",
    "218. The Skyline Problem": "import java.util.*;\n\npublic class The_Skyline_Problem {\n\n    public static void main(String[] args) {\n\n        The_Skyline_Problem out = new The_Skyline_Problem();\n\n        Solution_Heap s = out.new Solution_Heap();\n\n        // output: [ [2 10], [3 15], [7 12], [12 0], [15 10], [20 8], [24, 0] ]\n        s.getSkyline( new int[][]{ {2,9,10}, {3,7,15}, {5,12,12}, {15,20,10}, {19,24,8} } )\n            .stream().forEach(System.out::println);\n    }\n\n    class Solution_Heap {\n\n    public List<List<Integer>> getSkyline(int[][] buildings) {\n\n            List<List<Integer>> result = new ArrayList<>();\n\n            if (buildings == null || buildings.length == 0\n                || buildings[0].length == 0) {\n                return result;\n            }\n\n            List<Edge> edges = new ArrayList<Edge>();\n\n            // add all left/right edges\n            for (int[] each: buildings) {\n                edges.add(new Edge(each[0], each[2], true));\n                edges.add(new Edge(each[1], each[2], false));\n            }\n\n            // sort edges, NlogN\n            Collections.sort(edges, (a, b) -> {\n                if (a.x != b.x) {\n                    return Integer.compare(a.x, b.x);\n                }\n\n                if (a.isStart && b.isStart) {\n                    return Integer.compare(b.height, a.height); // higher edge at front\n                }\n\n                if (!a.isStart && !b.isStart) {\n                    return Integer.compare(a.height, b.height); // lower edge at front\n                }\n\n                return a.isStart ? -1 : 1; // lower edge at front\n            });\n\n            // process edges, comparator is reverseOrder()\n            PriorityQueue<Integer> heightHeap = new PriorityQueue<Integer>(Collections.reverseOrder());\n\n            for (Edge edge : edges) {\n\n                if (edge.isStart) {\n\n                    if (heightHeap.isEmpty() || edge.height > heightHeap.peek()) {\n                        result.add(Arrays.asList( edge.x, edge.height ));\n                    }\n\n                    heightHeap.add(edge.height);\n\n                } else {\n\n                    heightHeap.remove(edge.height);\n\n                    if (heightHeap.isEmpty()){\n                        result.add( Arrays.asList(edge.x, 0) ); // last point\n                    } else if (edge.height > heightHeap.peek()){ // @note: intersect\n                        result.add( Arrays.asList(edge.x, heightHeap.peek()) );\n                    }\n                }\n            }\n            return result;\n        }\n\n        class Edge {\n            int x; // x\u5750\u6807\n            int height;\n            boolean isStart;\n\n            public Edge(int x, int height, boolean isStart) {\n                this.x = x;\n                this.height = height;\n                this.isStart = isStart;\n            }\n        }\n    }\n\n    // merge sort example\n    public class Solution_mergeSort {\n\n        public List<int[]> getSkyline(int[][] buildings) {\n\n            if(buildings == null || buildings.length == 0) {\n                return new LinkedList<int[]>();\n            }\n\n            return getSkyline(buildings, 0, buildings.length - 1);\n        }\n\n        // NlogN\n        private LinkedList<int[]> getSkyline(int[][] buildings, int lo, int hi) {\n\n            if (lo < hi) {\n\n                int mid = lo + (hi - lo) / 2;\n                return mergeSkylines(getSkyline(buildings, lo, mid), getSkyline(buildings, mid + 1, hi));\n\n            } else {\n\n                //  lo == hi, base case, add the final already-merged building to skyline\n                LinkedList<int[]> skyline = new LinkedList<int[]>();\n\n                skyline.add(new int[]{buildings[lo][0], buildings[lo][2]}); // only care about [left-index, height]\n                skyline.add(new int[]{buildings[lo][1], 0}); // right-index is just for last right edge\n\n                return skyline;\n            }\n        }\n\n        // merge two Skylines\n        private LinkedList<int[]> mergeSkylines(LinkedList<int[]> skyline1, LinkedList<int[]> skyline2) {\n\n            LinkedList<int[]> skyline = new LinkedList<int[]>();\n            int height1 = 0, height2 = 0;\n\n            while(skyline1.size() > 0 && skyline2.size() > 0) {\n\n                int index = 0, height = 0;\n\n                // @note: always remove the smaller index first, so order is guaranteed\n                if (skyline1.getFirst()[0] < skyline2.getFirst()[0]) {\n                    index = skyline1.getFirst()[0];\n                    height1 = skyline1.getFirst()[1];\n                    height = Math.max(height1, height2);\n                    skyline1.removeFirst();\n                } else if (skyline1.getFirst()[0] > skyline2.getFirst()[0]) {\n                    index = skyline2.getFirst()[0];\n                    height2 = skyline2.getFirst()[1];\n                    height = Math.max(height1, height2);\n                    skyline2.removeFirst();\n                } else {\n                    index = skyline1.getFirst()[0];\n                    height1 = skyline1.getFirst()[1];\n                    height2 = skyline2.getFirst()[1];\n                    height = Math.max(height1, height2);\n                    skyline1.removeFirst();\n                    skyline2.removeFirst();\n                }\n\n                if (skyline.size() == 0 || height != skyline.getLast()[1]) {\n                    skyline.add(new int[]{index, height});\n                }\n            }\n\n            // final check\n            skyline.addAll(skyline1);\n            skyline.addAll(skyline2);\n\n            return skyline;\n        }\n\n    }\n\n}",
    "219. Contains Duplicate II": "class Solution {\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\n        Map<Integer, Integer> d = new HashMap<>();\n        for (int i = 0; i < nums.length; ++i) {\n            if (i - d.getOrDefault(nums[i], -1000000) <= k) {\n                return true;\n            }\n            d.put(nums[i], i);\n        }\n        return false;\n    }\n}",
    "220. Contains Duplicate III": "class Solution {\n    public boolean containsNearbyAlmostDuplicate(int[] nums, int indexDiff, int valueDiff) {\n        TreeSet<Long> ts = new TreeSet<>();\n        for (int i = 0; i < nums.length; ++i) {\n            Long x = ts.ceiling((long) nums[i] - (long) valueDiff);\n            if (x != null && x <= (long) nums[i] + (long) valueDiff) {\n                return true;\n            }\n            ts.add((long) nums[i]);\n            if (i >= indexDiff) {\n                ts.remove((long) nums[i - indexDiff]);\n            }\n        }\n        return false;\n    }\n}",
    "221. Maximal Square": "class Solution {\n    public int maximalSquare(char[][] matrix) {\n        int m = matrix.length, n = matrix[0].length;\n        int[][] dp = new int[m + 1][n + 1];\n        int mx = 0;\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (matrix[i][j] == '1') {\n                    dp[i + 1][j + 1] = Math.min(Math.min(dp[i][j + 1], dp[i + 1][j]), dp[i][j]) + 1;\n                    mx = Math.max(mx, dp[i + 1][j + 1]);\n                }\n            }\n        }\n        return mx * mx;\n    }\n}",
    "222. Count Complete Tree Nodes": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public int countNodes(TreeNode root) {\n        if (root == null) {\n            return 0;\n        }\n        int left = depth(root.left);\n        int right = depth(root.right);\n        if (left == right) {\n            return (1 << left) + countNodes(root.right);\n        }\n        return (1 << right) + countNodes(root.left);\n    }\n\n    private int depth(TreeNode root) {\n        int d = 0;\n        for (; root != null; root = root.left) {\n            ++d;\n        }\n        return d;\n    }\n}",
    "223. Rectangle Area": "class Solution {\n    public int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {\n        int a = (ax2 - ax1) * (ay2 - ay1);\n        int b = (bx2 - bx1) * (by2 - by1);\n        int width = Math.min(ax2, bx2) - Math.max(ax1, bx1);\n        int height = Math.min(ay2, by2) - Math.max(ay1, by1);\n        return a + b - Math.max(height, 0) * Math.max(width, 0);\n    }\n}",
    "224. Basic Calculator": "class Solution {\n    public int calculate(String s) {\n        Deque<Integer> stk = new ArrayDeque<>();\n        int sign = 1;\n        int ans = 0;\n        int n = s.length();\n        for (int i = 0; i < n; ++i) {\n            char c = s.charAt(i);\n            if (Character.isDigit(c)) {\n                int j = i;\n                int x = 0;\n                while (j < n && Character.isDigit(s.charAt(j))) {\n                    x = x * 10 + s.charAt(j) - '0';\n                    j++;\n                }\n                ans += sign * x;\n                i = j - 1;\n            } else if (c == '+') {\n                sign = 1;\n            } else if (c == '-') {\n                sign = -1;\n            } else if (c == '(') {\n                stk.push(ans);\n                stk.push(sign);\n                ans = 0;\n                sign = 1;\n            } else if (c == ')') {\n                ans = stk.pop() * ans + stk.pop();\n            }\n        }\n        return ans;\n    }\n}",
    "225. Implement Stack using Queues": "import java.util.Deque;\n\nclass MyStack {\n    private Deque<Integer> q1 = new ArrayDeque<>();\n    private Deque<Integer> q2 = new ArrayDeque<>();\n\n    public MyStack() {\n    }\n\n    public void push(int x) {\n        q2.offer(x);\n        while (!q1.isEmpty()) {\n            q2.offer(q1.poll());\n        }\n        Deque<Integer> q = q1;\n        q1 = q2;\n        q2 = q;\n    }\n\n    public int pop() {\n        return q1.poll();\n    }\n\n    public int top() {\n        return q1.peek();\n    }\n\n    public boolean empty() {\n        return q1.isEmpty();\n    }\n}\n\n/**\n * Your MyStack object will be instantiated and called as such:\n * MyStack obj = new MyStack();\n * obj.push(x);\n * int param_2 = obj.pop();\n * int param_3 = obj.top();\n * boolean param_4 = obj.empty();\n */",
    "226. Invert Binary Tree": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public TreeNode invertTree(TreeNode root) {\n        dfs(root);\n        return root;\n    }\n\n    private void dfs(TreeNode root) {\n        if (root == null) {\n            return;\n        }\n        TreeNode t = root.left;\n        root.left = root.right;\n        root.right = t;\n        dfs(root.left);\n        dfs(root.right);\n    }\n}",
    "227. Basic Calculator II": "class Solution {\n    public int calculate(String s) {\n        Deque<Integer> stk = new ArrayDeque<>();\n        char sign = '+';\n        int v = 0;\n        for (int i = 0; i < s.length(); ++i) {\n            char c = s.charAt(i);\n            if (Character.isDigit(c)) {\n                v = v * 10 + (c - '0');\n            }\n            if (i == s.length() - 1 || c == '+' || c == '-' || c == '*' || c == '/') {\n                if (sign == '+') {\n                    stk.push(v);\n                } else if (sign == '-') {\n                    stk.push(-v);\n                } else if (sign == '*') {\n                    stk.push(stk.pop() * v);\n                } else {\n                    stk.push(stk.pop() / v);\n                }\n                sign = c;\n                v = 0;\n            }\n        }\n        int ans = 0;\n        while (!stk.isEmpty()) {\n            ans += stk.pop();\n        }\n        return ans;\n    }\n}",
    "228. Summary Ranges": "class Solution {\n    public List<String> summaryRanges(int[] nums) {\n        List<String> ans = new ArrayList<>();\n        for (int i = 0, j, n = nums.length; i < n; i = j + 1) {\n            j = i;\n            while (j + 1 < n && nums[j + 1] == nums[j] + 1) {\n                ++j;\n            }\n            ans.add(f(nums, i, j));\n        }\n        return ans;\n    }\n\n    private String f(int[] nums, int i, int j) {\n        return i == j ? nums[i] + \"\" : String.format(\"%d->%d\", nums[i], nums[j]);\n    }\n}",
    "229. Majority Element II": "class Solution {\n    public List<Integer> majorityElement(int[] nums) {\n        int n1 = 0, n2 = 0;\n        int m1 = 0, m2 = 1;\n        for (int m : nums) {\n            if (m == m1) {\n                ++n1;\n            } else if (m == m2) {\n                ++n2;\n            } else if (n1 == 0) {\n                m1 = m;\n                ++n1;\n            } else if (n2 == 0) {\n                m2 = m;\n                ++n2;\n            } else {\n                --n1;\n                --n2;\n            }\n        }\n        List<Integer> ans = new ArrayList<>();\n        n1 = 0;\n        n2 = 0;\n        for (int m : nums) {\n            if (m == m1) {\n                ++n1;\n            } else if (m == m2) {\n                ++n2;\n            }\n        }\n        if (n1 > nums.length / 3) {\n            ans.add(m1);\n        }\n        if (n2 > nums.length / 3) {\n            ans.add(m2);\n        }\n        return ans;\n    }\n}",
    "230. Kth Smallest Element in a BST": "import java.util.Comparator;\nimport java.util.PriorityQueue;\n\npublic class Kth_Smallest_Element_in_a_BST {\n    /**\n     * Definition for a binary tree node.\n     * public class TreeNode {\n     *     int val;\n     *     TreeNode left;\n     *     TreeNode right;\n     *     TreeNode(int x) { val = x; }\n     * }\n     */\n    class Solution {\n\n        PriorityQueue<Integer> heap = new PriorityQueue<>(new Comparator<Integer>() {\n            @Override\n            public int compare(Integer o1, Integer o2) {\n                return o2 - o1;\n            }\n        });\n\n        public int kthSmallest(TreeNode root, int k) {\n\n            dfs(root, k);\n\n            return heap.peek();\n        }\n\n        private void dfs(TreeNode root, int k) {\n\n            if (root == null) {\n                return;\n            }\n\n            // maintain heap\n            if (heap.size() < k) {\n                heap.offer(root.val);\n\n                // followup question, heap.remove() is by object, not index.\n                // so if delete operation, just remove element from both tree and heap\n\n            } else {\n                int val = root.val;\n                if (val < heap.peek()) {\n                    heap.poll();\n                    heap.offer(val);\n                }\n            }\n            dfs(root.left, k);\n            dfs(root.right, k);\n        }\n    }\n\n}\n\nclass Solution_followUp {\n    public int kthSmallest(TreeNode root, int k) {\n        MyTreeNode node = build(root);\n        return dfs(node, k);\n    }\n\n    class MyTreeNode {\n        int val;\n        int count; // key point to add up and find k-th element\n        MyTreeNode left;\n        MyTreeNode right;\n        MyTreeNode(int x) {\n            this.val = x;\n            this.count = 1;\n        }\n    };\n\n    MyTreeNode build(TreeNode root) {\n        if (root == null) return null;\n        MyTreeNode node = new MyTreeNode(root.val);\n        node.left = build(root.left);\n        node.right = build(root.right);\n        if (node.left != null) node.count += node.left.count;\n        if (node.right != null) node.count += node.right.count;\n        return node;\n    }\n\n    int dfs(MyTreeNode node, int k) {\n        if (node.left != null) {\n            int cnt = node.left.count;\n            if (k <= cnt) {\n                return dfs(node.left, k);\n            } else if (k > cnt + 1) {\n                return dfs(node.right, k - 1 - cnt); // -1 is to exclude current root\n            } else { // k == cnt + 1\n                return node.val;\n            }\n        } else {\n            if (k == 1) return node.val;\n            return dfs(node.right, k - 1);\n        }\n    }\n}\n\n############\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public int kthSmallest(TreeNode root, int k) {\n        Deque<TreeNode> stk = new ArrayDeque<>();\n        while (root != null || !stk.isEmpty()) {\n            if (root != null) {\n                stk.push(root);\n                root = root.left;\n            } else {\n                root = stk.pop();\n                if (--k == 0) {\n                    return root.val;\n                }\n                root = root.right;\n            }\n        }\n        return 0;\n    }\n}",
    "231. Power of Two": "class Solution {\n    public boolean isPowerOfTwo(int n) {\n        return n > 0 && (n & (n - 1)) == 0;\n    }\n}",
    "232. Implement Queue using Stacks": "public class Implement_Queue_using_Stacks {\n    class MyQueue {\n        private Stack<Integer> stack1;\n        private Stack<Integer> stack2;\n\n        public MyQueue() {\n            this.stack1 = new Stack<Integer>();\n            this.stack2 = new Stack<Integer>();\n        }\n        // Push element x to the back of queue.\n        public void push(int x) {\n            stack1.push(x);\n        }\n\n        // Removes the element from in front of queue.\n        public int pop() {\n            if (!stack2.isEmpty()) {\n                return stack2.pop(); // stack is queue-order, queue-head at this-stack-top\n            } else {\n                while (!stack1.isEmpty()) {\n                    stack2.push(stack1.pop());\n                }\n                return stack2.pop();\n            }\n        }\n\n        // Get the front element.\n        public int peek() {\n            int ret = 0;\n            if (!stack2.isEmpty()) {\n                ret = stack2.peek();\n            } else {\n                while (!stack1.isEmpty()) {\n                    stack2.push(stack1.pop());\n                }\n                ret = stack2.peek();\n            }\n\n            return ret;\n        }\n\n        // Return whether the queue is empty.\n        public boolean empty() {\n            return stack1.isEmpty() && stack2.isEmpty();\n        }\n    }\n}\n\n############\n\nclass MyQueue {\n    private Deque<Integer> stk1 = new ArrayDeque<>();\n    private Deque<Integer> stk2 = new ArrayDeque<>();\n\n    public MyQueue() {\n    }\n\n    public void push(int x) {\n        stk1.push(x);\n    }\n\n    public int pop() {\n        move();\n        return stk2.pop();\n    }\n\n    public int peek() {\n        move();\n        return stk2.peek();\n    }\n\n    public boolean empty() {\n        return stk1.isEmpty() && stk2.isEmpty();\n    }\n\n    private void move() {\n        while (stk2.isEmpty()) {\n            while (!stk1.isEmpty()) {\n                stk2.push(stk1.pop());\n            }\n        }\n    }\n}\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue obj = new MyQueue();\n * obj.push(x);\n * int param_2 = obj.pop();\n * int param_3 = obj.peek();\n * boolean param_4 = obj.empty();\n */",
    "233. Number of Digit One": "class Solution {\n    private int[] a = new int[12];\n    private int[][] dp = new int[12][12];\n\n    public int countDigitOne(int n) {\n        int len = 0;\n        while (n > 0) {\n            a[++len] = n % 10;\n            n /= 10;\n        }\n        for (var e : dp) {\n            Arrays.fill(e, -1);\n        }\n        return dfs(len, 0, true);\n    }\n\n    private int dfs(int pos, int cnt, boolean limit) {\n        if (pos <= 0) {\n            return cnt;\n        }\n        if (!limit && dp[pos][cnt] != -1) {\n            return dp[pos][cnt];\n        }\n        int up = limit ? a[pos] : 9;\n        int ans = 0;\n        for (int i = 0; i <= up; ++i) {\n            ans += dfs(pos - 1, cnt + (i == 1 ? 1 : 0), limit && i == up);\n        }\n        if (!limit) {\n            dp[pos][cnt] = ans;\n        }\n        return ans;\n    }\n}",
    "234. Palindrome Linked List": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public boolean isPalindrome(ListNode head) {\n        ListNode slow = head;\n        ListNode fast = head.next;\n        while (fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        ListNode cur = slow.next;\n        slow.next = null;\n        ListNode pre = null;\n        while (cur != null) {\n            ListNode t = cur.next;\n            cur.next = pre;\n            pre = cur;\n            cur = t;\n        }\n        while (pre != null) {\n            if (pre.val != head.val) {\n                return false;\n            }\n            pre = pre.next;\n            head = head.next;\n        }\n        return true;\n    }\n}",
    "235. Lowest Common Ancestor of a Binary Search Tree": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\n\nclass Solution {\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n        while (true) {\n            if (root.val < Math.min(p.val, q.val)) {\n                root = root.right;\n            } else if (root.val > Math.max(p.val, q.val)) {\n                root = root.left;\n            } else {\n                return root;\n            }\n        }\n    }\n}",
    "236. Lowest Common Ancestor of a Binary Tree": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n        if (root == null || root == p || root == q) return root;\n        TreeNode left = lowestCommonAncestor(root.left, p, q);\n        TreeNode right = lowestCommonAncestor(root.right, p, q);\n        if (left == null) return right;\n        if (right == null) return left;\n        return root;\n    }\n}",
    "237. Delete Node in a Linked List": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public void deleteNode(ListNode node) {\n        node.val = node.next.val;\n        node.next = node.next.next;\n    }\n}",
    "238. Product of Array Except Self": "class Solution {\n    public int[] productExceptSelf(int[] nums) {\n        int n = nums.length;\n        int[] ans = new int[n];\n        for (int i = 0, left = 1; i < n; ++i) {\n            ans[i] = left;\n            left *= nums[i];\n        }\n        for (int i = n - 1, right = 1; i >= 0; --i) {\n            ans[i] *= right;\n            right *= nums[i];\n        }\n        return ans;\n    }\n}",
    "239. Sliding Window Maximum": "import java.util.ArrayDeque;\nimport java.util.Arrays;\nimport java.util.Deque;\n\npublic class Sliding_Window_Maximum {\n\n    public static void main(String[] args) {\n        Sliding_Window_Maximum out = new Sliding_Window_Maximum();\n        Solution s = out.new Solution();\n\n        System.out.println(Arrays.toString(s.maxSlidingWindow(new int[]{1,3,-1,-3,5,3,6,7}, 3)));\n    }\n\n    /*\n        Deque<String> dq = new ArrayDeque<>();\n        dq.offer(\"a\");\n        dq.offer(\"b\");\n        dq.offer(\"c\");\n        System.out.println(dq.peek()); // a\n        System.out.println(dq.peekFirst()); // a\n        System.out.println(dq.peekLast()); // c\n     */\n\n    class Solution {\n        public int[] maxSlidingWindow(int[] nums, int k) {\n            if (nums == null || nums.length == 0) {\n                return new int[0];\n            }\n\n            int n = nums.length;\n            int[] result = new int[n - k + 1];\n            int resultPointer = 0;\n\n            // store index of nums array\n            // q is descending values (its indexes)\n            // eg. [6,5,4,3,2,1], q will be: [6,5,4], then [5,4,3], then [4,3,2], then [3,2,1]\n            Deque<Integer> q =  new ArrayDeque<>();\n\n            for (int i = 0; i < nums.length; i++) {\n                // remove index not in k-window\n                while (!q.isEmpty() && q.peek() < i - k + 1) { // peek() head of queue\n                    q.poll();\n                }\n\n                // remove use-less index in q\n                while (!q.isEmpty() && nums[q.peekLast()] < nums[i]) { // peekLast() last of queue\n                    q.pollLast();\n                }\n\n                q.offer(i);\n\n                // start from k-th element, there is a max for window\n                if (i >= k - 1) {\n                    result[resultPointer] = nums[q.peek()];\n                    resultPointer++;\n                }\n            }\n\n            return result;\n        }\n    }\n}\n\n############\n\nclass Solution {\n    public int[] maxSlidingWindow(int[] nums, int k) {\n        int n = nums.length;\n        int[] ans = new int[n - k + 1];\n        Deque<Integer> q = new ArrayDeque<>();\n        for (int i = 0, j = 0; i < n; ++i) {\n            if (!q.isEmpty() && i - k + 1 > q.peekFirst()) {\n                q.pollFirst();\n            }\n            while (!q.isEmpty() && nums[q.peekLast()] <= nums[i]) {\n                q.pollLast();\n            }\n            q.offer(i);\n            if (i >= k - 1) {\n                ans[j++] = nums[q.peekFirst()];\n            }\n        }\n        return ans;\n    }\n}"
}